(function (global) {
  var process = {
    title: 'browser',
    browser: true,
    env: {},
    argv: [],
    nextTick: function (fn) {
      setTimeout(fn, 0)
    },
    cwd: function () {
      return '/'
    },
    chdir: function () {
    }
  };
  // Require a module
  function rqzt(file, callback) {
    if ({}.hasOwnProperty.call(rqzt.cache, file))
      return rqzt.cache[file];
    // Handle async require
    if (typeof callback == 'function') {
      rqzt.load(file, callback);
      return
    }
    var resolved = rqzt.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
      id: file,
      rqzt: rqzt,
      filename: file,
      exports: {},
      loaded: false,
      parent: null,
      children: []
    };
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    rqzt.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return rqzt.cache[file] = module$.exports
  }
  rqzt.modules = {};
  rqzt.cache = {};
  rqzt.resolve = function (file) {
    return {}.hasOwnProperty.call(rqzt.modules, file) ? rqzt.modules[file] : void 0
  };
  // Define normal static module
  rqzt.define = function (file, fn) {
    rqzt.modules[file] = fn
  };
  global.require = rqzt;
  // source: node_modules/riot/riot.js
  rqzt.define('riot/riot', function (module, exports, __dirname, __filename, process) {
    /* Riot v2.2.4, @license MIT, (c) 2015 Muut Inc. + contributors */
    ;
    (function (window, undefined) {
      'use strict';
      var riot = {
          version: 'v2.2.4',
          settings: {}
        },
        //// be aware, internal usage
        // counter to give a unique id to all the Tag instances
        __uid = 0,
        // riot specific prefixes
        RIOT_PREFIX = 'riot-', RIOT_TAG = RIOT_PREFIX + 'tag',
        // for typeof == '' comparisons
        T_STRING = 'string', T_OBJECT = 'object', T_UNDEF = 'undefined', T_FUNCTION = 'function',
        // special native tags that cannot be treated like the others
        SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/, RESERVED_WORDS_BLACKLIST = [
          '_item',
          '_id',
          'update',
          'root',
          'mount',
          'unmount',
          'mixin',
          'isMounted',
          'isLoop',
          'tags',
          'parent',
          'opts',
          'trigger',
          'on',
          'off',
          'one'
        ],
        // version# for IE 8-11, 0 for others
        IE_VERSION = (window && window.document || {}).documentMode | 0,
        // Array.isArray for IE8 is in the polyfills
        isArray = Array.isArray;
      riot.observable = function (el) {
        el = el || {};
        var callbacks = {}, _id = 0;
        el.on = function (events, fn) {
          if (isFunction(fn)) {
            if (typeof fn.id === T_UNDEF)
              fn._id = _id++;
            events.replace(/\S+/g, function (name, pos) {
              (callbacks[name] = callbacks[name] || []).push(fn);
              fn.typed = pos > 0
            })
          }
          return el
        };
        el.off = function (events, fn) {
          if (events == '*')
            callbacks = {};
          else {
            events.replace(/\S+/g, function (name) {
              if (fn) {
                var arr = callbacks[name];
                for (var i = 0, cb; cb = arr && arr[i]; ++i) {
                  if (cb._id == fn._id)
                    arr.splice(i--, 1)
                }
              } else {
                callbacks[name] = []
              }
            })
          }
          return el
        };
        // only single event supported
        el.one = function (name, fn) {
          function on() {
            el.off(name, on);
            fn.apply(el, arguments)
          }
          return el.on(name, on)
        };
        el.trigger = function (name) {
          var args = [].slice.call(arguments, 1), fns = callbacks[name] || [];
          for (var i = 0, fn; fn = fns[i]; ++i) {
            if (!fn.busy) {
              fn.busy = 1;
              fn.apply(el, fn.typed ? [name].concat(args) : args);
              if (fns[i] !== fn) {
                i--
              }
              fn.busy = 0
            }
          }
          if (callbacks.all && name != 'all') {
            el.trigger.apply(el, [
              'all',
              name
            ].concat(args))
          }
          return el
        };
        return el
      };
      riot.mixin = function () {
        var mixins = {};
        return function (name, mixin) {
          if (!mixin)
            return mixins[name];
          mixins[name] = mixin
        }
      }();
      (function (riot, evt, win) {
        // browsers only
        if (!win)
          return;
        var loc = win.location, fns = riot.observable(), started = false, current;
        function hash() {
          return loc.href.split('#')[1] || ''  // why not loc.hash.splice(1) ?
        }
        function parser(path) {
          return path.split('/')
        }
        function emit(path) {
          if (path.type)
            path = hash();
          if (path != current) {
            fns.trigger.apply(null, ['H'].concat(parser(path)));
            current = path
          }
        }
        var r = riot.route = function (arg) {
          // string
          if (arg[0]) {
            loc.hash = arg;
            emit(arg)  // function
          } else {
            fns.on('H', arg)
          }
        };
        r.exec = function (fn) {
          fn.apply(null, parser(hash()))
        };
        r.parser = function (fn) {
          parser = fn
        };
        r.stop = function () {
          if (started) {
            if (win.removeEventListener)
              win.removeEventListener(evt, emit, false)  //@IE8 - the if()
;
            else
              win.detachEvent('on' + evt, emit);
            //@IE8
            fns.off('*');
            started = false
          }
        };
        r.start = function () {
          if (!started) {
            if (win.addEventListener)
              win.addEventListener(evt, emit, false)  //@IE8 - the if()
;
            else
              win.attachEvent('on' + evt, emit);
            //IE8
            started = true
          }
        };
        // autostart the router
        r.start()
      }(riot, 'hashchange', window));
      /*

//// How it works?


Three ways:

1. Expressions: tmpl('{ value }', data).
   Returns the result of evaluated expression as a raw object.

2. Templates: tmpl('Hi { name } { surname }', data).
   Returns a string with evaluated expressions.

3. Filters: tmpl('{ show: !done, highlight: active }', data).
   Returns a space separated list of trueish keys (mainly
   used for setting html classes), e.g. "show highlight".


// Template examples

tmpl('{ title || "Untitled" }', data)
tmpl('Results are { results ? "ready" : "loading" }', data)
tmpl('Today is { new Date() }', data)
tmpl('{ message.length > 140 && "Message is too long" }', data)
tmpl('This item got { Math.round(rating) } stars', data)
tmpl('<h1>{ title }</h1>{ body }', data)


// Falsy expressions in templates

In templates (as opposed to single expressions) all falsy values
except zero (undefined/null/false) will default to empty string:

tmpl('{ undefined } - { false } - { null } - { 0 }', {})
// will return: " - - - 0"

*/
      var brackets = function (orig) {
        var cachedBrackets, r, b, re = /[{}]/g;
        return function (x) {
          // make sure we use the current setting
          var s = riot.settings.brackets || orig;
          // recreate cached vars if needed
          if (cachedBrackets !== s) {
            cachedBrackets = s;
            b = s.split(' ');
            r = b.map(function (e) {
              return e.replace(/(?=.)/g, '\\')
            })
          }
          // if regexp given, rewrite it with current brackets (only if differ from default)
          return x instanceof RegExp ? s === orig ? x : new RegExp(x.source.replace(re, function (b) {
            return r[~~(b === '}')]
          }), x.global ? 'g' : '') : // else, get specific bracket
          b[x]
        }
      }('{ }');
      var tmpl = function () {
        var cache = {}, OGLOB = '"in d?d:' + (window ? 'window).' : 'global).'), reVars = /(['"\/])(?:[^\\]*?|\\.|.)*?\1|\.\w*|\w*:|\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\b|function\s*\()|([A-Za-z_$]\w*)/g;
        // build a template (or get it from cache), render with data
        return function (str, data) {
          return str && (cache[str] || (cache[str] = tmpl(str)))(data)
        };
        // create a template instance
        function tmpl(s, p) {
          if (s.indexOf(brackets(0)) < 0) {
            // return raw text
            s = s.replace(/\n|\r\n?/g, '\n');
            return function () {
              return s
            }
          }
          // temporarily convert \{ and \} to a non-character
          s = s.replace(brackets(/\\{/g), '￰').replace(brackets(/\\}/g), '￱');
          // split string to expression and non-expresion parts
          p = split(s, extract(s, brackets(/{/), brackets(/}/)));
          // is it a single expression or a template? i.e. {x} or <b>{x}</b>
          s = p.length === 2 && !p[0] ? // if expression, evaluate it
          expr(p[1]) : // if template, evaluate all expressions in it
          '[' + p.map(function (s, i) {
            // is it an expression or a string (every second part is an expression)
            return i % 2 ? // evaluate the expressions
            expr(s, true) : // process string parts of the template:
            '"' + s  // preserve new lines
.replace(/\n|\r\n?/g, '\\n')  // escape quotes
.replace(/"/g, '\\"') + '"'
          }).join(',') + '].join("")';
          return new Function('d', 'return ' + s  // bring escaped { and } back
.replace(/\uFFF0/g, brackets(0)).replace(/\uFFF1/g, brackets(1)) + ';')
        }
        // parse { ... } expression
        function expr(s, n) {
          s = s  // convert new lines to spaces
.replace(/\n|\r\n?/g, ' ')  // trim whitespace, brackets, strip comments
.replace(brackets(/^[{ ]+|[ }]+$|\/\*.+?\*\//g), '');
          // is it an object literal? i.e. { key : value }
          return /^\s*[\w- "']+ *:/.test(s) ? // if object literal, return trueish keys
          // e.g.: { show: isOpen(), done: item.done } -> "show done"
          '[' + // extract key:val pairs, ignoring any nested objects
          extract(s, // name part: name:, "name":, 'name':, name :
          /["' ]*[\w- ]+["' ]*:/, // expression part: everything upto a comma followed by a name (see above) or end of line
          /,(?=["' ]*[\w- ]+["' ]*:)|}|$/).map(function (pair) {
            // get key, val parts
            return pair.replace(/^[ "']*(.+?)[ "']*: *(.+?),? *$/, function (_, k, v) {
              // wrap all conditional parts to ignore errors
              return v.replace(/[^&|=!><]+/g, wrap) + '?"' + k + '":"",'
            })
          }).join('') + '].join(" ").trim()' : // if js expression, evaluate as javascript
          wrap(s, n)
        }
        // execute js w/o breaking on errors or undefined vars
        function wrap(s, nonull) {
          s = s.trim();
          return !s ? '' : '(function(v){try{v=' + // prefix vars (name => data.name)
          s.replace(reVars, function (s, _, v) {
            return v ? '(("' + v + OGLOB + v + ')' : s
          }) + // default to empty string for falsy values except zero
          '}catch(e){}return ' + (nonull === true ? '!v&&v!==0?"":v' : 'v') + '}).call(d)'
        }
        // split string by an array of substrings
        function split(str, substrings) {
          var parts = [];
          substrings.map(function (sub, i) {
            // push matched expression and part before it
            i = str.indexOf(sub);
            parts.push(str.slice(0, i), sub);
            str = str.slice(i + sub.length)
          });
          if (str)
            parts.push(str);
          // push the remaining part
          return parts
        }
        // match strings between opening and closing regexp, skipping any inner/nested matches
        function extract(str, open, close) {
          var start, level = 0, matches = [], re = new RegExp('(' + open.source + ')|(' + close.source + ')', 'g');
          str.replace(re, function (_, open, close, pos) {
            // if outer inner bracket, mark position
            if (!level && open)
              start = pos;
            // in(de)crease bracket level
            level += open ? 1 : -1;
            // if outer closing bracket, grab the match
            if (!level && close != null)
              matches.push(str.slice(start, pos + close.length))
          });
          return matches
        }
      }();
      /*
  lib/browser/tag/mkdom.js

  Includes hacks needed for the Internet Explorer version 9 and bellow

*/
      // http://kangax.github.io/compat-table/es5/#ie8
      // http://codeplanet.io/dropping-ie8/
      var mkdom = function (checkIE) {
        var rootEls = {
            'tr': 'tbody',
            'th': 'tr',
            'td': 'tr',
            'tbody': 'table',
            'col': 'colgroup'
          }, GENERIC = 'div';
        checkIE = checkIE && checkIE < 10;
        // creates any dom element in a div, table, or colgroup container
        function _mkdom(html) {
          var match = html && html.match(/^\s*<([-\w]+)/), tagName = match && match[1].toLowerCase(), rootTag = rootEls[tagName] || GENERIC, el = mkEl(rootTag);
          el.stub = true;
          if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))
            ie9elem(el, html, tagName, !!match[1]);
          else
            el.innerHTML = html;
          return el
        }
        // creates tr, th, td, option, optgroup element for IE8-9
        /* istanbul ignore next */
        function ie9elem(el, html, tagName, select) {
          var div = mkEl(GENERIC), tag = select ? 'select>' : 'table>', child;
          div.innerHTML = '<' + tag + html + '</' + tag;
          child = div.getElementsByTagName(tagName)[0];
          if (child)
            el.appendChild(child)
        }
        // end ie9elem()
        return _mkdom
      }(IE_VERSION);
      // { key, i in items} -> { key, i, items }
      function loopKeys(expr) {
        var b0 = brackets(0), els = expr.trim().slice(b0.length).match(/^\s*(\S+?)\s*(?:,\s*(\S+))?\s+in\s+(.+)$/);
        return els ? {
          key: els[1],
          pos: els[2],
          val: b0 + els[3]
        } : { val: expr }
      }
      function mkitem(expr, key, val) {
        var item = {};
        item[expr.key] = key;
        if (expr.pos)
          item[expr.pos] = val;
        return item
      }
      /* Beware: heavy stuff */
      function _each(dom, parent, expr) {
        remAttr(dom, 'each');
        var tagName = getTagName(dom), template = dom.outerHTML, hasImpl = !!tagImpl[tagName], impl = tagImpl[tagName] || { tmpl: template }, root = dom.parentNode, placeholder = document.createComment('riot placeholder'), tags = [], child = getTag(dom), checksum;
        root.insertBefore(placeholder, dom);
        expr = loopKeys(expr);
        // clean template code
        parent.one('premount', function () {
          if (root.stub)
            root = parent.root;
          // remove the original DOM node
          dom.parentNode.removeChild(dom)
        }).on('update', function () {
          var items = tmpl(expr.val, parent);
          // object loop. any changes cause full redraw
          if (!isArray(items)) {
            checksum = items ? JSON.stringify(items) : '';
            items = !items ? [] : Object.keys(items).map(function (key) {
              return mkitem(expr, key, items[key])
            })
          }
          var frag = document.createDocumentFragment(), i = tags.length, j = items.length;
          // unmount leftover items
          while (i > j) {
            tags[--i].unmount();
            tags.splice(i, 1)
          }
          for (i = 0; i < j; ++i) {
            var _item = !checksum && !!expr.key ? mkitem(expr, items[i], i) : items[i];
            if (!tags[i]) {
              // mount new
              (tags[i] = new Tag(impl, {
                parent: parent,
                isLoop: true,
                hasImpl: hasImpl,
                root: SPECIAL_TAGS_REGEX.test(tagName) ? root : dom.cloneNode(),
                item: _item
              }, dom.innerHTML)).mount();
              frag.appendChild(tags[i].root)
            } else
              tags[i].update(_item);
            tags[i]._item = _item
          }
          root.insertBefore(frag, placeholder);
          if (child)
            parent.tags[tagName] = tags
        }).one('updated', function () {
          var keys = Object.keys(parent);
          // only set new values
          walk(root, function (node) {
            // only set element node and not isLoop
            if (node.nodeType == 1 && !node.isLoop && !node._looped) {
              node._visited = false;
              // reset _visited for loop node
              node._looped = true;
              // avoid set multiple each
              setNamed(node, parent, keys)
            }
          })
        })
      }
      function parseNamedElements(root, tag, childTags) {
        walk(root, function (dom) {
          if (dom.nodeType == 1) {
            dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || dom.getAttribute('each')) ? 1 : 0;
            // custom child tag
            var child = getTag(dom);
            if (child && !dom.isLoop) {
              childTags.push(initChildTag(child, dom, tag))
            }
            if (!dom.isLoop)
              setNamed(dom, tag, [])
          }
        })
      }
      function parseExpressions(root, tag, expressions) {
        function addExpr(dom, val, extra) {
          if (val.indexOf(brackets(0)) >= 0) {
            var expr = {
              dom: dom,
              expr: val
            };
            expressions.push(extend(expr, extra))
          }
        }
        walk(root, function (dom) {
          var type = dom.nodeType;
          // text node
          if (type == 3 && dom.parentNode.tagName != 'STYLE')
            addExpr(dom, dom.nodeValue);
          if (type != 1)
            return;
          /* element */
          // loop
          var attr = dom.getAttribute('each');
          if (attr) {
            _each(dom, tag, attr);
            return false
          }
          // attribute expressions
          each(dom.attributes, function (attr) {
            var name = attr.name, bool = name.split('__')[1];
            addExpr(dom, attr.value, {
              attr: bool || name,
              bool: bool
            });
            if (bool) {
              remAttr(dom, name);
              return false
            }
          });
          // skip custom tags
          if (getTag(dom))
            return false
        })
      }
      function Tag(impl, conf, innerHTML) {
        var self = riot.observable(this), opts = inherit(conf.opts) || {}, dom = mkdom(impl.tmpl), parent = conf.parent, isLoop = conf.isLoop, hasImpl = conf.hasImpl, item = cleanUpData(conf.item), expressions = [], childTags = [], root = conf.root, fn = impl.fn, tagName = root.tagName.toLowerCase(), attr = {}, propsInSyncWithParent = [];
        if (fn && root._tag) {
          root._tag.unmount(true)
        }
        // not yet mounted
        this.isMounted = false;
        root.isLoop = isLoop;
        // keep a reference to the tag just created
        // so we will be able to mount this tag multiple times
        root._tag = this;
        // create a unique id to this tag
        // it could be handy to use it also to improve the virtual dom rendering speed
        this._id = __uid++;
        extend(this, {
          parent: parent,
          root: root,
          opts: opts,
          tags: {}
        }, item);
        // grab attributes
        each(root.attributes, function (el) {
          var val = el.value;
          // remember attributes with expressions only
          if (brackets(/{.*}/).test(val))
            attr[el.name] = val
        });
        if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))
          // replace all the yield tags with the tag inner html
          dom.innerHTML = replaceYield(dom.innerHTML, innerHTML);
        // options
        function updateOpts() {
          var ctx = hasImpl && isLoop ? self : parent || self;
          // update opts from current DOM attributes
          each(root.attributes, function (el) {
            opts[el.name] = tmpl(el.value, ctx)
          });
          // recover those with expressions
          each(Object.keys(attr), function (name) {
            opts[name] = tmpl(attr[name], ctx)
          })
        }
        function normalizeData(data) {
          for (var key in item) {
            if (typeof self[key] !== T_UNDEF)
              self[key] = data[key]
          }
        }
        function inheritFromParent() {
          if (!self.parent || !isLoop)
            return;
          each(Object.keys(self.parent), function (k) {
            // some properties must be always in sync with the parent tag
            var mustSync = !~RESERVED_WORDS_BLACKLIST.indexOf(k) && ~propsInSyncWithParent.indexOf(k);
            if (typeof self[k] === T_UNDEF || mustSync) {
              // track the property to keep in sync
              // so we can keep it updated
              if (!mustSync)
                propsInSyncWithParent.push(k);
              self[k] = self.parent[k]
            }
          })
        }
        this.update = function (data) {
          // make sure the data passed will not override
          // the component core methods
          data = cleanUpData(data);
          // inherit properties from the parent
          inheritFromParent();
          // normalize the tag properties in case an item object was initially passed
          if (data && typeof item === T_OBJECT) {
            normalizeData(data);
            item = data
          }
          extend(self, data);
          updateOpts();
          self.trigger('update', data);
          update(expressions, self);
          self.trigger('updated')
        };
        this.mixin = function () {
          each(arguments, function (mix) {
            mix = typeof mix === T_STRING ? riot.mixin(mix) : mix;
            each(Object.keys(mix), function (key) {
              // bind methods to self
              if (key != 'init')
                self[key] = isFunction(mix[key]) ? mix[key].bind(self) : mix[key]
            });
            // init method will be called automatically
            if (mix.init)
              mix.init.bind(self)()
          })
        };
        this.mount = function () {
          updateOpts();
          // initialiation
          if (fn)
            fn.call(self, opts);
          // parse layout after init. fn may calculate args for nested custom tags
          parseExpressions(dom, self, expressions);
          // mount the child tags
          toggle(true);
          // update the root adding custom attributes coming from the compiler
          // it fixes also #1087
          if (impl.attrs || hasImpl) {
            walkAttributes(impl.attrs, function (k, v) {
              root.setAttribute(k, v)
            });
            parseExpressions(self.root, self, expressions)
          }
          if (!self.parent || isLoop)
            self.update(item);
          // internal use only, fixes #403
          self.trigger('premount');
          if (isLoop && !hasImpl) {
            // update the root attribute for the looped elements
            self.root = root = dom.firstChild
          } else {
            while (dom.firstChild)
              root.appendChild(dom.firstChild);
            if (root.stub)
              self.root = root = parent.root
          }
          // if it's not a child tag we can trigger its mount event
          if (!self.parent || self.parent.isMounted) {
            self.isMounted = true;
            self.trigger('mount')
          }  // otherwise we need to wait that the parent event gets triggered
          else
            self.parent.one('mount', function () {
              // avoid to trigger the `mount` event for the tags
              // not visible included in an if statement
              if (!isInStub(self.root)) {
                self.parent.isMounted = self.isMounted = true;
                self.trigger('mount')
              }
            })
        };
        this.unmount = function (keepRootTag) {
          var el = root, p = el.parentNode, ptag;
          if (p) {
            if (parent) {
              ptag = getImmediateCustomParentTag(parent);
              // remove this tag from the parent tags object
              // if there are multiple nested tags with same name..
              // remove this element form the array
              if (isArray(ptag.tags[tagName]))
                each(ptag.tags[tagName], function (tag, i) {
                  if (tag._id == self._id)
                    ptag.tags[tagName].splice(i, 1)
                });
              else
                // otherwise just delete the tag instance
                ptag.tags[tagName] = undefined
            } else
              while (el.firstChild)
                el.removeChild(el.firstChild);
            if (!keepRootTag)
              p.removeChild(el);
            else
              // the riot-tag attribute isn't needed anymore, remove it
              p.removeAttribute('riot-tag')
          }
          self.trigger('unmount');
          toggle();
          self.off('*');
          // somehow ie8 does not like `delete root._tag`
          root._tag = null
        };
        function toggle(isMount) {
          // mount/unmount children
          each(childTags, function (child) {
            child[isMount ? 'mount' : 'unmount']()
          });
          // listen/unlisten parent (events flow one way from parent to children)
          if (parent) {
            var evt = isMount ? 'on' : 'off';
            // the loop tags will be always in sync with the parent automatically
            if (isLoop)
              parent[evt]('unmount', self.unmount);
            else
              parent[evt]('update', self.update)[evt]('unmount', self.unmount)
          }
        }
        // named elements available for fn
        parseNamedElements(dom, this, childTags)
      }
      function setEventHandler(name, handler, dom, tag) {
        dom[name] = function (e) {
          var item = tag._item, ptag = tag.parent, el;
          if (!item)
            while (ptag && !item) {
              item = ptag._item;
              ptag = ptag.parent
            }
          // cross browser event fix
          e = e || window.event;
          // ignore error on some browsers
          try {
            e.currentTarget = dom;
            if (!e.target)
              e.target = e.srcElement;
            if (!e.which)
              e.which = e.charCode || e.keyCode
          } catch (ignored) {
          }
          e.item = item;
          // prevent default behaviour (by default)
          if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {
            if (e.preventDefault)
              e.preventDefault();
            e.returnValue = false
          }
          if (!e.preventUpdate) {
            el = item ? getImmediateCustomParentTag(ptag) : tag;
            el.update()
          }
        }
      }
      // used by if- attribute
      function insertTo(root, node, before) {
        if (root) {
          root.insertBefore(before, node);
          root.removeChild(node)
        }
      }
      function update(expressions, tag) {
        each(expressions, function (expr, i) {
          var dom = expr.dom, attrName = expr.attr, value = tmpl(expr.expr, tag), parent = expr.dom.parentNode;
          if (expr.bool)
            value = value ? attrName : false;
          else if (value == null)
            value = '';
          // leave out riot- prefixes from strings inside textarea
          // fix #815: any value -> string
          if (parent && parent.tagName == 'TEXTAREA')
            value = ('' + value).replace(/riot-/g, '');
          // no change
          if (expr.value === value)
            return;
          expr.value = value;
          // text node
          if (!attrName) {
            dom.nodeValue = '' + value;
            // #815 related
            return
          }
          // remove original attribute
          remAttr(dom, attrName);
          // event handler
          if (isFunction(value)) {
            setEventHandler(attrName, value, dom, tag)  // if- conditional
          } else if (attrName == 'if') {
            var stub = expr.stub, add = function () {
                insertTo(stub.parentNode, stub, dom)
              }, remove = function () {
                insertTo(dom.parentNode, dom, stub)
              };
            // add to DOM
            if (value) {
              if (stub) {
                add();
                dom.inStub = false;
                // avoid to trigger the mount event if the tags is not visible yet
                // maybe we can optimize this avoiding to mount the tag at all
                if (!isInStub(dom)) {
                  walk(dom, function (el) {
                    if (el._tag && !el._tag.isMounted)
                      el._tag.isMounted = !!el._tag.trigger('mount')
                  })
                }
              }  // remove from DOM
            } else {
              stub = expr.stub = stub || document.createTextNode('');
              // if the parentNode is defined we can easily replace the tag
              if (dom.parentNode)
                remove();
              else
                // otherwise we need to wait the updated event
                (tag.parent || tag).one('updated', remove);
              dom.inStub = true
            }  // show / hide
          } else if (/^(show|hide)$/.test(attrName)) {
            if (attrName == 'hide')
              value = !value;
            dom.style.display = value ? '' : 'none'  // field value
          } else if (attrName == 'value') {
            dom.value = value  // <img src="{ expr }">
          } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {
            if (value)
              dom.setAttribute(attrName.slice(RIOT_PREFIX.length), value)
          } else {
            if (expr.bool) {
              dom[attrName] = value;
              if (!value)
                return
            }
            if (typeof value !== T_OBJECT)
              dom.setAttribute(attrName, value)
          }
        })
      }
      function each(els, fn) {
        for (var i = 0, len = (els || []).length, el; i < len; i++) {
          el = els[i];
          // return false -> remove current item during loop
          if (el != null && fn(el, i) === false)
            i--
        }
        return els
      }
      function isFunction(v) {
        return typeof v === T_FUNCTION || false  // avoid IE problems
      }
      function remAttr(dom, name) {
        dom.removeAttribute(name)
      }
      function getTag(dom) {
        return dom.tagName && tagImpl[dom.getAttribute(RIOT_TAG) || dom.tagName.toLowerCase()]
      }
      function initChildTag(child, dom, parent) {
        var tag = new Tag(child, {
            root: dom,
            parent: parent
          }, dom.innerHTML), tagName = getTagName(dom), ptag = getImmediateCustomParentTag(parent), cachedTag;
        // fix for the parent attribute in the looped elements
        tag.parent = ptag;
        cachedTag = ptag.tags[tagName];
        // if there are multiple children tags having the same name
        if (cachedTag) {
          // if the parent tags property is not yet an array
          // create it adding the first cached tag
          if (!isArray(cachedTag))
            ptag.tags[tagName] = [cachedTag];
          // add the new nested tag to the array
          if (!~ptag.tags[tagName].indexOf(tag))
            ptag.tags[tagName].push(tag)
        } else {
          ptag.tags[tagName] = tag
        }
        // empty the child node once we got its template
        // to avoid that its children get compiled multiple times
        dom.innerHTML = '';
        return tag
      }
      function getImmediateCustomParentTag(tag) {
        var ptag = tag;
        while (!getTag(ptag.root)) {
          if (!ptag.parent)
            break;
          ptag = ptag.parent
        }
        return ptag
      }
      function getTagName(dom) {
        var child = getTag(dom), namedTag = dom.getAttribute('name'), tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child ? child.name : dom.tagName.toLowerCase();
        return tagName
      }
      function extend(src) {
        var obj, args = arguments;
        for (var i = 1; i < args.length; ++i) {
          if (obj = args[i]) {
            for (var key in obj) {
              // eslint-disable-line guard-for-in
              src[key] = obj[key]
            }
          }
        }
        return src
      }
      // with this function we avoid that the current Tag methods get overridden
      function cleanUpData(data) {
        if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))
          return data;
        var o = {};
        for (var key in data) {
          if (!~RESERVED_WORDS_BLACKLIST.indexOf(key))
            o[key] = data[key]
        }
        return o
      }
      function walk(dom, fn) {
        if (dom) {
          if (fn(dom) === false)
            return;
          else {
            dom = dom.firstChild;
            while (dom) {
              walk(dom, fn);
              dom = dom.nextSibling
            }
          }
        }
      }
      // minimize risk: only zero or one _space_ between attr & value
      function walkAttributes(html, fn) {
        var m, re = /([-\w]+) ?= ?(?:"([^"]*)|'([^']*)|({[^}]*}))/g;
        while (m = re.exec(html)) {
          fn(m[1].toLowerCase(), m[2] || m[3] || m[4])
        }
      }
      function isInStub(dom) {
        while (dom) {
          if (dom.inStub)
            return true;
          dom = dom.parentNode
        }
        return false
      }
      function mkEl(name) {
        return document.createElement(name)
      }
      function replaceYield(tmpl, innerHTML) {
        return tmpl.replace(/<(yield)\/?>(<\/\1>)?/gi, innerHTML || '')
      }
      function $$(selector, ctx) {
        return (ctx || document).querySelectorAll(selector)
      }
      function $(selector, ctx) {
        return (ctx || document).querySelector(selector)
      }
      function inherit(parent) {
        function Child() {
        }
        Child.prototype = parent;
        return new Child
      }
      function setNamed(dom, parent, keys) {
        if (dom._visited)
          return;
        var p, v = dom.getAttribute('id') || dom.getAttribute('name');
        if (v) {
          if (keys.indexOf(v) < 0) {
            p = parent[v];
            if (!p)
              parent[v] = dom;
            else if (isArray(p))
              p.push(dom);
            else
              parent[v] = [
                p,
                dom
              ]
          }
          dom._visited = true
        }
      }
      // faster String startsWith alternative
      function startsWith(src, str) {
        return src.slice(0, str.length) === str
      }
      /*
 Virtual dom is an array of custom tags on the document.
 Updates and unmounts propagate downwards from parent to children.
*/
      var virtualDom = [], tagImpl = {}, styleNode;
      function injectStyle(css) {
        if (riot.render)
          return;
        // skip injection on the server
        if (!styleNode) {
          styleNode = mkEl('style');
          styleNode.setAttribute('type', 'text/css')
        }
        var head = document.head || document.getElementsByTagName('head')[0];
        if (styleNode.styleSheet)
          styleNode.styleSheet.cssText += css;
        else
          styleNode.innerHTML += css;
        if (!styleNode._rendered)
          if (styleNode.styleSheet) {
            document.body.appendChild(styleNode)
          } else {
            var rs = $('style[type=riot]');
            if (rs) {
              rs.parentNode.insertBefore(styleNode, rs);
              rs.parentNode.removeChild(rs)
            } else
              head.appendChild(styleNode)
          }
        styleNode._rendered = true
      }
      function mountTo(root, tagName, opts) {
        var tag = tagImpl[tagName],
          // cache the inner HTML to fix #855
          innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;
        // clear the inner html
        root.innerHTML = '';
        if (tag && root)
          tag = new Tag(tag, {
            root: root,
            opts: opts
          }, innerHTML);
        if (tag && tag.mount) {
          tag.mount();
          virtualDom.push(tag);
          return tag.on('unmount', function () {
            virtualDom.splice(virtualDom.indexOf(tag), 1)
          })
        }
      }
      riot.tag = function (name, html, css, attrs, fn) {
        if (isFunction(attrs)) {
          fn = attrs;
          if (/^[\w\-]+\s?=/.test(css)) {
            attrs = css;
            css = ''
          } else
            attrs = ''
        }
        if (css) {
          if (isFunction(css))
            fn = css;
          else
            injectStyle(css)
        }
        tagImpl[name] = {
          name: name,
          tmpl: html,
          attrs: attrs,
          fn: fn
        };
        return name
      };
      riot.mount = function (selector, tagName, opts) {
        var els, allTags, tags = [];
        // helper functions
        function addRiotTags(arr) {
          var list = '';
          each(arr, function (e) {
            list += ', *[' + RIOT_TAG + '="' + e.trim() + '"]'
          });
          return list
        }
        function selectAllTags() {
          var keys = Object.keys(tagImpl);
          return keys + addRiotTags(keys)
        }
        function pushTags(root) {
          var last;
          if (root.tagName) {
            if (tagName && (!(last = root.getAttribute(RIOT_TAG)) || last != tagName))
              root.setAttribute(RIOT_TAG, tagName);
            var tag = mountTo(root, tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts);
            if (tag)
              tags.push(tag)
          } else if (root.length) {
            each(root, pushTags)  // assume nodeList
          }
        }
        // ----- mount code -----
        if (typeof tagName === T_OBJECT) {
          opts = tagName;
          tagName = 0
        }
        // crawl the DOM to find the tag
        if (typeof selector === T_STRING) {
          if (selector === '*')
            // select all the tags registered
            // and also the tags found with the riot-tag attribute set
            selector = allTags = selectAllTags();
          else
            // or just the ones named like the selector
            selector += addRiotTags(selector.split(','));
          els = $$(selector)
        } else
          // probably you have passed already a tag or a NodeList
          els = selector;
        // select all the registered and mount them inside their root elements
        if (tagName === '*') {
          // get all custom tags
          tagName = allTags || selectAllTags();
          // if the root els it's just a single tag
          if (els.tagName)
            els = $$(tagName, els);
          else {
            // select all the children for all the different root elements
            var nodeList = [];
            each(els, function (_el) {
              nodeList.push($$(tagName, _el))
            });
            els = nodeList
          }
          // get rid of the tagName
          tagName = 0
        }
        if (els.tagName)
          pushTags(els);
        else
          each(els, pushTags);
        return tags
      };
      // update everything
      riot.update = function () {
        return each(virtualDom, function (tag) {
          tag.update()
        })
      };
      // @deprecated
      riot.mountTo = riot.mount;
      // share methods for other riot parts, e.g. compiler
      riot.util = {
        brackets: brackets,
        tmpl: tmpl
      };
      // support CommonJS, AMD & browser
      /* istanbul ignore next */
      if (typeof exports === T_OBJECT)
        module.exports = riot;
      else if (typeof define === 'function' && define.amd)
        define(function () {
          return window.riot = riot
        });
      else
        window.riot = riot
    }(typeof window != 'undefined' ? window : void 0))
  });
  // source: node_modules/underscore/underscore.js
  rqzt.define('underscore/underscore', function (module, exports, __dirname, __filename, process) {
    //     Underscore.js 1.8.3
    //     http://underscorejs.org
    //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    (function () {
      // Baseline setup
      // --------------
      // Establish the root object, `window` in the browser, or `exports` on the server.
      var root = this;
      // Save the previous value of the `_` variable.
      var previousUnderscore = root._;
      // Save bytes in the minified (but not gzipped) version:
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
      // Create quick reference variables for speed access to core prototypes.
      var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
      // All **ECMAScript 5** native function implementations that we hope to use
      // are declared here.
      var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create;
      // Naked function reference for surrogate-prototype-swapping.
      var Ctor = function () {
      };
      // Create a safe reference to the Underscore object for use below.
      var _ = function (obj) {
        if (obj instanceof _)
          return obj;
        if (!(this instanceof _))
          return new _(obj);
        this._wrapped = obj
      };
      // Export the Underscore object for **Node.js**, with
      // backwards-compatibility for the old `require()` API. If we're in
      // the browser, add `_` as a global object.
      if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = _
        }
        exports._ = _
      } else {
        root._ = _
      }
      // Current version.
      _.VERSION = '1.8.3';
      // Internal function that returns an efficient (for current engines) version
      // of the passed-in callback, to be repeatedly applied in other Underscore
      // functions.
      var optimizeCb = function (func, context, argCount) {
        if (context === void 0)
          return func;
        switch (argCount == null ? 3 : argCount) {
        case 1:
          return function (value) {
            return func.call(context, value)
          };
        case 2:
          return function (value, other) {
            return func.call(context, value, other)
          };
        case 3:
          return function (value, index, collection) {
            return func.call(context, value, index, collection)
          };
        case 4:
          return function (accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection)
          }
        }
        return function () {
          return func.apply(context, arguments)
        }
      };
      // A mostly-internal function to generate callbacks that can be applied
      // to each element in a collection, returning the desired result — either
      // identity, an arbitrary callback, a property matcher, or a property accessor.
      var cb = function (value, context, argCount) {
        if (value == null)
          return _.identity;
        if (_.isFunction(value))
          return optimizeCb(value, context, argCount);
        if (_.isObject(value))
          return _.matcher(value);
        return _.property(value)
      };
      _.iteratee = function (value, context) {
        return cb(value, context, Infinity)
      };
      // An internal function for creating assigner functions.
      var createAssigner = function (keysFunc, undefinedOnly) {
        return function (obj) {
          var length = arguments.length;
          if (length < 2 || obj == null)
            return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index], keys = keysFunc(source), l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!undefinedOnly || obj[key] === void 0)
                obj[key] = source[key]
            }
          }
          return obj
        }
      };
      // An internal function for creating a new object that inherits from another.
      var baseCreate = function (prototype) {
        if (!_.isObject(prototype))
          return {};
        if (nativeCreate)
          return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor;
        Ctor.prototype = null;
        return result
      };
      var property = function (key) {
        return function (obj) {
          return obj == null ? void 0 : obj[key]
        }
      };
      // Helper for collection methods to determine whether a collection
      // should be iterated as an array or as an object
      // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
      // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
      var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      var getLength = property('length');
      var isArrayLike = function (collection) {
        var length = getLength(collection);
        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX
      };
      // Collection Functions
      // --------------------
      // The cornerstone, an `each` implementation, aka `forEach`.
      // Handles raw objects in addition to array-likes. Treats all
      // sparse array-likes as if they were dense.
      _.each = _.forEach = function (obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) {
          for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj)
          }
        } else {
          var keys = _.keys(obj);
          for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj)
          }
        }
        return obj
      };
      // Return the results of applying the iteratee to each element.
      _.map = _.collect = function (obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length);
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          results[index] = iteratee(obj[currentKey], currentKey, obj)
        }
        return results
      };
      // Create a reducing function iterating left or right.
      function createReduce(dir) {
        // Optimized iterator function as using arguments.length
        // in the main function will deoptimize the, see #1991.
        function iterator(obj, iteratee, memo, keys, index, length) {
          for (; index >= 0 && index < length; index += dir) {
            var currentKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj)
          }
          return memo
        }
        return function (obj, iteratee, memo, context) {
          iteratee = optimizeCb(iteratee, context, 4);
          var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
          // Determine the initial value if none is provided.
          if (arguments.length < 3) {
            memo = obj[keys ? keys[index] : index];
            index += dir
          }
          return iterator(obj, iteratee, memo, keys, index, length)
        }
      }
      // **Reduce** builds up a single result from a list of values, aka `inject`,
      // or `foldl`.
      _.reduce = _.foldl = _.inject = createReduce(1);
      // The right-associative version of reduce, also known as `foldr`.
      _.reduceRight = _.foldr = createReduce(-1);
      // Return the first value which passes a truth test. Aliased as `detect`.
      _.find = _.detect = function (obj, predicate, context) {
        var key;
        if (isArrayLike(obj)) {
          key = _.findIndex(obj, predicate, context)
        } else {
          key = _.findKey(obj, predicate, context)
        }
        if (key !== void 0 && key !== -1)
          return obj[key]
      };
      // Return all the elements that pass a truth test.
      // Aliased as `select`.
      _.filter = _.select = function (obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        _.each(obj, function (value, index, list) {
          if (predicate(value, index, list))
            results.push(value)
        });
        return results
      };
      // Return all the elements for which a truth test fails.
      _.reject = function (obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context)
      };
      // Determine whether all of the elements match a truth test.
      // Aliased as `all`.
      _.every = _.all = function (obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (!predicate(obj[currentKey], currentKey, obj))
            return false
        }
        return true
      };
      // Determine if at least one element in the object matches a truth test.
      // Aliased as `any`.
      _.some = _.any = function (obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (predicate(obj[currentKey], currentKey, obj))
            return true
        }
        return false
      };
      // Determine if the array or object contains a given item (using `===`).
      // Aliased as `includes` and `include`.
      _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
        if (!isArrayLike(obj))
          obj = _.values(obj);
        if (typeof fromIndex != 'number' || guard)
          fromIndex = 0;
        return _.indexOf(obj, item, fromIndex) >= 0
      };
      // Invoke a method (with arguments) on every item in a collection.
      _.invoke = function (obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function (value) {
          var func = isFunc ? method : value[method];
          return func == null ? func : func.apply(value, args)
        })
      };
      // Convenience version of a common use case of `map`: fetching a property.
      _.pluck = function (obj, key) {
        return _.map(obj, _.property(key))
      };
      // Convenience version of a common use case of `filter`: selecting only objects
      // containing specific `key:value` pairs.
      _.where = function (obj, attrs) {
        return _.filter(obj, _.matcher(attrs))
      };
      // Convenience version of a common use case of `find`: getting the first object
      // containing specific `key:value` pairs.
      _.findWhere = function (obj, attrs) {
        return _.find(obj, _.matcher(attrs))
      };
      // Return the maximum element (or element-based computation).
      _.max = function (obj, iteratee, context) {
        var result = -Infinity, lastComputed = -Infinity, value, computed;
        if (iteratee == null && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value > result) {
              result = value
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function (value, index, list) {
            computed = iteratee(value, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
              result = value;
              lastComputed = computed
            }
          })
        }
        return result
      };
      // Return the minimum element (or element-based computation).
      _.min = function (obj, iteratee, context) {
        var result = Infinity, lastComputed = Infinity, value, computed;
        if (iteratee == null && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value < result) {
              result = value
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function (value, index, list) {
            computed = iteratee(value, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
              result = value;
              lastComputed = computed
            }
          })
        }
        return result
      };
      // Shuffle a collection, using the modern version of the
      // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
      _.shuffle = function (obj) {
        var set = isArrayLike(obj) ? obj : _.values(obj);
        var length = set.length;
        var shuffled = Array(length);
        for (var index = 0, rand; index < length; index++) {
          rand = _.random(0, index);
          if (rand !== index)
            shuffled[index] = shuffled[rand];
          shuffled[rand] = set[index]
        }
        return shuffled
      };
      // Sample **n** random values from a collection.
      // If **n** is not specified, returns a single random element.
      // The internal `guard` argument allows it to work with `map`.
      _.sample = function (obj, n, guard) {
        if (n == null || guard) {
          if (!isArrayLike(obj))
            obj = _.values(obj);
          return obj[_.random(obj.length - 1)]
        }
        return _.shuffle(obj).slice(0, Math.max(0, n))
      };
      // Sort the object's values by a criterion produced by an iteratee.
      _.sortBy = function (obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        return _.pluck(_.map(obj, function (value, index, list) {
          return {
            value: value,
            index: index,
            criteria: iteratee(value, index, list)
          }
        }).sort(function (left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0)
              return 1;
            if (a < b || b === void 0)
              return -1
          }
          return left.index - right.index
        }), 'value')
      };
      // An internal function used for aggregate "group by" operations.
      var group = function (behavior) {
        return function (obj, iteratee, context) {
          var result = {};
          iteratee = cb(iteratee, context);
          _.each(obj, function (value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key)
          });
          return result
        }
      };
      // Groups the object's values by a criterion. Pass either a string attribute
      // to group by, or a function that returns the criterion.
      _.groupBy = group(function (result, value, key) {
        if (_.has(result, key))
          result[key].push(value);
        else
          result[key] = [value]
      });
      // Indexes the object's values by a criterion, similar to `groupBy`, but for
      // when you know that your index values will be unique.
      _.indexBy = group(function (result, value, key) {
        result[key] = value
      });
      // Counts instances of an object that group by a certain criterion. Pass
      // either a string attribute to count by, or a function that returns the
      // criterion.
      _.countBy = group(function (result, value, key) {
        if (_.has(result, key))
          result[key]++;
        else
          result[key] = 1
      });
      // Safely create a real, live array from anything iterable.
      _.toArray = function (obj) {
        if (!obj)
          return [];
        if (_.isArray(obj))
          return slice.call(obj);
        if (isArrayLike(obj))
          return _.map(obj, _.identity);
        return _.values(obj)
      };
      // Return the number of elements in an object.
      _.size = function (obj) {
        if (obj == null)
          return 0;
        return isArrayLike(obj) ? obj.length : _.keys(obj).length
      };
      // Split a collection into two arrays: one whose elements all satisfy the given
      // predicate, and one whose elements all do not satisfy the predicate.
      _.partition = function (obj, predicate, context) {
        predicate = cb(predicate, context);
        var pass = [], fail = [];
        _.each(obj, function (value, key, obj) {
          (predicate(value, key, obj) ? pass : fail).push(value)
        });
        return [
          pass,
          fail
        ]
      };
      // Array Functions
      // ---------------
      // Get the first element of an array. Passing **n** will return the first N
      // values in the array. Aliased as `head` and `take`. The **guard** check
      // allows it to work with `_.map`.
      _.first = _.head = _.take = function (array, n, guard) {
        if (array == null)
          return void 0;
        if (n == null || guard)
          return array[0];
        return _.initial(array, array.length - n)
      };
      // Returns everything but the last entry of the array. Especially useful on
      // the arguments object. Passing **n** will return all the values in
      // the array, excluding the last N.
      _.initial = function (array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)))
      };
      // Get the last element of an array. Passing **n** will return the last N
      // values in the array.
      _.last = function (array, n, guard) {
        if (array == null)
          return void 0;
        if (n == null || guard)
          return array[array.length - 1];
        return _.rest(array, Math.max(0, array.length - n))
      };
      // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
      // Especially useful on the arguments object. Passing an **n** will return
      // the rest N values in the array.
      _.rest = _.tail = _.drop = function (array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n)
      };
      // Trim out all falsy values from an array.
      _.compact = function (array) {
        return _.filter(array, _.identity)
      };
      // Internal implementation of a recursive `flatten` function.
      var flatten = function (input, shallow, strict, startIndex) {
        var output = [], idx = 0;
        for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
          var value = input[i];
          if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
            //flatten current level of array or arguments object
            if (!shallow)
              value = flatten(value, shallow, strict);
            var j = 0, len = value.length;
            output.length += len;
            while (j < len) {
              output[idx++] = value[j++]
            }
          } else if (!strict) {
            output[idx++] = value
          }
        }
        return output
      };
      // Flatten out an array, either recursively (by default), or just one level.
      _.flatten = function (array, shallow) {
        return flatten(array, shallow, false)
      };
      // Return a version of the array that does not contain the specified value(s).
      _.without = function (array) {
        return _.difference(array, slice.call(arguments, 1))
      };
      // Produce a duplicate-free version of the array. If the array has already
      // been sorted, you have the option of using a faster algorithm.
      // Aliased as `unique`.
      _.uniq = _.unique = function (array, isSorted, iteratee, context) {
        if (!_.isBoolean(isSorted)) {
          context = iteratee;
          iteratee = isSorted;
          isSorted = false
        }
        if (iteratee != null)
          iteratee = cb(iteratee, context);
        var result = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
          var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
          if (isSorted) {
            if (!i || seen !== computed)
              result.push(value);
            seen = computed
          } else if (iteratee) {
            if (!_.contains(seen, computed)) {
              seen.push(computed);
              result.push(value)
            }
          } else if (!_.contains(result, value)) {
            result.push(value)
          }
        }
        return result
      };
      // Produce an array that contains the union: each distinct element from all of
      // the passed-in arrays.
      _.union = function () {
        return _.uniq(flatten(arguments, true, true))
      };
      // Produce an array that contains every item shared between all the
      // passed-in arrays.
      _.intersection = function (array) {
        var result = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
          var item = array[i];
          if (_.contains(result, item))
            continue;
          for (var j = 1; j < argsLength; j++) {
            if (!_.contains(arguments[j], item))
              break
          }
          if (j === argsLength)
            result.push(item)
        }
        return result
      };
      // Take the difference between one array and a number of other arrays.
      // Only the elements present in just the first array will remain.
      _.difference = function (array) {
        var rest = flatten(arguments, true, true, 1);
        return _.filter(array, function (value) {
          return !_.contains(rest, value)
        })
      };
      // Zip together multiple lists into a single array -- elements that share
      // an index go together.
      _.zip = function () {
        return _.unzip(arguments)
      };
      // Complement of _.zip. Unzip accepts an array of arrays and groups
      // each array's elements on shared indices
      _.unzip = function (array) {
        var length = array && _.max(array, getLength).length || 0;
        var result = Array(length);
        for (var index = 0; index < length; index++) {
          result[index] = _.pluck(array, index)
        }
        return result
      };
      // Converts lists into objects. Pass either a single array of `[key, value]`
      // pairs, or two parallel arrays of the same length -- one of keys, and one of
      // the corresponding values.
      _.object = function (list, values) {
        var result = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
          if (values) {
            result[list[i]] = values[i]
          } else {
            result[list[i][0]] = list[i][1]
          }
        }
        return result
      };
      // Generator function to create the findIndex and findLastIndex functions
      function createPredicateIndexFinder(dir) {
        return function (array, predicate, context) {
          predicate = cb(predicate, context);
          var length = getLength(array);
          var index = dir > 0 ? 0 : length - 1;
          for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array))
              return index
          }
          return -1
        }
      }
      // Returns the first index on an array-like that passes a predicate test
      _.findIndex = createPredicateIndexFinder(1);
      _.findLastIndex = createPredicateIndexFinder(-1);
      // Use a comparator function to figure out the smallest index at which
      // an object should be inserted so as to maintain order. Uses binary search.
      _.sortedIndex = function (array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        var value = iteratee(obj);
        var low = 0, high = getLength(array);
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (iteratee(array[mid]) < value)
            low = mid + 1;
          else
            high = mid
        }
        return low
      };
      // Generator function to create the indexOf and lastIndexOf functions
      function createIndexFinder(dir, predicateFind, sortedIndex) {
        return function (array, item, idx) {
          var i = 0, length = getLength(array);
          if (typeof idx == 'number') {
            if (dir > 0) {
              i = idx >= 0 ? idx : Math.max(idx + length, i)
            } else {
              length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1
            }
          } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1
          }
          if (item !== item) {
            idx = predicateFind(slice.call(array, i, length), _.isNaN);
            return idx >= 0 ? idx + i : -1
          }
          for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item)
              return idx
          }
          return -1
        }
      }
      // Return the position of the first occurrence of an item in an array,
      // or -1 if the item is not included in the array.
      // If the array is large and already in sort order, pass `true`
      // for **isSorted** to use binary search.
      _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
      _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
      // Generate an integer Array containing an arithmetic progression. A port of
      // the native Python `range()` function. See
      // [the Python documentation](http://docs.python.org/library/functions.html#range).
      _.range = function (start, stop, step) {
        if (stop == null) {
          stop = start || 0;
          start = 0
        }
        step = step || 1;
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);
        for (var idx = 0; idx < length; idx++, start += step) {
          range[idx] = start
        }
        return range
      };
      // Function (ahem) Functions
      // ------------------
      // Determines whether to execute a function as a constructor
      // or a normal function with the provided arguments
      var executeBound = function (sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc))
          return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype);
        var result = sourceFunc.apply(self, args);
        if (_.isObject(result))
          return result;
        return self
      };
      // Create a function bound to a given object (assigning `this`, and arguments,
      // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
      // available.
      _.bind = function (func, context) {
        if (nativeBind && func.bind === nativeBind)
          return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func))
          throw new TypeError('Bind must be called on a function');
        var args = slice.call(arguments, 2);
        var bound = function () {
          return executeBound(func, bound, context, this, args.concat(slice.call(arguments)))
        };
        return bound
      };
      // Partially apply a function by creating a version that has had some of its
      // arguments pre-filled, without changing its dynamic `this` context. _ acts
      // as a placeholder, allowing any combination of arguments to be pre-filled.
      _.partial = function (func) {
        var boundArgs = slice.call(arguments, 1);
        var bound = function () {
          var position = 0, length = boundArgs.length;
          var args = Array(length);
          for (var i = 0; i < length; i++) {
            args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i]
          }
          while (position < arguments.length)
            args.push(arguments[position++]);
          return executeBound(func, bound, this, this, args)
        };
        return bound
      };
      // Bind a number of an object's methods to that object. Remaining arguments
      // are the method names to be bound. Useful for ensuring that all callbacks
      // defined on an object belong to it.
      _.bindAll = function (obj) {
        var i, length = arguments.length, key;
        if (length <= 1)
          throw new Error('bindAll must be passed function names');
        for (i = 1; i < length; i++) {
          key = arguments[i];
          obj[key] = _.bind(obj[key], obj)
        }
        return obj
      };
      // Memoize an expensive function by storing its results.
      _.memoize = function (func, hasher) {
        var memoize = function (key) {
          var cache = memoize.cache;
          var address = '' + (hasher ? hasher.apply(this, arguments) : key);
          if (!_.has(cache, address))
            cache[address] = func.apply(this, arguments);
          return cache[address]
        };
        memoize.cache = {};
        return memoize
      };
      // Delays a function for the given number of milliseconds, and then calls
      // it with the arguments supplied.
      _.delay = function (func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function () {
          return func.apply(null, args)
        }, wait)
      };
      // Defers a function, scheduling it to run after the current call stack has
      // cleared.
      _.defer = _.partial(_.delay, _, 1);
      // Returns a function, that, when invoked, will only be triggered at most once
      // during a given window of time. Normally, the throttled function will run
      // as much as it can, without ever going more than once per `wait` duration;
      // but if you'd like to disable the execution on the leading edge, pass
      // `{leading: false}`. To disable execution on the trailing edge, ditto.
      _.throttle = function (func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options)
          options = {};
        var later = function () {
          previous = options.leading === false ? 0 : _.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout)
            context = args = null
        };
        return function () {
          var now = _.now();
          if (!previous && options.leading === false)
            previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout)
              context = args = null
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining)
          }
          return result
        }
      };
      // Returns a function, that, as long as it continues to be invoked, will not
      // be triggered. The function will be called after it stops being called for
      // N milliseconds. If `immediate` is passed, trigger the function on the
      // leading edge, instead of the trailing.
      _.debounce = function (func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        var later = function () {
          var last = _.now() - timestamp;
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last)
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              if (!timeout)
                context = args = null
            }
          }
        };
        return function () {
          context = this;
          args = arguments;
          timestamp = _.now();
          var callNow = immediate && !timeout;
          if (!timeout)
            timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null
          }
          return result
        }
      };
      // Returns the first function passed as an argument to the second,
      // allowing you to adjust arguments, run code before and after, and
      // conditionally execute the original function.
      _.wrap = function (func, wrapper) {
        return _.partial(wrapper, func)
      };
      // Returns a negated version of the passed-in predicate.
      _.negate = function (predicate) {
        return function () {
          return !predicate.apply(this, arguments)
        }
      };
      // Returns a function that is the composition of a list of functions, each
      // consuming the return value of the function that follows.
      _.compose = function () {
        var args = arguments;
        var start = args.length - 1;
        return function () {
          var i = start;
          var result = args[start].apply(this, arguments);
          while (i--)
            result = args[i].call(this, result);
          return result
        }
      };
      // Returns a function that will only be executed on and after the Nth call.
      _.after = function (times, func) {
        return function () {
          if (--times < 1) {
            return func.apply(this, arguments)
          }
        }
      };
      // Returns a function that will only be executed up to (but not including) the Nth call.
      _.before = function (times, func) {
        var memo;
        return function () {
          if (--times > 0) {
            memo = func.apply(this, arguments)
          }
          if (times <= 1)
            func = null;
          return memo
        }
      };
      // Returns a function that will be executed at most one time, no matter how
      // often you call it. Useful for lazy initialization.
      _.once = _.partial(_.before, 2);
      // Object Functions
      // ----------------
      // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
      var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
      var nonEnumerableProps = [
        'valueOf',
        'isPrototypeOf',
        'toString',
        'propertyIsEnumerable',
        'hasOwnProperty',
        'toLocaleString'
      ];
      function collectNonEnumProps(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
        // Constructor is a special case.
        var prop = 'constructor';
        if (_.has(obj, prop) && !_.contains(keys, prop))
          keys.push(prop);
        while (nonEnumIdx--) {
          prop = nonEnumerableProps[nonEnumIdx];
          if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
            keys.push(prop)
          }
        }
      }
      // Retrieve the names of an object's own properties.
      // Delegates to **ECMAScript 5**'s native `Object.keys`
      _.keys = function (obj) {
        if (!_.isObject(obj))
          return [];
        if (nativeKeys)
          return nativeKeys(obj);
        var keys = [];
        for (var key in obj)
          if (_.has(obj, key))
            keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug)
          collectNonEnumProps(obj, keys);
        return keys
      };
      // Retrieve all the property names of an object.
      _.allKeys = function (obj) {
        if (!_.isObject(obj))
          return [];
        var keys = [];
        for (var key in obj)
          keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug)
          collectNonEnumProps(obj, keys);
        return keys
      };
      // Retrieve the values of an object's properties.
      _.values = function (obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]]
        }
        return values
      };
      // Returns the results of applying the iteratee to each element of the object
      // In contrast to _.map it returns an object
      _.mapObject = function (obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = _.keys(obj), length = keys.length, results = {}, currentKey;
        for (var index = 0; index < length; index++) {
          currentKey = keys[index];
          results[currentKey] = iteratee(obj[currentKey], currentKey, obj)
        }
        return results
      };
      // Convert an object into a list of `[key, value]` pairs.
      _.pairs = function (obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [
            keys[i],
            obj[keys[i]]
          ]
        }
        return pairs
      };
      // Invert the keys and values of an object. The values must be serializable.
      _.invert = function (obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i]
        }
        return result
      };
      // Return a sorted list of the function names available on the object.
      // Aliased as `methods`
      _.functions = _.methods = function (obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key]))
            names.push(key)
        }
        return names.sort()
      };
      // Extend a given object with all the properties in passed-in object(s).
      _.extend = createAssigner(_.allKeys);
      // Assigns a given object with all the own properties in the passed-in object(s)
      // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
      _.extendOwn = _.assign = createAssigner(_.keys);
      // Returns the first key on an object that passes a predicate test
      _.findKey = function (obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = _.keys(obj), key;
        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];
          if (predicate(obj[key], key, obj))
            return key
        }
      };
      // Return a copy of the object only containing the whitelisted properties.
      _.pick = function (object, oiteratee, context) {
        var result = {}, obj = object, iteratee, keys;
        if (obj == null)
          return result;
        if (_.isFunction(oiteratee)) {
          keys = _.allKeys(obj);
          iteratee = optimizeCb(oiteratee, context)
        } else {
          keys = flatten(arguments, false, false, 1);
          iteratee = function (value, key, obj) {
            return key in obj
          };
          obj = Object(obj)
        }
        for (var i = 0, length = keys.length; i < length; i++) {
          var key = keys[i];
          var value = obj[key];
          if (iteratee(value, key, obj))
            result[key] = value
        }
        return result
      };
      // Return a copy of the object without the blacklisted properties.
      _.omit = function (obj, iteratee, context) {
        if (_.isFunction(iteratee)) {
          iteratee = _.negate(iteratee)
        } else {
          var keys = _.map(flatten(arguments, false, false, 1), String);
          iteratee = function (value, key) {
            return !_.contains(keys, key)
          }
        }
        return _.pick(obj, iteratee, context)
      };
      // Fill in a given object with default properties.
      _.defaults = createAssigner(_.allKeys, true);
      // Creates an object that inherits from the given prototype object.
      // If additional properties are provided then they will be added to the
      // created object.
      _.create = function (prototype, props) {
        var result = baseCreate(prototype);
        if (props)
          _.extendOwn(result, props);
        return result
      };
      // Create a (shallow-cloned) duplicate of an object.
      _.clone = function (obj) {
        if (!_.isObject(obj))
          return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj)
      };
      // Invokes interceptor with the obj, and then returns obj.
      // The primary purpose of this method is to "tap into" a method chain, in
      // order to perform operations on intermediate results within the chain.
      _.tap = function (obj, interceptor) {
        interceptor(obj);
        return obj
      };
      // Returns whether an object has a given set of `key:value` pairs.
      _.isMatch = function (object, attrs) {
        var keys = _.keys(attrs), length = keys.length;
        if (object == null)
          return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj))
            return false
        }
        return true
      };
      // Internal recursive comparison function for `isEqual`.
      var eq = function (a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b)
          return a !== 0 || 1 / a === 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null)
          return a === b;
        // Unwrap any wrapped objects.
        if (a instanceof _)
          a = a._wrapped;
        if (b instanceof _)
          b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b))
          return false;
        switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return '' + a === '' + b;
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive.
          // Object(NaN) is equivalent to NaN
          if (+a !== +a)
            return +b !== +b;
          // An `egal` comparison is performed for other numeric values.
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a === +b
        }
        var areArrays = className === '[object Array]';
        if (!areArrays) {
          if (typeof a != 'object' || typeof b != 'object')
            return false;
          // Objects with different constructors are not equivalent, but `Object`s or `Array`s
          // from different frames are.
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
            return false
          }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
          // Linear search. Performance is inversely proportional to the number of
          // unique nested structures.
          if (aStack[length] === a)
            return bStack[length] === b
        }
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
        // Recursively compare objects and arrays.
        if (areArrays) {
          // Compare array lengths to determine if a deep comparison is necessary.
          length = a.length;
          if (length !== b.length)
            return false;
          // Deep compare the contents, ignoring non-numeric properties.
          while (length--) {
            if (!eq(a[length], b[length], aStack, bStack))
              return false
          }
        } else {
          // Deep compare objects.
          var keys = _.keys(a), key;
          length = keys.length;
          // Ensure that both objects contain the same number of properties before comparing deep equality.
          if (_.keys(b).length !== length)
            return false;
          while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack)))
              return false
          }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true
      };
      // Perform a deep comparison to check if two objects are equal.
      _.isEqual = function (a, b) {
        return eq(a, b)
      };
      // Is a given array, string, or object empty?
      // An "empty" object has no enumerable own-properties.
      _.isEmpty = function (obj) {
        if (obj == null)
          return true;
        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
          return obj.length === 0;
        return _.keys(obj).length === 0
      };
      // Is a given value a DOM element?
      _.isElement = function (obj) {
        return !!(obj && obj.nodeType === 1)
      };
      // Is a given value an array?
      // Delegates to ECMA5's native Array.isArray
      _.isArray = nativeIsArray || function (obj) {
        return toString.call(obj) === '[object Array]'
      };
      // Is a given variable an object?
      _.isObject = function (obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj
      };
      // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
      _.each([
        'Arguments',
        'Function',
        'String',
        'Number',
        'Date',
        'RegExp',
        'Error'
      ], function (name) {
        _['is' + name] = function (obj) {
          return toString.call(obj) === '[object ' + name + ']'
        }
      });
      // Define a fallback version of the method in browsers (ahem, IE < 9), where
      // there isn't any inspectable "Arguments" type.
      if (!_.isArguments(arguments)) {
        _.isArguments = function (obj) {
          return _.has(obj, 'callee')
        }
      }
      // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
      // IE 11 (#1621), and in Safari 8 (#1929).
      if (typeof /./ != 'function' && typeof Int8Array != 'object') {
        _.isFunction = function (obj) {
          return typeof obj == 'function' || false
        }
      }
      // Is a given object a finite number?
      _.isFinite = function (obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj))
      };
      // Is the given value `NaN`? (NaN is the only number which does not equal itself).
      _.isNaN = function (obj) {
        return _.isNumber(obj) && obj !== +obj
      };
      // Is a given value a boolean?
      _.isBoolean = function (obj) {
        return obj === true || obj === false || toString.call(obj) === '[object Boolean]'
      };
      // Is a given value equal to null?
      _.isNull = function (obj) {
        return obj === null
      };
      // Is a given variable undefined?
      _.isUndefined = function (obj) {
        return obj === void 0
      };
      // Shortcut function for checking if an object has a given property directly
      // on itself (in other words, not on a prototype).
      _.has = function (obj, key) {
        return obj != null && hasOwnProperty.call(obj, key)
      };
      // Utility Functions
      // -----------------
      // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
      // previous owner. Returns a reference to the Underscore object.
      _.noConflict = function () {
        root._ = previousUnderscore;
        return this
      };
      // Keep the identity function around for default iteratees.
      _.identity = function (value) {
        return value
      };
      // Predicate-generating functions. Often useful outside of Underscore.
      _.constant = function (value) {
        return function () {
          return value
        }
      };
      _.noop = function () {
      };
      _.property = property;
      // Generates a function for a given object that returns a given property.
      _.propertyOf = function (obj) {
        return obj == null ? function () {
        } : function (key) {
          return obj[key]
        }
      };
      // Returns a predicate for checking whether an object has a given set of
      // `key:value` pairs.
      _.matcher = _.matches = function (attrs) {
        attrs = _.extendOwn({}, attrs);
        return function (obj) {
          return _.isMatch(obj, attrs)
        }
      };
      // Run a function **n** times.
      _.times = function (n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; i < n; i++)
          accum[i] = iteratee(i);
        return accum
      };
      // Return a random integer between min and max (inclusive).
      _.random = function (min, max) {
        if (max == null) {
          max = min;
          min = 0
        }
        return min + Math.floor(Math.random() * (max - min + 1))
      };
      // A (possibly faster) way to get the current timestamp as an integer.
      _.now = Date.now || function () {
        return new Date().getTime()
      };
      // List of HTML entities for escaping.
      var escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;'
      };
      var unescapeMap = _.invert(escapeMap);
      // Functions for escaping and unescaping strings to/from HTML interpolation.
      var createEscaper = function (map) {
        var escaper = function (match) {
          return map[match]
        };
        // Regexes for identifying a key that needs to be escaped
        var source = '(?:' + _.keys(map).join('|') + ')';
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, 'g');
        return function (string) {
          string = string == null ? '' : '' + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string
        }
      };
      _.escape = createEscaper(escapeMap);
      _.unescape = createEscaper(unescapeMap);
      // If the value of the named `property` is a function then invoke it with the
      // `object` as context; otherwise, return it.
      _.result = function (object, property, fallback) {
        var value = object == null ? void 0 : object[property];
        if (value === void 0) {
          value = fallback
        }
        return _.isFunction(value) ? value.call(object) : value
      };
      // Generate a unique integer id (unique within the entire client session).
      // Useful for temporary DOM ids.
      var idCounter = 0;
      _.uniqueId = function (prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id
      };
      // By default, Underscore uses ERB-style template delimiters, change the
      // following template settings to use alternative delimiters.
      _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
      // When customizing `templateSettings`, if you don't want to define an
      // interpolation, evaluation or escaping regex, we need one that is
      // guaranteed not to match.
      var noMatch = /(.)^/;
      // Certain characters need to be escaped so that they can be put into a
      // string literal.
      var escapes = {
        "'": "'",
        '\\': '\\',
        '\r': 'r',
        '\n': 'n',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
      var escapeChar = function (match) {
        return '\\' + escapes[match]
      };
      // JavaScript micro-templating, similar to John Resig's implementation.
      // Underscore templating handles arbitrary delimiters, preserves whitespace,
      // and correctly escapes quotes within interpolated code.
      // NB: `oldSettings` only exists for backwards compatibility.
      _.template = function (text, settings, oldSettings) {
        if (!settings && oldSettings)
          settings = oldSettings;
        settings = _.defaults({}, settings, _.templateSettings);
        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');
        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escaper, escapeChar);
          index = offset + match.length;
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'"
          } else if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'"
          } else if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='"
          }
          // Adobe VMs need the match returned to produce the correct offest.
          return match
        });
        source += "';\n";
        // If a variable is not specified, place data values in local scope.
        if (!settings.variable)
          source = 'with(obj||{}){\n' + source + '}\n';
        source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
        try {
          var render = new Function(settings.variable || 'obj', '_', source)
        } catch (e) {
          e.source = source;
          throw e
        }
        var template = function (data) {
          return render.call(this, data, _)
        };
        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';
        return template
      };
      // Add a "chain" function. Start chaining a wrapped Underscore object.
      _.chain = function (obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance
      };
      // OOP
      // ---------------
      // If Underscore is called as a function, it returns a wrapped object that
      // can be used OO-style. This wrapper holds altered versions of all the
      // underscore functions. Wrapped objects may be chained.
      // Helper function to continue chaining intermediate results.
      var result = function (instance, obj) {
        return instance._chain ? _(obj).chain() : obj
      };
      // Add your own custom functions to the Underscore object.
      _.mixin = function (obj) {
        _.each(_.functions(obj), function (name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function () {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return result(this, func.apply(_, args))
          }
        })
      };
      // Add all of the Underscore functions to the wrapper object.
      _.mixin(_);
      // Add all mutator Array functions to the wrapper.
      _.each([
        'pop',
        'push',
        'reverse',
        'shift',
        'sort',
        'splice',
        'unshift'
      ], function (name) {
        var method = ArrayProto[name];
        _.prototype[name] = function () {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name === 'shift' || name === 'splice') && obj.length === 0)
            delete obj[0];
          return result(this, obj)
        }
      });
      // Add all accessor Array functions to the wrapper.
      _.each([
        'concat',
        'join',
        'slice'
      ], function (name) {
        var method = ArrayProto[name];
        _.prototype[name] = function () {
          return result(this, method.apply(this._wrapped, arguments))
        }
      });
      // Extracts the result from a wrapped and chained object.
      _.prototype.value = function () {
        return this._wrapped
      };
      // Provide unwrapping proxy for some methods used in engine operations
      // such as arithmetic and JSON stringification.
      _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
      _.prototype.toString = function () {
        return '' + this._wrapped
      };
      // AMD registration happens at the end for compatibility with AMD loaders
      // that may not enforce next-turn semantics on modules. Even though general
      // practice for AMD registration is to be anonymous, underscore registers
      // as a named module because, like jQuery, it is a base library that is
      // popular enough to be bundled in a third party lib, but not be part of
      // an AMD load request. Those cases could generate an error when an
      // anonymous define() is called outside of a loader request.
      if (typeof define === 'function' && define.amd) {
        define('underscore', [], function () {
          return _
        })
      }
    }.call(this))
  });
  // source: node_modules/crowdcontrol/lib/index.js
  rqzt.define('crowdcontrol/lib', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    module.exports = {
      data: rqzt('crowdcontrol/lib/data'),
      utils: rqzt('crowdcontrol/lib/utils'),
      view: rqzt('crowdcontrol/lib/view'),
      config: rqzt('crowdcontrol/lib/config'),
      start: function (opts) {
        return this.utils.shim.riot.mount('*')
      },
      Events: rqzt('crowdcontrol/lib/events')
    };
    if (typeof window !== 'undefined' && window !== null) {
      window.crowdcontrol = module.exports
    }  //# sourceMappingURL=index.js.map
  });
  // source: node_modules/crowdcontrol/lib/data/index.js
  rqzt.define('crowdcontrol/lib/data', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var policy;
    policy = rqzt('crowdcontrol/lib/data/policy');
    module.exports = {
      Api: rqzt('crowdcontrol/lib/data/api'),
      Source: rqzt('crowdcontrol/lib/data/source'),
      Policy: policy.Policy,
      TabularRestfulStreamingPolicy: policy.TabularRestfulStreamingPolicy
    }  //# sourceMappingURL=index.js.map
  });
  // source: node_modules/crowdcontrol/lib/data/policy.js
  rqzt.define('crowdcontrol/lib/data/policy', function (module, exports, __dirname, __filename, process) {
  });
  // source: node_modules/crowdcontrol/lib/data/api.js
  rqzt.define('crowdcontrol/lib/data/api', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var Api, ScheduledTask, ScheduledTaskType, apis, log, promise, requestAnimationFrame, timeNow, utils, xhr;
    utils = rqzt('crowdcontrol/lib/utils');
    promise = utils.shim.promise;
    xhr = utils.shim.xhr;
    log = utils.log;
    requestAnimationFrame = utils.shim.requestAnimationFrame;
    timeNow = Date.now || function () {
      return new Date().getTime()
    };
    ScheduledTaskType = {
      every: 'every',
      once: 'once'
    };
    ScheduledTask = function () {
      function ScheduledTask(type, fn1, millis1) {
        this.type = type;
        this.fn = fn1;
        this.millis = millis1;
        this.scheduledTime = timeNow() + this.millis;
        this.kill = false
      }
      ScheduledTask.prototype.cancel = function () {
        return this.kill = true
      };
      return ScheduledTask
    }();
    apis = {};
    Api = function () {
      Api.prototype.scheduledTasks = null;
      Api.prototype.url = '';
      Api.prototype.token = '';
      function Api(url1, token) {
        var url;
        this.url = url1 != null ? url1 : '';
        this.token = token != null ? token : '';
        this.scheduledTasks = [];
        url = this.url;
        if (url[url.length - 1] === '/') {
          this.url = url.substring(0, url.length - 1)
        }
      }
      Api.get = function (name) {
        if (name == null) {
          name = ''
        }
        return apis[name]
      };
      Api.prototype.register = function (name) {
        if (name == null) {
          name = ''
        }
        return apis[name] = this
      };
      Api.prototype.get = function (path, data, headers) {
        var p;
        if (headers == null) {
          headers = {}
        }
        if (this.token) {
          headers.Authorization = this.token
        }
        p = path;
        if (p[0] !== '/') {
          p = '/' + path
        }
        return xhr({
          method: 'GET',
          contentType: 'application/json',
          headers: headers,
          url: this.url + p,
          data: JSON.stringify(data)
        })
      };
      Api.prototype.post = function (path, data, headers) {
        var p;
        if (headers == null) {
          headers = {}
        }
        if (this.token) {
          headers.Authorization = this.token
        }
        p = path;
        if (p[0] !== '/') {
          p = '/' + path
        }
        return xhr({
          method: 'POST',
          contentType: 'application/json',
          headers: headers,
          url: this.url + p,
          data: JSON.stringify(data)
        })
      };
      Api.prototype.put = function (path, data, headers) {
        var p;
        if (headers == null) {
          headers = {}
        }
        if (this.token) {
          headers.Authorization = this.token
        }
        p = path;
        if (p[0] !== '/') {
          p = '/' + path
        }
        return xhr({
          method: 'PUT',
          contentType: 'application/json',
          headers: headers,
          url: this.url + p,
          data: JSON.stringify(data)
        })
      };
      Api.prototype.patch = function (path, data, headers) {
        var p;
        if (headers == null) {
          headers = {}
        }
        if (this.token) {
          headers.Authorization = this.token
        }
        p = path;
        if (p[0] !== '/') {
          p = '/' + path
        }
        return xhr({
          method: 'PATCH',
          contentType: 'application/json',
          headers: headers,
          url: this.url + p,
          data: JSON.stringify(data)
        })
      };
      Api.prototype['delete'] = function (path, data, headers) {
        var p;
        if (headers == null) {
          headers = {}
        }
        if (this.token) {
          headers.Authorization = this.token
        }
        p = path;
        if (p[0] !== '/') {
          p = '/' + path
        }
        return xhr({
          method: 'DELETE',
          contentType: 'application/json',
          headers: headers,
          url: this.url + p,
          data: JSON.stringify(data)
        })
      };
      Api.prototype.scheduleOnce = function (fn, millis) {
        var task;
        task = new ScheduledTask(ScheduledTaskType.once, fn, millis);
        this.scheduledTasks.push(task);
        if (this.scheduledTasks.length === 1) {
          this.loop()
        }
        return task
      };
      Api.prototype.scheduleEvery = function (fn, millis, now) {
        var task;
        if (now == null) {
          now = false
        }
        task = new ScheduledTask(ScheduledTaskType.every, fn, millis);
        this.scheduledTasks.push(task);
        if (this.scheduledTasks.length === 1) {
          this.loop()
        }
        if (now) {
          log('API: scheduling for immediate execution');
          task = new ScheduledTask(ScheduledTaskType.once, fn, 0);
          this.scheduledTasks.push(task)
        }
        return task
      };
      Api.prototype.loop = function () {
        if (this.scheduledTasks.length > 0) {
          log('API: starting loop');
          return requestAnimationFrame(function (_this) {
            return function () {
              var i, length, now, sfn;
              now = timeNow();
              i = 0;
              length = _this.scheduledTasks.length;
              while (i < length) {
                sfn = _this.scheduledTasks[i];
                if (sfn.scheduledTime <= now) {
                  if (!sfn.kill) {
                    sfn.fn(now)
                  }
                  if (sfn.kill || sfn.type === ScheduledTaskType.once) {
                    length--;
                    _this.scheduledTasks[i] = _this.scheduledTasks[length]
                  } else if (sfn.type === ScheduledTaskType.every) {
                    sfn.scheduledTime += sfn.millis
                  }
                } else {
                  i++
                }
              }
              _this.scheduledTasks.length = length;
              if (length > 0) {
                return _this.loop()
              }
            }
          }(this))
        }
      };
      return Api
    }();
    module.exports = Api  //# sourceMappingURL=api.js.map
  });
  // source: node_modules/crowdcontrol/lib/utils/index.js
  rqzt.define('crowdcontrol/lib/utils', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    module.exports = {
      shim: rqzt('crowdcontrol/lib/utils/shim'),
      log: rqzt('crowdcontrol/lib/utils/log'),
      mediator: rqzt('crowdcontrol/lib/utils/mediator')
    }  //# sourceMappingURL=index.js.map
  });
  // source: node_modules/crowdcontrol/lib/utils/shim.js
  rqzt.define('crowdcontrol/lib/utils/shim', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var promise, xhr;
    promise = rqzt('bluebird/js/browser/bluebird');
    xhr = rqzt('xhr-promise');
    Function.prototype.property = function (prop, desc) {
      return Object.defineProperty(this.prototype, prop, desc)
    };
    promise['new'] = function (fn) {
      return new promise(fn)
    };
    module.exports = {
      observable: function (obj) {
        return this.riot.observable(obj)
      },
      requestAnimationFrame: rqzt('raf'),
      riot: typeof window !== 'undefined' && window !== null && window.riot != null ? window.riot : void 0,
      xhr: function (data) {
        var x;
        x = new xhr;
        return x.send.apply(x, arguments)
      },
      promise: promise
    }  //# sourceMappingURL=shim.js.map
  });
  // source: node_modules/bluebird/js/browser/bluebird.js
  rqzt.define('bluebird/js/browser/bluebird', function (module, exports, __dirname, __filename, process) {
    /* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
    /**
 * bluebird build version 2.9.34
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
*/
    !function (e) {
      if ('object' == typeof exports && 'undefined' != typeof module)
        module.exports = e();
      else if ('function' == typeof define && define.amd)
        define([], e);
      else {
        var f;
        'undefined' != typeof window ? f = window : 'undefined' != typeof global ? f = global : 'undefined' != typeof self && (f = self), f.Promise = e()
      }
    }(function () {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof _dereq_ == 'function' && _dereq_;
              if (!u && a)
                return a(o, !0);
              if (i)
                return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = 'MODULE_NOT_FOUND', f
            }
            var l = n[o] = { exports: {} };
            t[o][0].call(l.exports, function (e) {
              var n = t[o][1][e];
              return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
          }
          return n[o].exports
        }
        var i = typeof _dereq_ == 'function' && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s
      }({
        1: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise) {
              var SomePromiseArray = Promise._SomePromiseArray;
              function any(promises) {
                var ret = new SomePromiseArray(promises);
                var promise = ret.promise();
                ret.setHowMany(1);
                ret.setUnwrap();
                ret.init();
                return promise
              }
              Promise.any = function (promises) {
                return any(promises)
              };
              Promise.prototype.any = function () {
                return any(this)
              }
            }
          },
          {}
        ],
        2: [
          function (_dereq_, module, exports) {
            'use strict';
            var firstLineError;
            try {
              throw new Error
            } catch (e) {
              firstLineError = e
            }
            var schedule = _dereq_('./schedule.js');
            var Queue = _dereq_('./queue.js');
            var util = _dereq_('./util.js');
            function Async() {
              this._isTickUsed = false;
              this._lateQueue = new Queue(16);
              this._normalQueue = new Queue(16);
              this._trampolineEnabled = true;
              var self = this;
              this.drainQueues = function () {
                self._drainQueues()
              };
              this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule
            }
            Async.prototype.disableTrampolineIfNecessary = function () {
              if (util.hasDevTools) {
                this._trampolineEnabled = false
              }
            };
            Async.prototype.enableTrampoline = function () {
              if (!this._trampolineEnabled) {
                this._trampolineEnabled = true;
                this._schedule = function (fn) {
                  setTimeout(fn, 0)
                }
              }
            };
            Async.prototype.haveItemsQueued = function () {
              return this._normalQueue.length() > 0
            };
            Async.prototype.throwLater = function (fn, arg) {
              if (arguments.length === 1) {
                arg = fn;
                fn = function () {
                  throw arg
                }
              }
              if (typeof setTimeout !== 'undefined') {
                setTimeout(function () {
                  fn(arg)
                }, 0)
              } else
                try {
                  this._schedule(function () {
                    fn(arg)
                  })
                } catch (e) {
                  throw new Error('No async scheduler available\n\n    See http://goo.gl/m3OTXk\n')
                }
            };
            function AsyncInvokeLater(fn, receiver, arg) {
              this._lateQueue.push(fn, receiver, arg);
              this._queueTick()
            }
            function AsyncInvoke(fn, receiver, arg) {
              this._normalQueue.push(fn, receiver, arg);
              this._queueTick()
            }
            function AsyncSettlePromises(promise) {
              this._normalQueue._pushOne(promise);
              this._queueTick()
            }
            if (!util.hasDevTools) {
              Async.prototype.invokeLater = AsyncInvokeLater;
              Async.prototype.invoke = AsyncInvoke;
              Async.prototype.settlePromises = AsyncSettlePromises
            } else {
              if (schedule.isStatic) {
                schedule = function (fn) {
                  setTimeout(fn, 0)
                }
              }
              Async.prototype.invokeLater = function (fn, receiver, arg) {
                if (this._trampolineEnabled) {
                  AsyncInvokeLater.call(this, fn, receiver, arg)
                } else {
                  this._schedule(function () {
                    setTimeout(function () {
                      fn.call(receiver, arg)
                    }, 100)
                  })
                }
              };
              Async.prototype.invoke = function (fn, receiver, arg) {
                if (this._trampolineEnabled) {
                  AsyncInvoke.call(this, fn, receiver, arg)
                } else {
                  this._schedule(function () {
                    fn.call(receiver, arg)
                  })
                }
              };
              Async.prototype.settlePromises = function (promise) {
                if (this._trampolineEnabled) {
                  AsyncSettlePromises.call(this, promise)
                } else {
                  this._schedule(function () {
                    promise._settlePromises()
                  })
                }
              }
            }
            Async.prototype.invokeFirst = function (fn, receiver, arg) {
              this._normalQueue.unshift(fn, receiver, arg);
              this._queueTick()
            };
            Async.prototype._drainQueue = function (queue) {
              while (queue.length() > 0) {
                var fn = queue.shift();
                if (typeof fn !== 'function') {
                  fn._settlePromises();
                  continue
                }
                var receiver = queue.shift();
                var arg = queue.shift();
                fn.call(receiver, arg)
              }
            };
            Async.prototype._drainQueues = function () {
              this._drainQueue(this._normalQueue);
              this._reset();
              this._drainQueue(this._lateQueue)
            };
            Async.prototype._queueTick = function () {
              if (!this._isTickUsed) {
                this._isTickUsed = true;
                this._schedule(this.drainQueues)
              }
            };
            Async.prototype._reset = function () {
              this._isTickUsed = false
            };
            module.exports = new Async;
            module.exports.firstLineError = firstLineError
          },
          {
            './queue.js': 28,
            './schedule.js': 31,
            './util.js': 38
          }
        ],
        3: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL, tryConvertToPromise) {
              var rejectThis = function (_, e) {
                this._reject(e)
              };
              var targetRejected = function (e, context) {
                context.promiseRejectionQueued = true;
                context.bindingPromise._then(rejectThis, rejectThis, null, this, e)
              };
              var bindingResolved = function (thisArg, context) {
                if (this._isPending()) {
                  this._resolveCallback(context.target)
                }
              };
              var bindingRejected = function (e, context) {
                if (!context.promiseRejectionQueued)
                  this._reject(e)
              };
              Promise.prototype.bind = function (thisArg) {
                var maybePromise = tryConvertToPromise(thisArg);
                var ret = new Promise(INTERNAL);
                ret._propagateFrom(this, 1);
                var target = this._target();
                ret._setBoundTo(maybePromise);
                if (maybePromise instanceof Promise) {
                  var context = {
                    promiseRejectionQueued: false,
                    promise: ret,
                    target: target,
                    bindingPromise: maybePromise
                  };
                  target._then(INTERNAL, targetRejected, ret._progress, ret, context);
                  maybePromise._then(bindingResolved, bindingRejected, ret._progress, ret, context)
                } else {
                  ret._resolveCallback(target)
                }
                return ret
              };
              Promise.prototype._setBoundTo = function (obj) {
                if (obj !== undefined) {
                  this._bitField = this._bitField | 131072;
                  this._boundTo = obj
                } else {
                  this._bitField = this._bitField & ~131072
                }
              };
              Promise.prototype._isBound = function () {
                return (this._bitField & 131072) === 131072
              };
              Promise.bind = function (thisArg, value) {
                var maybePromise = tryConvertToPromise(thisArg);
                var ret = new Promise(INTERNAL);
                ret._setBoundTo(maybePromise);
                if (maybePromise instanceof Promise) {
                  maybePromise._then(function () {
                    ret._resolveCallback(value)
                  }, ret._reject, ret._progress, ret, null)
                } else {
                  ret._resolveCallback(value)
                }
                return ret
              }
            }
          },
          {}
        ],
        4: [
          function (_dereq_, module, exports) {
            'use strict';
            var old;
            if (typeof Promise !== 'undefined')
              old = Promise;
            function noConflict() {
              try {
                if (Promise === bluebird)
                  Promise = old
              } catch (e) {
              }
              return bluebird
            }
            var bluebird = _dereq_('./promise.js')();
            bluebird.noConflict = noConflict;
            module.exports = bluebird
          },
          { './promise.js': 23 }
        ],
        5: [
          function (_dereq_, module, exports) {
            'use strict';
            var cr = Object.create;
            if (cr) {
              var callerCache = cr(null);
              var getterCache = cr(null);
              callerCache[' size'] = getterCache[' size'] = 0
            }
            module.exports = function (Promise) {
              var util = _dereq_('./util.js');
              var canEvaluate = util.canEvaluate;
              var isIdentifier = util.isIdentifier;
              var getMethodCaller;
              var getGetter;
              if (!true) {
                var makeMethodCaller = function (methodName) {
                  return new Function('ensureMethod', "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod)
                };
                var makeGetter = function (propertyName) {
                  return new Function('obj', "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace('propertyName', propertyName))
                };
                var getCompiled = function (name, compiler, cache) {
                  var ret = cache[name];
                  if (typeof ret !== 'function') {
                    if (!isIdentifier(name)) {
                      return null
                    }
                    ret = compiler(name);
                    cache[name] = ret;
                    cache[' size']++;
                    if (cache[' size'] > 512) {
                      var keys = Object.keys(cache);
                      for (var i = 0; i < 256; ++i)
                        delete cache[keys[i]];
                      cache[' size'] = keys.length - 256
                    }
                  }
                  return ret
                };
                getMethodCaller = function (name) {
                  return getCompiled(name, makeMethodCaller, callerCache)
                };
                getGetter = function (name) {
                  return getCompiled(name, makeGetter, getterCache)
                }
              }
              function ensureMethod(obj, methodName) {
                var fn;
                if (obj != null)
                  fn = obj[methodName];
                if (typeof fn !== 'function') {
                  var message = 'Object ' + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
                  throw new Promise.TypeError(message)
                }
                return fn
              }
              function caller(obj) {
                var methodName = this.pop();
                var fn = ensureMethod(obj, methodName);
                return fn.apply(obj, this)
              }
              Promise.prototype.call = function (methodName) {
                var $_len = arguments.length;
                var args = new Array($_len - 1);
                for (var $_i = 1; $_i < $_len; ++$_i) {
                  args[$_i - 1] = arguments[$_i]
                }
                if (!true) {
                  if (canEvaluate) {
                    var maybeCaller = getMethodCaller(methodName);
                    if (maybeCaller !== null) {
                      return this._then(maybeCaller, undefined, undefined, args, undefined)
                    }
                  }
                }
                args.push(methodName);
                return this._then(caller, undefined, undefined, args, undefined)
              };
              function namedGetter(obj) {
                return obj[this]
              }
              function indexedGetter(obj) {
                var index = +this;
                if (index < 0)
                  index = Math.max(0, index + obj.length);
                return obj[index]
              }
              Promise.prototype.get = function (propertyName) {
                var isIndex = typeof propertyName === 'number';
                var getter;
                if (!isIndex) {
                  if (canEvaluate) {
                    var maybeGetter = getGetter(propertyName);
                    getter = maybeGetter !== null ? maybeGetter : namedGetter
                  } else {
                    getter = namedGetter
                  }
                } else {
                  getter = indexedGetter
                }
                return this._then(getter, undefined, undefined, propertyName, undefined)
              }
            }
          },
          { './util.js': 38 }
        ],
        6: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise) {
              var errors = _dereq_('./errors.js');
              var async = _dereq_('./async.js');
              var CancellationError = errors.CancellationError;
              Promise.prototype._cancel = function (reason) {
                if (!this.isCancellable())
                  return this;
                var parent;
                var promiseToReject = this;
                while ((parent = promiseToReject._cancellationParent) !== undefined && parent.isCancellable()) {
                  promiseToReject = parent
                }
                this._unsetCancellable();
                promiseToReject._target()._rejectCallback(reason, false, true)
              };
              Promise.prototype.cancel = function (reason) {
                if (!this.isCancellable())
                  return this;
                if (reason === undefined)
                  reason = new CancellationError;
                async.invokeLater(this._cancel, this, reason);
                return this
              };
              Promise.prototype.cancellable = function () {
                if (this._cancellable())
                  return this;
                async.enableTrampoline();
                this._setCancellable();
                this._cancellationParent = undefined;
                return this
              };
              Promise.prototype.uncancellable = function () {
                var ret = this.then();
                ret._unsetCancellable();
                return ret
              };
              Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
                var ret = this._then(didFulfill, didReject, didProgress, undefined, undefined);
                ret._setCancellable();
                ret._cancellationParent = undefined;
                return ret
              }
            }
          },
          {
            './async.js': 2,
            './errors.js': 13
          }
        ],
        7: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function () {
              var async = _dereq_('./async.js');
              var util = _dereq_('./util.js');
              var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
              var stackFramePattern = null;
              var formatStack = null;
              var indentStackFrames = false;
              var warn;
              function CapturedTrace(parent) {
                this._parent = parent;
                var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
                captureStackTrace(this, CapturedTrace);
                if (length > 32)
                  this.uncycle()
              }
              util.inherits(CapturedTrace, Error);
              CapturedTrace.prototype.uncycle = function () {
                var length = this._length;
                if (length < 2)
                  return;
                var nodes = [];
                var stackToIndex = {};
                for (var i = 0, node = this; node !== undefined; ++i) {
                  nodes.push(node);
                  node = node._parent
                }
                length = this._length = i;
                for (var i = length - 1; i >= 0; --i) {
                  var stack = nodes[i].stack;
                  if (stackToIndex[stack] === undefined) {
                    stackToIndex[stack] = i
                  }
                }
                for (var i = 0; i < length; ++i) {
                  var currentStack = nodes[i].stack;
                  var index = stackToIndex[currentStack];
                  if (index !== undefined && index !== i) {
                    if (index > 0) {
                      nodes[index - 1]._parent = undefined;
                      nodes[index - 1]._length = 1
                    }
                    nodes[i]._parent = undefined;
                    nodes[i]._length = 1;
                    var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                    if (index < length - 1) {
                      cycleEdgeNode._parent = nodes[index + 1];
                      cycleEdgeNode._parent.uncycle();
                      cycleEdgeNode._length = cycleEdgeNode._parent._length + 1
                    } else {
                      cycleEdgeNode._parent = undefined;
                      cycleEdgeNode._length = 1
                    }
                    var currentChildLength = cycleEdgeNode._length + 1;
                    for (var j = i - 2; j >= 0; --j) {
                      nodes[j]._length = currentChildLength;
                      currentChildLength++
                    }
                    return
                  }
                }
              };
              CapturedTrace.prototype.parent = function () {
                return this._parent
              };
              CapturedTrace.prototype.hasParent = function () {
                return this._parent !== undefined
              };
              CapturedTrace.prototype.attachExtraTrace = function (error) {
                if (error.__stackCleaned__)
                  return;
                this.uncycle();
                var parsed = CapturedTrace.parseStackAndMessage(error);
                var message = parsed.message;
                var stacks = [parsed.stack];
                var trace = this;
                while (trace !== undefined) {
                  stacks.push(cleanStack(trace.stack.split('\n')));
                  trace = trace._parent
                }
                removeCommonRoots(stacks);
                removeDuplicateOrEmptyJumps(stacks);
                util.notEnumerableProp(error, 'stack', reconstructStack(message, stacks));
                util.notEnumerableProp(error, '__stackCleaned__', true)
              };
              function reconstructStack(message, stacks) {
                for (var i = 0; i < stacks.length - 1; ++i) {
                  stacks[i].push('From previous event:');
                  stacks[i] = stacks[i].join('\n')
                }
                if (i < stacks.length) {
                  stacks[i] = stacks[i].join('\n')
                }
                return message + '\n' + stacks.join('\n')
              }
              function removeDuplicateOrEmptyJumps(stacks) {
                for (var i = 0; i < stacks.length; ++i) {
                  if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                    stacks.splice(i, 1);
                    i--
                  }
                }
              }
              function removeCommonRoots(stacks) {
                var current = stacks[0];
                for (var i = 1; i < stacks.length; ++i) {
                  var prev = stacks[i];
                  var currentLastIndex = current.length - 1;
                  var currentLastLine = current[currentLastIndex];
                  var commonRootMeetPoint = -1;
                  for (var j = prev.length - 1; j >= 0; --j) {
                    if (prev[j] === currentLastLine) {
                      commonRootMeetPoint = j;
                      break
                    }
                  }
                  for (var j = commonRootMeetPoint; j >= 0; --j) {
                    var line = prev[j];
                    if (current[currentLastIndex] === line) {
                      current.pop();
                      currentLastIndex--
                    } else {
                      break
                    }
                  }
                  current = prev
                }
              }
              function cleanStack(stack) {
                var ret = [];
                for (var i = 0; i < stack.length; ++i) {
                  var line = stack[i];
                  var isTraceLine = stackFramePattern.test(line) || '    (No stack trace)' === line;
                  var isInternalFrame = isTraceLine && shouldIgnore(line);
                  if (isTraceLine && !isInternalFrame) {
                    if (indentStackFrames && line.charAt(0) !== ' ') {
                      line = '    ' + line
                    }
                    ret.push(line)
                  }
                }
                return ret
              }
              function stackFramesAsArray(error) {
                var stack = error.stack.replace(/\s+$/g, '').split('\n');
                for (var i = 0; i < stack.length; ++i) {
                  var line = stack[i];
                  if ('    (No stack trace)' === line || stackFramePattern.test(line)) {
                    break
                  }
                }
                if (i > 0) {
                  stack = stack.slice(i)
                }
                return stack
              }
              CapturedTrace.parseStackAndMessage = function (error) {
                var stack = error.stack;
                var message = error.toString();
                stack = typeof stack === 'string' && stack.length > 0 ? stackFramesAsArray(error) : ['    (No stack trace)'];
                return {
                  message: message,
                  stack: cleanStack(stack)
                }
              };
              CapturedTrace.formatAndLogError = function (error, title) {
                if (typeof console !== 'undefined') {
                  var message;
                  if (typeof error === 'object' || typeof error === 'function') {
                    var stack = error.stack;
                    message = title + formatStack(stack, error)
                  } else {
                    message = title + String(error)
                  }
                  if (typeof warn === 'function') {
                    warn(message)
                  } else if (typeof console.log === 'function' || typeof console.log === 'object') {
                    console.log(message)
                  }
                }
              };
              CapturedTrace.unhandledRejection = function (reason) {
                CapturedTrace.formatAndLogError(reason, '^--- With additional stack trace: ')
              };
              CapturedTrace.isSupported = function () {
                return typeof captureStackTrace === 'function'
              };
              CapturedTrace.fireRejectionEvent = function (name, localHandler, reason, promise) {
                var localEventFired = false;
                try {
                  if (typeof localHandler === 'function') {
                    localEventFired = true;
                    if (name === 'rejectionHandled') {
                      localHandler(promise)
                    } else {
                      localHandler(reason, promise)
                    }
                  }
                } catch (e) {
                  async.throwLater(e)
                }
                var globalEventFired = false;
                try {
                  globalEventFired = fireGlobalEvent(name, reason, promise)
                } catch (e) {
                  globalEventFired = true;
                  async.throwLater(e)
                }
                var domEventFired = false;
                if (fireDomEvent) {
                  try {
                    domEventFired = fireDomEvent(name.toLowerCase(), {
                      reason: reason,
                      promise: promise
                    })
                  } catch (e) {
                    domEventFired = true;
                    async.throwLater(e)
                  }
                }
                if (!globalEventFired && !localEventFired && !domEventFired && name === 'unhandledRejection') {
                  CapturedTrace.formatAndLogError(reason, 'Unhandled rejection ')
                }
              };
              function formatNonError(obj) {
                var str;
                if (typeof obj === 'function') {
                  str = '[function ' + (obj.name || 'anonymous') + ']'
                } else {
                  str = obj.toString();
                  var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
                  if (ruselessToString.test(str)) {
                    try {
                      var newStr = JSON.stringify(obj);
                      str = newStr
                    } catch (e) {
                    }
                  }
                  if (str.length === 0) {
                    str = '(empty array)'
                  }
                }
                return '(<' + snip(str) + '>, no stack trace)'
              }
              function snip(str) {
                var maxChars = 41;
                if (str.length < maxChars) {
                  return str
                }
                return str.substr(0, maxChars - 3) + '...'
              }
              var shouldIgnore = function () {
                return false
              };
              var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
              function parseLineInfo(line) {
                var matches = line.match(parseLineInfoRegex);
                if (matches) {
                  return {
                    fileName: matches[1],
                    line: parseInt(matches[2], 10)
                  }
                }
              }
              CapturedTrace.setBounds = function (firstLineError, lastLineError) {
                if (!CapturedTrace.isSupported())
                  return;
                var firstStackLines = firstLineError.stack.split('\n');
                var lastStackLines = lastLineError.stack.split('\n');
                var firstIndex = -1;
                var lastIndex = -1;
                var firstFileName;
                var lastFileName;
                for (var i = 0; i < firstStackLines.length; ++i) {
                  var result = parseLineInfo(firstStackLines[i]);
                  if (result) {
                    firstFileName = result.fileName;
                    firstIndex = result.line;
                    break
                  }
                }
                for (var i = 0; i < lastStackLines.length; ++i) {
                  var result = parseLineInfo(lastStackLines[i]);
                  if (result) {
                    lastFileName = result.fileName;
                    lastIndex = result.line;
                    break
                  }
                }
                if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
                  return
                }
                shouldIgnore = function (line) {
                  if (bluebirdFramePattern.test(line))
                    return true;
                  var info = parseLineInfo(line);
                  if (info) {
                    if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                      return true
                    }
                  }
                  return false
                }
              };
              var captureStackTrace = function stackDetection() {
                var v8stackFramePattern = /^\s*at\s*/;
                var v8stackFormatter = function (stack, error) {
                  if (typeof stack === 'string')
                    return stack;
                  if (error.name !== undefined && error.message !== undefined) {
                    return error.toString()
                  }
                  return formatNonError(error)
                };
                if (typeof Error.stackTraceLimit === 'number' && typeof Error.captureStackTrace === 'function') {
                  Error.stackTraceLimit = Error.stackTraceLimit + 6;
                  stackFramePattern = v8stackFramePattern;
                  formatStack = v8stackFormatter;
                  var captureStackTrace = Error.captureStackTrace;
                  shouldIgnore = function (line) {
                    return bluebirdFramePattern.test(line)
                  };
                  return function (receiver, ignoreUntil) {
                    Error.stackTraceLimit = Error.stackTraceLimit + 6;
                    captureStackTrace(receiver, ignoreUntil);
                    Error.stackTraceLimit = Error.stackTraceLimit - 6
                  }
                }
                var err = new Error;
                if (typeof err.stack === 'string' && err.stack.split('\n')[0].indexOf('stackDetection@') >= 0) {
                  stackFramePattern = /@/;
                  formatStack = v8stackFormatter;
                  indentStackFrames = true;
                  return function captureStackTrace(o) {
                    o.stack = new Error().stack
                  }
                }
                var hasStackAfterThrow;
                try {
                  throw new Error
                } catch (e) {
                  hasStackAfterThrow = 'stack' in e
                }
                if (!('stack' in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === 'number') {
                  stackFramePattern = v8stackFramePattern;
                  formatStack = v8stackFormatter;
                  return function captureStackTrace(o) {
                    Error.stackTraceLimit = Error.stackTraceLimit + 6;
                    try {
                      throw new Error
                    } catch (e) {
                      o.stack = e.stack
                    }
                    Error.stackTraceLimit = Error.stackTraceLimit - 6
                  }
                }
                formatStack = function (stack, error) {
                  if (typeof stack === 'string')
                    return stack;
                  if ((typeof error === 'object' || typeof error === 'function') && error.name !== undefined && error.message !== undefined) {
                    return error.toString()
                  }
                  return formatNonError(error)
                };
                return null
              }([]);
              var fireDomEvent;
              var fireGlobalEvent = function () {
                if (util.isNode) {
                  return function (name, reason, promise) {
                    if (name === 'rejectionHandled') {
                      return process.emit(name, promise)
                    } else {
                      return process.emit(name, reason, promise)
                    }
                  }
                } else {
                  var customEventWorks = false;
                  var anyEventWorks = true;
                  try {
                    var ev = new self.CustomEvent('test');
                    customEventWorks = ev instanceof CustomEvent
                  } catch (e) {
                  }
                  if (!customEventWorks) {
                    try {
                      var event = document.createEvent('CustomEvent');
                      event.initCustomEvent('testingtheevent', false, true, {});
                      self.dispatchEvent(event)
                    } catch (e) {
                      anyEventWorks = false
                    }
                  }
                  if (anyEventWorks) {
                    fireDomEvent = function (type, detail) {
                      var event;
                      if (customEventWorks) {
                        event = new self.CustomEvent(type, {
                          detail: detail,
                          bubbles: false,
                          cancelable: true
                        })
                      } else if (self.dispatchEvent) {
                        event = document.createEvent('CustomEvent');
                        event.initCustomEvent(type, false, true, detail)
                      }
                      return event ? !self.dispatchEvent(event) : false
                    }
                  }
                  var toWindowMethodNameMap = {};
                  toWindowMethodNameMap['unhandledRejection'] = ('on' + 'unhandledRejection').toLowerCase();
                  toWindowMethodNameMap['rejectionHandled'] = ('on' + 'rejectionHandled').toLowerCase();
                  return function (name, reason, promise) {
                    var methodName = toWindowMethodNameMap[name];
                    var method = self[methodName];
                    if (!method)
                      return false;
                    if (name === 'rejectionHandled') {
                      method.call(self, promise)
                    } else {
                      method.call(self, reason, promise)
                    }
                    return true
                  }
                }
              }();
              if (typeof console !== 'undefined' && typeof console.warn !== 'undefined') {
                warn = function (message) {
                  console.warn(message)
                };
                if (util.isNode && process.stderr.isTTY) {
                  warn = function (message) {
                    process.stderr.write('[31m' + message + '[39m\n')
                  }
                } else if (!util.isNode && typeof new Error().stack === 'string') {
                  warn = function (message) {
                    console.warn('%c' + message, 'color: red')
                  }
                }
              }
              return CapturedTrace
            }
          },
          {
            './async.js': 2,
            './util.js': 38
          }
        ],
        8: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (NEXT_FILTER) {
              var util = _dereq_('./util.js');
              var errors = _dereq_('./errors.js');
              var tryCatch = util.tryCatch;
              var errorObj = util.errorObj;
              var keys = _dereq_('./es5.js').keys;
              var TypeError = errors.TypeError;
              function CatchFilter(instances, callback, promise) {
                this._instances = instances;
                this._callback = callback;
                this._promise = promise
              }
              function safePredicate(predicate, e) {
                var safeObject = {};
                var retfilter = tryCatch(predicate).call(safeObject, e);
                if (retfilter === errorObj)
                  return retfilter;
                var safeKeys = keys(safeObject);
                if (safeKeys.length) {
                  errorObj.e = new TypeError('Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n');
                  return errorObj
                }
                return retfilter
              }
              CatchFilter.prototype.doFilter = function (e) {
                var cb = this._callback;
                var promise = this._promise;
                var boundTo = promise._boundValue();
                for (var i = 0, len = this._instances.length; i < len; ++i) {
                  var item = this._instances[i];
                  var itemIsErrorType = item === Error || item != null && item.prototype instanceof Error;
                  if (itemIsErrorType && e instanceof item) {
                    var ret = tryCatch(cb).call(boundTo, e);
                    if (ret === errorObj) {
                      NEXT_FILTER.e = ret.e;
                      return NEXT_FILTER
                    }
                    return ret
                  } else if (typeof item === 'function' && !itemIsErrorType) {
                    var shouldHandle = safePredicate(item, e);
                    if (shouldHandle === errorObj) {
                      e = errorObj.e;
                      break
                    } else if (shouldHandle) {
                      var ret = tryCatch(cb).call(boundTo, e);
                      if (ret === errorObj) {
                        NEXT_FILTER.e = ret.e;
                        return NEXT_FILTER
                      }
                      return ret
                    }
                  }
                }
                NEXT_FILTER.e = e;
                return NEXT_FILTER
              };
              return CatchFilter
            }
          },
          {
            './errors.js': 13,
            './es5.js': 14,
            './util.js': 38
          }
        ],
        9: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, CapturedTrace, isDebugging) {
              var contextStack = [];
              function Context() {
                this._trace = new CapturedTrace(peekContext())
              }
              Context.prototype._pushContext = function () {
                if (!isDebugging())
                  return;
                if (this._trace !== undefined) {
                  contextStack.push(this._trace)
                }
              };
              Context.prototype._popContext = function () {
                if (!isDebugging())
                  return;
                if (this._trace !== undefined) {
                  contextStack.pop()
                }
              };
              function createContext() {
                if (isDebugging())
                  return new Context
              }
              function peekContext() {
                var lastIndex = contextStack.length - 1;
                if (lastIndex >= 0) {
                  return contextStack[lastIndex]
                }
                return undefined
              }
              Promise.prototype._peekContext = peekContext;
              Promise.prototype._pushContext = Context.prototype._pushContext;
              Promise.prototype._popContext = Context.prototype._popContext;
              return createContext
            }
          },
          {}
        ],
        10: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, CapturedTrace) {
              var getDomain = Promise._getDomain;
              var async = _dereq_('./async.js');
              var Warning = _dereq_('./errors.js').Warning;
              var util = _dereq_('./util.js');
              var canAttachTrace = util.canAttachTrace;
              var unhandledRejectionHandled;
              var possiblyUnhandledRejection;
              var debugging = false || util.isNode && (!!process.env['BLUEBIRD_DEBUG'] || process.env['NODE_ENV'] === 'development');
              if (debugging) {
                async.disableTrampolineIfNecessary()
              }
              Promise.prototype._ignoreRejections = function () {
                this._unsetRejectionIsUnhandled();
                this._bitField = this._bitField | 16777216
              };
              Promise.prototype._ensurePossibleRejectionHandled = function () {
                if ((this._bitField & 16777216) !== 0)
                  return;
                this._setRejectionIsUnhandled();
                async.invokeLater(this._notifyUnhandledRejection, this, undefined)
              };
              Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
                CapturedTrace.fireRejectionEvent('rejectionHandled', unhandledRejectionHandled, undefined, this)
              };
              Promise.prototype._notifyUnhandledRejection = function () {
                if (this._isRejectionUnhandled()) {
                  var reason = this._getCarriedStackTrace() || this._settledValue;
                  this._setUnhandledRejectionIsNotified();
                  CapturedTrace.fireRejectionEvent('unhandledRejection', possiblyUnhandledRejection, reason, this)
                }
              };
              Promise.prototype._setUnhandledRejectionIsNotified = function () {
                this._bitField = this._bitField | 524288
              };
              Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
                this._bitField = this._bitField & ~524288
              };
              Promise.prototype._isUnhandledRejectionNotified = function () {
                return (this._bitField & 524288) > 0
              };
              Promise.prototype._setRejectionIsUnhandled = function () {
                this._bitField = this._bitField | 2097152
              };
              Promise.prototype._unsetRejectionIsUnhandled = function () {
                this._bitField = this._bitField & ~2097152;
                if (this._isUnhandledRejectionNotified()) {
                  this._unsetUnhandledRejectionIsNotified();
                  this._notifyUnhandledRejectionIsHandled()
                }
              };
              Promise.prototype._isRejectionUnhandled = function () {
                return (this._bitField & 2097152) > 0
              };
              Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
                this._bitField = this._bitField | 1048576;
                this._fulfillmentHandler0 = capturedTrace
              };
              Promise.prototype._isCarryingStackTrace = function () {
                return (this._bitField & 1048576) > 0
              };
              Promise.prototype._getCarriedStackTrace = function () {
                return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : undefined
              };
              Promise.prototype._captureStackTrace = function () {
                if (debugging) {
                  this._trace = new CapturedTrace(this._peekContext())
                }
                return this
              };
              Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
                if (debugging && canAttachTrace(error)) {
                  var trace = this._trace;
                  if (trace !== undefined) {
                    if (ignoreSelf)
                      trace = trace._parent
                  }
                  if (trace !== undefined) {
                    trace.attachExtraTrace(error)
                  } else if (!error.__stackCleaned__) {
                    var parsed = CapturedTrace.parseStackAndMessage(error);
                    util.notEnumerableProp(error, 'stack', parsed.message + '\n' + parsed.stack.join('\n'));
                    util.notEnumerableProp(error, '__stackCleaned__', true)
                  }
                }
              };
              Promise.prototype._warn = function (message) {
                var warning = new Warning(message);
                var ctx = this._peekContext();
                if (ctx) {
                  ctx.attachExtraTrace(warning)
                } else {
                  var parsed = CapturedTrace.parseStackAndMessage(warning);
                  warning.stack = parsed.message + '\n' + parsed.stack.join('\n')
                }
                CapturedTrace.formatAndLogError(warning, '')
              };
              Promise.onPossiblyUnhandledRejection = function (fn) {
                var domain = getDomain();
                possiblyUnhandledRejection = typeof fn === 'function' ? domain === null ? fn : domain.bind(fn) : undefined
              };
              Promise.onUnhandledRejectionHandled = function (fn) {
                var domain = getDomain();
                unhandledRejectionHandled = typeof fn === 'function' ? domain === null ? fn : domain.bind(fn) : undefined
              };
              Promise.longStackTraces = function () {
                if (async.haveItemsQueued() && debugging === false) {
                  throw new Error('cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n')
                }
                debugging = CapturedTrace.isSupported();
                if (debugging) {
                  async.disableTrampolineIfNecessary()
                }
              };
              Promise.hasLongStackTraces = function () {
                return debugging && CapturedTrace.isSupported()
              };
              if (!CapturedTrace.isSupported()) {
                Promise.longStackTraces = function () {
                };
                debugging = false
              }
              return function () {
                return debugging
              }
            }
          },
          {
            './async.js': 2,
            './errors.js': 13,
            './util.js': 38
          }
        ],
        11: [
          function (_dereq_, module, exports) {
            'use strict';
            var util = _dereq_('./util.js');
            var isPrimitive = util.isPrimitive;
            module.exports = function (Promise) {
              var returner = function () {
                return this
              };
              var thrower = function () {
                throw this
              };
              var returnUndefined = function () {
              };
              var throwUndefined = function () {
                throw undefined
              };
              var wrapper = function (value, action) {
                if (action === 1) {
                  return function () {
                    throw value
                  }
                } else if (action === 2) {
                  return function () {
                    return value
                  }
                }
              };
              Promise.prototype['return'] = Promise.prototype.thenReturn = function (value) {
                if (value === undefined)
                  return this.then(returnUndefined);
                if (isPrimitive(value)) {
                  return this._then(wrapper(value, 2), undefined, undefined, undefined, undefined)
                }
                return this._then(returner, undefined, undefined, value, undefined)
              };
              Promise.prototype['throw'] = Promise.prototype.thenThrow = function (reason) {
                if (reason === undefined)
                  return this.then(throwUndefined);
                if (isPrimitive(reason)) {
                  return this._then(wrapper(reason, 1), undefined, undefined, undefined, undefined)
                }
                return this._then(thrower, undefined, undefined, reason, undefined)
              }
            }
          },
          { './util.js': 38 }
        ],
        12: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
              var PromiseReduce = Promise.reduce;
              Promise.prototype.each = function (fn) {
                return PromiseReduce(this, fn, null, INTERNAL)
              };
              Promise.each = function (promises, fn) {
                return PromiseReduce(promises, fn, null, INTERNAL)
              }
            }
          },
          {}
        ],
        13: [
          function (_dereq_, module, exports) {
            'use strict';
            var es5 = _dereq_('./es5.js');
            var Objectfreeze = es5.freeze;
            var util = _dereq_('./util.js');
            var inherits = util.inherits;
            var notEnumerableProp = util.notEnumerableProp;
            function subError(nameProperty, defaultMessage) {
              function SubError(message) {
                if (!(this instanceof SubError))
                  return new SubError(message);
                notEnumerableProp(this, 'message', typeof message === 'string' ? message : defaultMessage);
                notEnumerableProp(this, 'name', nameProperty);
                if (Error.captureStackTrace) {
                  Error.captureStackTrace(this, this.constructor)
                } else {
                  Error.call(this)
                }
              }
              inherits(SubError, Error);
              return SubError
            }
            var _TypeError, _RangeError;
            var Warning = subError('Warning', 'warning');
            var CancellationError = subError('CancellationError', 'cancellation error');
            var TimeoutError = subError('TimeoutError', 'timeout error');
            var AggregateError = subError('AggregateError', 'aggregate error');
            try {
              _TypeError = TypeError;
              _RangeError = RangeError
            } catch (e) {
              _TypeError = subError('TypeError', 'type error');
              _RangeError = subError('RangeError', 'range error')
            }
            var methods = ('join pop push shift unshift slice filter forEach some ' + 'every map indexOf lastIndexOf reduce reduceRight sort reverse').split(' ');
            for (var i = 0; i < methods.length; ++i) {
              if (typeof Array.prototype[methods[i]] === 'function') {
                AggregateError.prototype[methods[i]] = Array.prototype[methods[i]]
              }
            }
            es5.defineProperty(AggregateError.prototype, 'length', {
              value: 0,
              configurable: false,
              writable: true,
              enumerable: true
            });
            AggregateError.prototype['isOperational'] = true;
            var level = 0;
            AggregateError.prototype.toString = function () {
              var indent = Array(level * 4 + 1).join(' ');
              var ret = '\n' + indent + 'AggregateError of:' + '\n';
              level++;
              indent = Array(level * 4 + 1).join(' ');
              for (var i = 0; i < this.length; ++i) {
                var str = this[i] === this ? '[Circular AggregateError]' : this[i] + '';
                var lines = str.split('\n');
                for (var j = 0; j < lines.length; ++j) {
                  lines[j] = indent + lines[j]
                }
                str = lines.join('\n');
                ret += str + '\n'
              }
              level--;
              return ret
            };
            function OperationalError(message) {
              if (!(this instanceof OperationalError))
                return new OperationalError(message);
              notEnumerableProp(this, 'name', 'OperationalError');
              notEnumerableProp(this, 'message', message);
              this.cause = message;
              this['isOperational'] = true;
              if (message instanceof Error) {
                notEnumerableProp(this, 'message', message.message);
                notEnumerableProp(this, 'stack', message.stack)
              } else if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor)
              }
            }
            inherits(OperationalError, Error);
            var errorTypes = Error['__BluebirdErrorTypes__'];
            if (!errorTypes) {
              errorTypes = Objectfreeze({
                CancellationError: CancellationError,
                TimeoutError: TimeoutError,
                OperationalError: OperationalError,
                RejectionError: OperationalError,
                AggregateError: AggregateError
              });
              notEnumerableProp(Error, '__BluebirdErrorTypes__', errorTypes)
            }
            module.exports = {
              Error: Error,
              TypeError: _TypeError,
              RangeError: _RangeError,
              CancellationError: errorTypes.CancellationError,
              OperationalError: errorTypes.OperationalError,
              TimeoutError: errorTypes.TimeoutError,
              AggregateError: errorTypes.AggregateError,
              Warning: Warning
            }
          },
          {
            './es5.js': 14,
            './util.js': 38
          }
        ],
        14: [
          function (_dereq_, module, exports) {
            var isES5 = function () {
              'use strict';
              return this === undefined
            }();
            if (isES5) {
              module.exports = {
                freeze: Object.freeze,
                defineProperty: Object.defineProperty,
                getDescriptor: Object.getOwnPropertyDescriptor,
                keys: Object.keys,
                names: Object.getOwnPropertyNames,
                getPrototypeOf: Object.getPrototypeOf,
                isArray: Array.isArray,
                isES5: isES5,
                propertyIsWritable: function (obj, prop) {
                  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                  return !!(!descriptor || descriptor.writable || descriptor.set)
                }
              }
            } else {
              var has = {}.hasOwnProperty;
              var str = {}.toString;
              var proto = {}.constructor.prototype;
              var ObjectKeys = function (o) {
                var ret = [];
                for (var key in o) {
                  if (has.call(o, key)) {
                    ret.push(key)
                  }
                }
                return ret
              };
              var ObjectGetDescriptor = function (o, key) {
                return { value: o[key] }
              };
              var ObjectDefineProperty = function (o, key, desc) {
                o[key] = desc.value;
                return o
              };
              var ObjectFreeze = function (obj) {
                return obj
              };
              var ObjectGetPrototypeOf = function (obj) {
                try {
                  return Object(obj).constructor.prototype
                } catch (e) {
                  return proto
                }
              };
              var ArrayIsArray = function (obj) {
                try {
                  return str.call(obj) === '[object Array]'
                } catch (e) {
                  return false
                }
              };
              module.exports = {
                isArray: ArrayIsArray,
                keys: ObjectKeys,
                names: ObjectKeys,
                defineProperty: ObjectDefineProperty,
                getDescriptor: ObjectGetDescriptor,
                freeze: ObjectFreeze,
                getPrototypeOf: ObjectGetPrototypeOf,
                isES5: isES5,
                propertyIsWritable: function () {
                  return true
                }
              }
            }
          },
          {}
        ],
        15: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
              var PromiseMap = Promise.map;
              Promise.prototype.filter = function (fn, options) {
                return PromiseMap(this, fn, options, INTERNAL)
              };
              Promise.filter = function (promises, fn, options) {
                return PromiseMap(promises, fn, options, INTERNAL)
              }
            }
          },
          {}
        ],
        16: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, NEXT_FILTER, tryConvertToPromise) {
              var util = _dereq_('./util.js');
              var isPrimitive = util.isPrimitive;
              var thrower = util.thrower;
              function returnThis() {
                return this
              }
              function throwThis() {
                throw this
              }
              function return$(r) {
                return function () {
                  return r
                }
              }
              function throw$(r) {
                return function () {
                  throw r
                }
              }
              function promisedFinally(ret, reasonOrValue, isFulfilled) {
                var then;
                if (isPrimitive(reasonOrValue)) {
                  then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue)
                } else {
                  then = isFulfilled ? returnThis : throwThis
                }
                return ret._then(then, thrower, undefined, reasonOrValue, undefined)
              }
              function finallyHandler(reasonOrValue) {
                var promise = this.promise;
                var handler = this.handler;
                var ret = promise._isBound() ? handler.call(promise._boundValue()) : handler();
                if (ret !== undefined) {
                  var maybePromise = tryConvertToPromise(ret, promise);
                  if (maybePromise instanceof Promise) {
                    maybePromise = maybePromise._target();
                    return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled())
                  }
                }
                if (promise.isRejected()) {
                  NEXT_FILTER.e = reasonOrValue;
                  return NEXT_FILTER
                } else {
                  return reasonOrValue
                }
              }
              function tapHandler(value) {
                var promise = this.promise;
                var handler = this.handler;
                var ret = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);
                if (ret !== undefined) {
                  var maybePromise = tryConvertToPromise(ret, promise);
                  if (maybePromise instanceof Promise) {
                    maybePromise = maybePromise._target();
                    return promisedFinally(maybePromise, value, true)
                  }
                }
                return value
              }
              Promise.prototype._passThroughHandler = function (handler, isFinally) {
                if (typeof handler !== 'function')
                  return this.then();
                var promiseAndHandler = {
                  promise: this,
                  handler: handler
                };
                return this._then(isFinally ? finallyHandler : tapHandler, isFinally ? finallyHandler : undefined, undefined, promiseAndHandler, undefined)
              };
              Promise.prototype.lastly = Promise.prototype['finally'] = function (handler) {
                return this._passThroughHandler(handler, true)
              };
              Promise.prototype.tap = function (handler) {
                return this._passThroughHandler(handler, false)
              }
            }
          },
          { './util.js': 38 }
        ],
        17: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise) {
              var errors = _dereq_('./errors.js');
              var TypeError = errors.TypeError;
              var util = _dereq_('./util.js');
              var errorObj = util.errorObj;
              var tryCatch = util.tryCatch;
              var yieldHandlers = [];
              function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
                for (var i = 0; i < yieldHandlers.length; ++i) {
                  traceParent._pushContext();
                  var result = tryCatch(yieldHandlers[i])(value);
                  traceParent._popContext();
                  if (result === errorObj) {
                    traceParent._pushContext();
                    var ret = Promise.reject(errorObj.e);
                    traceParent._popContext();
                    return ret
                  }
                  var maybePromise = tryConvertToPromise(result, traceParent);
                  if (maybePromise instanceof Promise)
                    return maybePromise
                }
                return null
              }
              function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
                var promise = this._promise = new Promise(INTERNAL);
                promise._captureStackTrace();
                this._stack = stack;
                this._generatorFunction = generatorFunction;
                this._receiver = receiver;
                this._generator = undefined;
                this._yieldHandlers = typeof yieldHandler === 'function' ? [yieldHandler].concat(yieldHandlers) : yieldHandlers
              }
              PromiseSpawn.prototype.promise = function () {
                return this._promise
              };
              PromiseSpawn.prototype._run = function () {
                this._generator = this._generatorFunction.call(this._receiver);
                this._receiver = this._generatorFunction = undefined;
                this._next(undefined)
              };
              PromiseSpawn.prototype._continue = function (result) {
                if (result === errorObj) {
                  return this._promise._rejectCallback(result.e, false, true)
                }
                var value = result.value;
                if (result.done === true) {
                  this._promise._resolveCallback(value)
                } else {
                  var maybePromise = tryConvertToPromise(value, this._promise);
                  if (!(maybePromise instanceof Promise)) {
                    maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                    if (maybePromise === null) {
                      this._throw(new TypeError('A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n'.replace('%s', value) + 'From coroutine:\n' + this._stack.split('\n').slice(1, -7).join('\n')));
                      return
                    }
                  }
                  maybePromise._then(this._next, this._throw, undefined, this, null)
                }
              };
              PromiseSpawn.prototype._throw = function (reason) {
                this._promise._attachExtraTrace(reason);
                this._promise._pushContext();
                var result = tryCatch(this._generator['throw']).call(this._generator, reason);
                this._promise._popContext();
                this._continue(result)
              };
              PromiseSpawn.prototype._next = function (value) {
                this._promise._pushContext();
                var result = tryCatch(this._generator.next).call(this._generator, value);
                this._promise._popContext();
                this._continue(result)
              };
              Promise.coroutine = function (generatorFunction, options) {
                if (typeof generatorFunction !== 'function') {
                  throw new TypeError('generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n')
                }
                var yieldHandler = Object(options).yieldHandler;
                var PromiseSpawn$ = PromiseSpawn;
                var stack = new Error().stack;
                return function () {
                  var generator = generatorFunction.apply(this, arguments);
                  var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
                  spawn._generator = generator;
                  spawn._next(undefined);
                  return spawn.promise()
                }
              };
              Promise.coroutine.addYieldHandler = function (fn) {
                if (typeof fn !== 'function')
                  throw new TypeError('fn must be a function\n\n    See http://goo.gl/916lJJ\n');
                yieldHandlers.push(fn)
              };
              Promise.spawn = function (generatorFunction) {
                if (typeof generatorFunction !== 'function') {
                  return apiRejection('generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n')
                }
                var spawn = new PromiseSpawn(generatorFunction, this);
                var ret = spawn.promise();
                spawn._run(Promise.spawn);
                return ret
              }
            }
          },
          {
            './errors.js': 13,
            './util.js': 38
          }
        ],
        18: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
              var util = _dereq_('./util.js');
              var canEvaluate = util.canEvaluate;
              var tryCatch = util.tryCatch;
              var errorObj = util.errorObj;
              var reject;
              if (!true) {
                if (canEvaluate) {
                  var thenCallback = function (i) {
                    return new Function('value', 'holder', "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i))
                  };
                  var caller = function (count) {
                    var values = [];
                    for (var i = 1; i <= count; ++i)
                      values.push('holder.p' + i);
                    return new Function('holder', "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ".replace(/values/g, values.join(', ')))
                  };
                  var thenCallbacks = [];
                  var callers = [undefined];
                  for (var i = 1; i <= 5; ++i) {
                    thenCallbacks.push(thenCallback(i));
                    callers.push(caller(i))
                  }
                  var Holder = function (total, fn) {
                    this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                    this.fn = fn;
                    this.total = total;
                    this.now = 0
                  };
                  Holder.prototype.callers = callers;
                  Holder.prototype.checkFulfillment = function (promise) {
                    var now = this.now;
                    now++;
                    var total = this.total;
                    if (now >= total) {
                      var handler = this.callers[total];
                      promise._pushContext();
                      var ret = tryCatch(handler)(this);
                      promise._popContext();
                      if (ret === errorObj) {
                        promise._rejectCallback(ret.e, false, true)
                      } else {
                        promise._resolveCallback(ret)
                      }
                    } else {
                      this.now = now
                    }
                  };
                  var reject = function (reason) {
                    this._reject(reason)
                  }
                }
              }
              Promise.join = function () {
                var last = arguments.length - 1;
                var fn;
                if (last > 0 && typeof arguments[last] === 'function') {
                  fn = arguments[last];
                  if (!true) {
                    if (last < 6 && canEvaluate) {
                      var ret = new Promise(INTERNAL);
                      ret._captureStackTrace();
                      var holder = new Holder(last, fn);
                      var callbacks = thenCallbacks;
                      for (var i = 0; i < last; ++i) {
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                          maybePromise = maybePromise._target();
                          if (maybePromise._isPending()) {
                            maybePromise._then(callbacks[i], reject, undefined, ret, holder)
                          } else if (maybePromise._isFulfilled()) {
                            callbacks[i].call(ret, maybePromise._value(), holder)
                          } else {
                            ret._reject(maybePromise._reason())
                          }
                        } else {
                          callbacks[i].call(ret, maybePromise, holder)
                        }
                      }
                      return ret
                    }
                  }
                }
                var $_len = arguments.length;
                var args = new Array($_len);
                for (var $_i = 0; $_i < $_len; ++$_i) {
                  args[$_i] = arguments[$_i]
                }
                if (fn)
                  args.pop();
                var ret = new PromiseArray(args).promise();
                return fn !== undefined ? ret.spread(fn) : ret
              }
            }
          },
          { './util.js': 38 }
        ],
        19: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
              var getDomain = Promise._getDomain;
              var async = _dereq_('./async.js');
              var util = _dereq_('./util.js');
              var tryCatch = util.tryCatch;
              var errorObj = util.errorObj;
              var PENDING = {};
              var EMPTY_ARRAY = [];
              function MappingPromiseArray(promises, fn, limit, _filter) {
                this.constructor$(promises);
                this._promise._captureStackTrace();
                var domain = getDomain();
                this._callback = domain === null ? fn : domain.bind(fn);
                this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
                this._limit = limit;
                this._inFlight = 0;
                this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
                async.invoke(init, this, undefined)
              }
              util.inherits(MappingPromiseArray, PromiseArray);
              function init() {
                this._init$(undefined, -2)
              }
              MappingPromiseArray.prototype._init = function () {
              };
              MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
                var values = this._values;
                var length = this.length();
                var preservedValues = this._preservedValues;
                var limit = this._limit;
                if (values[index] === PENDING) {
                  values[index] = value;
                  if (limit >= 1) {
                    this._inFlight--;
                    this._drainQueue();
                    if (this._isResolved())
                      return
                  }
                } else {
                  if (limit >= 1 && this._inFlight >= limit) {
                    values[index] = value;
                    this._queue.push(index);
                    return
                  }
                  if (preservedValues !== null)
                    preservedValues[index] = value;
                  var callback = this._callback;
                  var receiver = this._promise._boundValue();
                  this._promise._pushContext();
                  var ret = tryCatch(callback).call(receiver, value, index, length);
                  this._promise._popContext();
                  if (ret === errorObj)
                    return this._reject(ret.e);
                  var maybePromise = tryConvertToPromise(ret, this._promise);
                  if (maybePromise instanceof Promise) {
                    maybePromise = maybePromise._target();
                    if (maybePromise._isPending()) {
                      if (limit >= 1)
                        this._inFlight++;
                      values[index] = PENDING;
                      return maybePromise._proxyPromiseArray(this, index)
                    } else if (maybePromise._isFulfilled()) {
                      ret = maybePromise._value()
                    } else {
                      return this._reject(maybePromise._reason())
                    }
                  }
                  values[index] = ret
                }
                var totalResolved = ++this._totalResolved;
                if (totalResolved >= length) {
                  if (preservedValues !== null) {
                    this._filter(values, preservedValues)
                  } else {
                    this._resolve(values)
                  }
                }
              };
              MappingPromiseArray.prototype._drainQueue = function () {
                var queue = this._queue;
                var limit = this._limit;
                var values = this._values;
                while (queue.length > 0 && this._inFlight < limit) {
                  if (this._isResolved())
                    return;
                  var index = queue.pop();
                  this._promiseFulfilled(values[index], index)
                }
              };
              MappingPromiseArray.prototype._filter = function (booleans, values) {
                var len = values.length;
                var ret = new Array(len);
                var j = 0;
                for (var i = 0; i < len; ++i) {
                  if (booleans[i])
                    ret[j++] = values[i]
                }
                ret.length = j;
                this._resolve(ret)
              };
              MappingPromiseArray.prototype.preservedValues = function () {
                return this._preservedValues
              };
              function map(promises, fn, options, _filter) {
                var limit = typeof options === 'object' && options !== null ? options.concurrency : 0;
                limit = typeof limit === 'number' && isFinite(limit) && limit >= 1 ? limit : 0;
                return new MappingPromiseArray(promises, fn, limit, _filter)
              }
              Promise.prototype.map = function (fn, options) {
                if (typeof fn !== 'function')
                  return apiRejection('fn must be a function\n\n    See http://goo.gl/916lJJ\n');
                return map(this, fn, options, null).promise()
              };
              Promise.map = function (promises, fn, options, _filter) {
                if (typeof fn !== 'function')
                  return apiRejection('fn must be a function\n\n    See http://goo.gl/916lJJ\n');
                return map(promises, fn, options, _filter).promise()
              }
            }
          },
          {
            './async.js': 2,
            './util.js': 38
          }
        ],
        20: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
              var util = _dereq_('./util.js');
              var tryCatch = util.tryCatch;
              Promise.method = function (fn) {
                if (typeof fn !== 'function') {
                  throw new Promise.TypeError('fn must be a function\n\n    See http://goo.gl/916lJJ\n')
                }
                return function () {
                  var ret = new Promise(INTERNAL);
                  ret._captureStackTrace();
                  ret._pushContext();
                  var value = tryCatch(fn).apply(this, arguments);
                  ret._popContext();
                  ret._resolveFromSyncValue(value);
                  return ret
                }
              };
              Promise.attempt = Promise['try'] = function (fn, args, ctx) {
                if (typeof fn !== 'function') {
                  return apiRejection('fn must be a function\n\n    See http://goo.gl/916lJJ\n')
                }
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                ret._pushContext();
                var value = util.isArray(args) ? tryCatch(fn).apply(ctx, args) : tryCatch(fn).call(ctx, args);
                ret._popContext();
                ret._resolveFromSyncValue(value);
                return ret
              };
              Promise.prototype._resolveFromSyncValue = function (value) {
                if (value === util.errorObj) {
                  this._rejectCallback(value.e, false, true)
                } else {
                  this._resolveCallback(value, true)
                }
              }
            }
          },
          { './util.js': 38 }
        ],
        21: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise) {
              var util = _dereq_('./util.js');
              var async = _dereq_('./async.js');
              var tryCatch = util.tryCatch;
              var errorObj = util.errorObj;
              function spreadAdapter(val, nodeback) {
                var promise = this;
                if (!util.isArray(val))
                  return successAdapter.call(promise, val, nodeback);
                var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
                if (ret === errorObj) {
                  async.throwLater(ret.e)
                }
              }
              function successAdapter(val, nodeback) {
                var promise = this;
                var receiver = promise._boundValue();
                var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
                if (ret === errorObj) {
                  async.throwLater(ret.e)
                }
              }
              function errorAdapter(reason, nodeback) {
                var promise = this;
                if (!reason) {
                  var target = promise._target();
                  var newReason = target._getCarriedStackTrace();
                  newReason.cause = reason;
                  reason = newReason
                }
                var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
                if (ret === errorObj) {
                  async.throwLater(ret.e)
                }
              }
              Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {
                if (typeof nodeback == 'function') {
                  var adapter = successAdapter;
                  if (options !== undefined && Object(options).spread) {
                    adapter = spreadAdapter
                  }
                  this._then(adapter, errorAdapter, undefined, this, nodeback)
                }
                return this
              }
            }
          },
          {
            './async.js': 2,
            './util.js': 38
          }
        ],
        22: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray) {
              var util = _dereq_('./util.js');
              var async = _dereq_('./async.js');
              var tryCatch = util.tryCatch;
              var errorObj = util.errorObj;
              Promise.prototype.progressed = function (handler) {
                return this._then(undefined, undefined, handler, undefined, undefined)
              };
              Promise.prototype._progress = function (progressValue) {
                if (this._isFollowingOrFulfilledOrRejected())
                  return;
                this._target()._progressUnchecked(progressValue)
              };
              Promise.prototype._progressHandlerAt = function (index) {
                return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2]
              };
              Promise.prototype._doProgressWith = function (progression) {
                var progressValue = progression.value;
                var handler = progression.handler;
                var promise = progression.promise;
                var receiver = progression.receiver;
                var ret = tryCatch(handler).call(receiver, progressValue);
                if (ret === errorObj) {
                  if (ret.e != null && ret.e.name !== 'StopProgressPropagation') {
                    var trace = util.canAttachTrace(ret.e) ? ret.e : new Error(util.toString(ret.e));
                    promise._attachExtraTrace(trace);
                    promise._progress(ret.e)
                  }
                } else if (ret instanceof Promise) {
                  ret._then(promise._progress, null, null, promise, undefined)
                } else {
                  promise._progress(ret)
                }
              };
              Promise.prototype._progressUnchecked = function (progressValue) {
                var len = this._length();
                var progress = this._progress;
                for (var i = 0; i < len; i++) {
                  var handler = this._progressHandlerAt(i);
                  var promise = this._promiseAt(i);
                  if (!(promise instanceof Promise)) {
                    var receiver = this._receiverAt(i);
                    if (typeof handler === 'function') {
                      handler.call(receiver, progressValue, promise)
                    } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {
                      receiver._promiseProgressed(progressValue, promise)
                    }
                    continue
                  }
                  if (typeof handler === 'function') {
                    async.invoke(this._doProgressWith, this, {
                      handler: handler,
                      promise: promise,
                      receiver: this._receiverAt(i),
                      value: progressValue
                    })
                  } else {
                    async.invoke(progress, promise, progressValue)
                  }
                }
              }
            }
          },
          {
            './async.js': 2,
            './util.js': 38
          }
        ],
        23: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function () {
              var makeSelfResolutionError = function () {
                return new TypeError('circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n')
              };
              var reflect = function () {
                return new Promise.PromiseInspection(this._target())
              };
              var apiRejection = function (msg) {
                return Promise.reject(new TypeError(msg))
              };
              var util = _dereq_('./util.js');
              var getDomain;
              if (util.isNode) {
                getDomain = function () {
                  var ret = process.domain;
                  if (ret === undefined)
                    ret = null;
                  return ret
                }
              } else {
                getDomain = function () {
                  return null
                }
              }
              util.notEnumerableProp(Promise, '_getDomain', getDomain);
              var async = _dereq_('./async.js');
              var errors = _dereq_('./errors.js');
              var TypeError = Promise.TypeError = errors.TypeError;
              Promise.RangeError = errors.RangeError;
              Promise.CancellationError = errors.CancellationError;
              Promise.TimeoutError = errors.TimeoutError;
              Promise.OperationalError = errors.OperationalError;
              Promise.RejectionError = errors.OperationalError;
              Promise.AggregateError = errors.AggregateError;
              var INTERNAL = function () {
              };
              var APPLY = {};
              var NEXT_FILTER = { e: null };
              var tryConvertToPromise = _dereq_('./thenables.js')(Promise, INTERNAL);
              var PromiseArray = _dereq_('./promise_array.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
              var CapturedTrace = _dereq_('./captured_trace.js')();
              var isDebugging = _dereq_('./debuggability.js')(Promise, CapturedTrace);
              /*jshint unused:false*/
              var createContext = _dereq_('./context.js')(Promise, CapturedTrace, isDebugging);
              var CatchFilter = _dereq_('./catch_filter.js')(NEXT_FILTER);
              var PromiseResolver = _dereq_('./promise_resolver.js');
              var nodebackForPromise = PromiseResolver._nodebackForPromise;
              var errorObj = util.errorObj;
              var tryCatch = util.tryCatch;
              function Promise(resolver) {
                if (typeof resolver !== 'function') {
                  throw new TypeError('the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n')
                }
                if (this.constructor !== Promise) {
                  throw new TypeError('the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n')
                }
                this._bitField = 0;
                this._fulfillmentHandler0 = undefined;
                this._rejectionHandler0 = undefined;
                this._progressHandler0 = undefined;
                this._promise0 = undefined;
                this._receiver0 = undefined;
                this._settledValue = undefined;
                if (resolver !== INTERNAL)
                  this._resolveFromResolver(resolver)
              }
              Promise.prototype.toString = function () {
                return '[object Promise]'
              };
              Promise.prototype.caught = Promise.prototype['catch'] = function (fn) {
                var len = arguments.length;
                if (len > 1) {
                  var catchInstances = new Array(len - 1), j = 0, i;
                  for (i = 0; i < len - 1; ++i) {
                    var item = arguments[i];
                    if (typeof item === 'function') {
                      catchInstances[j++] = item
                    } else {
                      return Promise.reject(new TypeError('Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n'))
                    }
                  }
                  catchInstances.length = j;
                  fn = arguments[i];
                  var catchFilter = new CatchFilter(catchInstances, fn, this);
                  return this._then(undefined, catchFilter.doFilter, undefined, catchFilter, undefined)
                }
                return this._then(undefined, fn, undefined, undefined, undefined)
              };
              Promise.prototype.reflect = function () {
                return this._then(reflect, reflect, undefined, this, undefined)
              };
              Promise.prototype.then = function (didFulfill, didReject, didProgress) {
                if (isDebugging() && arguments.length > 0 && typeof didFulfill !== 'function' && typeof didReject !== 'function') {
                  var msg = '.then() only accepts functions but was passed: ' + util.classString(didFulfill);
                  if (arguments.length > 1) {
                    msg += ', ' + util.classString(didReject)
                  }
                  this._warn(msg)
                }
                return this._then(didFulfill, didReject, didProgress, undefined, undefined)
              };
              Promise.prototype.done = function (didFulfill, didReject, didProgress) {
                var promise = this._then(didFulfill, didReject, didProgress, undefined, undefined);
                promise._setIsFinal()
              };
              Promise.prototype.spread = function (didFulfill, didReject) {
                return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined)
              };
              Promise.prototype.isCancellable = function () {
                return !this.isResolved() && this._cancellable()
              };
              Promise.prototype.toJSON = function () {
                var ret = {
                  isFulfilled: false,
                  isRejected: false,
                  fulfillmentValue: undefined,
                  rejectionReason: undefined
                };
                if (this.isFulfilled()) {
                  ret.fulfillmentValue = this.value();
                  ret.isFulfilled = true
                } else if (this.isRejected()) {
                  ret.rejectionReason = this.reason();
                  ret.isRejected = true
                }
                return ret
              };
              Promise.prototype.all = function () {
                return new PromiseArray(this).promise()
              };
              Promise.prototype.error = function (fn) {
                return this.caught(util.originatesFromRejection, fn)
              };
              Promise.is = function (val) {
                return val instanceof Promise
              };
              Promise.fromNode = function (fn) {
                var ret = new Promise(INTERNAL);
                var result = tryCatch(fn)(nodebackForPromise(ret));
                if (result === errorObj) {
                  ret._rejectCallback(result.e, true, true)
                }
                return ret
              };
              Promise.all = function (promises) {
                return new PromiseArray(promises).promise()
              };
              Promise.defer = Promise.pending = function () {
                var promise = new Promise(INTERNAL);
                return new PromiseResolver(promise)
              };
              Promise.cast = function (obj) {
                var ret = tryConvertToPromise(obj);
                if (!(ret instanceof Promise)) {
                  var val = ret;
                  ret = new Promise(INTERNAL);
                  ret._fulfillUnchecked(val)
                }
                return ret
              };
              Promise.resolve = Promise.fulfilled = Promise.cast;
              Promise.reject = Promise.rejected = function (reason) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                ret._rejectCallback(reason, true);
                return ret
              };
              Promise.setScheduler = function (fn) {
                if (typeof fn !== 'function')
                  throw new TypeError('fn must be a function\n\n    See http://goo.gl/916lJJ\n');
                var prev = async._schedule;
                async._schedule = fn;
                return prev
              };
              Promise.prototype._then = function (didFulfill, didReject, didProgress, receiver, internalData) {
                var haveInternalData = internalData !== undefined;
                var ret = haveInternalData ? internalData : new Promise(INTERNAL);
                if (!haveInternalData) {
                  ret._propagateFrom(this, 4 | 1);
                  ret._captureStackTrace()
                }
                var target = this._target();
                if (target !== this) {
                  if (receiver === undefined)
                    receiver = this._boundTo;
                  if (!haveInternalData)
                    ret._setIsMigrated()
                }
                var callbackIndex = target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver, getDomain());
                if (target._isResolved() && !target._isSettlePromisesQueued()) {
                  async.invoke(target._settlePromiseAtPostResolution, target, callbackIndex)
                }
                return ret
              };
              Promise.prototype._settlePromiseAtPostResolution = function (index) {
                if (this._isRejectionUnhandled())
                  this._unsetRejectionIsUnhandled();
                this._settlePromiseAt(index)
              };
              Promise.prototype._length = function () {
                return this._bitField & 131071
              };
              Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
                return (this._bitField & 939524096) > 0
              };
              Promise.prototype._isFollowing = function () {
                return (this._bitField & 536870912) === 536870912
              };
              Promise.prototype._setLength = function (len) {
                this._bitField = this._bitField & -131072 | len & 131071
              };
              Promise.prototype._setFulfilled = function () {
                this._bitField = this._bitField | 268435456
              };
              Promise.prototype._setRejected = function () {
                this._bitField = this._bitField | 134217728
              };
              Promise.prototype._setFollowing = function () {
                this._bitField = this._bitField | 536870912
              };
              Promise.prototype._setIsFinal = function () {
                this._bitField = this._bitField | 33554432
              };
              Promise.prototype._isFinal = function () {
                return (this._bitField & 33554432) > 0
              };
              Promise.prototype._cancellable = function () {
                return (this._bitField & 67108864) > 0
              };
              Promise.prototype._setCancellable = function () {
                this._bitField = this._bitField | 67108864
              };
              Promise.prototype._unsetCancellable = function () {
                this._bitField = this._bitField & ~67108864
              };
              Promise.prototype._setIsMigrated = function () {
                this._bitField = this._bitField | 4194304
              };
              Promise.prototype._unsetIsMigrated = function () {
                this._bitField = this._bitField & ~4194304
              };
              Promise.prototype._isMigrated = function () {
                return (this._bitField & 4194304) > 0
              };
              Promise.prototype._receiverAt = function (index) {
                var ret = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];
                if (ret === undefined && this._isBound()) {
                  return this._boundValue()
                }
                return ret
              };
              Promise.prototype._promiseAt = function (index) {
                return index === 0 ? this._promise0 : this[index * 5 - 5 + 3]
              };
              Promise.prototype._fulfillmentHandlerAt = function (index) {
                return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0]
              };
              Promise.prototype._rejectionHandlerAt = function (index) {
                return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1]
              };
              Promise.prototype._boundValue = function () {
                var ret = this._boundTo;
                if (ret !== undefined) {
                  if (ret instanceof Promise) {
                    if (ret.isFulfilled()) {
                      return ret.value()
                    } else {
                      return undefined
                    }
                  }
                }
                return ret
              };
              Promise.prototype._migrateCallbacks = function (follower, index) {
                var fulfill = follower._fulfillmentHandlerAt(index);
                var reject = follower._rejectionHandlerAt(index);
                var progress = follower._progressHandlerAt(index);
                var promise = follower._promiseAt(index);
                var receiver = follower._receiverAt(index);
                if (promise instanceof Promise)
                  promise._setIsMigrated();
                this._addCallbacks(fulfill, reject, progress, promise, receiver, null)
              };
              Promise.prototype._addCallbacks = function (fulfill, reject, progress, promise, receiver, domain) {
                var index = this._length();
                if (index >= 131071 - 5) {
                  index = 0;
                  this._setLength(0)
                }
                if (index === 0) {
                  this._promise0 = promise;
                  if (receiver !== undefined)
                    this._receiver0 = receiver;
                  if (typeof fulfill === 'function' && !this._isCarryingStackTrace()) {
                    this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill)
                  }
                  if (typeof reject === 'function') {
                    this._rejectionHandler0 = domain === null ? reject : domain.bind(reject)
                  }
                  if (typeof progress === 'function') {
                    this._progressHandler0 = domain === null ? progress : domain.bind(progress)
                  }
                } else {
                  var base = index * 5 - 5;
                  this[base + 3] = promise;
                  this[base + 4] = receiver;
                  if (typeof fulfill === 'function') {
                    this[base + 0] = domain === null ? fulfill : domain.bind(fulfill)
                  }
                  if (typeof reject === 'function') {
                    this[base + 1] = domain === null ? reject : domain.bind(reject)
                  }
                  if (typeof progress === 'function') {
                    this[base + 2] = domain === null ? progress : domain.bind(progress)
                  }
                }
                this._setLength(index + 1);
                return index
              };
              Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
                var index = this._length();
                if (index >= 131071 - 5) {
                  index = 0;
                  this._setLength(0)
                }
                if (index === 0) {
                  this._promise0 = promiseSlotValue;
                  this._receiver0 = receiver
                } else {
                  var base = index * 5 - 5;
                  this[base + 3] = promiseSlotValue;
                  this[base + 4] = receiver
                }
                this._setLength(index + 1)
              };
              Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
                this._setProxyHandlers(promiseArray, index)
              };
              Promise.prototype._resolveCallback = function (value, shouldBind) {
                if (this._isFollowingOrFulfilledOrRejected())
                  return;
                if (value === this)
                  return this._rejectCallback(makeSelfResolutionError(), false, true);
                var maybePromise = tryConvertToPromise(value, this);
                if (!(maybePromise instanceof Promise))
                  return this._fulfill(value);
                var propagationFlags = 1 | (shouldBind ? 4 : 0);
                this._propagateFrom(maybePromise, propagationFlags);
                var promise = maybePromise._target();
                if (promise._isPending()) {
                  var len = this._length();
                  for (var i = 0; i < len; ++i) {
                    promise._migrateCallbacks(this, i)
                  }
                  this._setFollowing();
                  this._setLength(0);
                  this._setFollowee(promise)
                } else if (promise._isFulfilled()) {
                  this._fulfillUnchecked(promise._value())
                } else {
                  this._rejectUnchecked(promise._reason(), promise._getCarriedStackTrace())
                }
              };
              Promise.prototype._rejectCallback = function (reason, synchronous, shouldNotMarkOriginatingFromRejection) {
                if (!shouldNotMarkOriginatingFromRejection) {
                  util.markAsOriginatingFromRejection(reason)
                }
                var trace = util.ensureErrorObject(reason);
                var hasStack = trace === reason;
                this._attachExtraTrace(trace, synchronous ? hasStack : false);
                this._reject(reason, hasStack ? undefined : trace)
              };
              Promise.prototype._resolveFromResolver = function (resolver) {
                var promise = this;
                this._captureStackTrace();
                this._pushContext();
                var synchronous = true;
                var r = tryCatch(resolver)(function (value) {
                  if (promise === null)
                    return;
                  promise._resolveCallback(value);
                  promise = null
                }, function (reason) {
                  if (promise === null)
                    return;
                  promise._rejectCallback(reason, synchronous);
                  promise = null
                });
                synchronous = false;
                this._popContext();
                if (r !== undefined && r === errorObj && promise !== null) {
                  promise._rejectCallback(r.e, true, true);
                  promise = null
                }
              };
              Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {
                if (promise._isRejected())
                  return;
                promise._pushContext();
                var x;
                if (receiver === APPLY && !this._isRejected()) {
                  x = tryCatch(handler).apply(this._boundValue(), value)
                } else {
                  x = tryCatch(handler).call(receiver, value)
                }
                promise._popContext();
                if (x === errorObj || x === promise || x === NEXT_FILTER) {
                  var err = x === promise ? makeSelfResolutionError() : x.e;
                  promise._rejectCallback(err, false, true)
                } else {
                  promise._resolveCallback(x)
                }
              };
              Promise.prototype._target = function () {
                var ret = this;
                while (ret._isFollowing())
                  ret = ret._followee();
                return ret
              };
              Promise.prototype._followee = function () {
                return this._rejectionHandler0
              };
              Promise.prototype._setFollowee = function (promise) {
                this._rejectionHandler0 = promise
              };
              Promise.prototype._cleanValues = function () {
                if (this._cancellable()) {
                  this._cancellationParent = undefined
                }
              };
              Promise.prototype._propagateFrom = function (parent, flags) {
                if ((flags & 1) > 0 && parent._cancellable()) {
                  this._setCancellable();
                  this._cancellationParent = parent
                }
                if ((flags & 4) > 0 && parent._isBound()) {
                  this._setBoundTo(parent._boundTo)
                }
              };
              Promise.prototype._fulfill = function (value) {
                if (this._isFollowingOrFulfilledOrRejected())
                  return;
                this._fulfillUnchecked(value)
              };
              Promise.prototype._reject = function (reason, carriedStackTrace) {
                if (this._isFollowingOrFulfilledOrRejected())
                  return;
                this._rejectUnchecked(reason, carriedStackTrace)
              };
              Promise.prototype._settlePromiseAt = function (index) {
                var promise = this._promiseAt(index);
                var isPromise = promise instanceof Promise;
                if (isPromise && promise._isMigrated()) {
                  promise._unsetIsMigrated();
                  return async.invoke(this._settlePromiseAt, this, index)
                }
                var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
                var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
                var value = this._settledValue;
                var receiver = this._receiverAt(index);
                this._clearCallbackDataAtIndex(index);
                if (typeof handler === 'function') {
                  if (!isPromise) {
                    handler.call(receiver, value, promise)
                  } else {
                    this._settlePromiseFromHandler(handler, receiver, value, promise)
                  }
                } else if (receiver instanceof PromiseArray) {
                  if (!receiver._isResolved()) {
                    if (this._isFulfilled()) {
                      receiver._promiseFulfilled(value, promise)
                    } else {
                      receiver._promiseRejected(value, promise)
                    }
                  }
                } else if (isPromise) {
                  if (this._isFulfilled()) {
                    promise._fulfill(value)
                  } else {
                    promise._reject(value, carriedStackTrace)
                  }
                }
                if (index >= 4 && (index & 31) === 4)
                  async.invokeLater(this._setLength, this, 0)
              };
              Promise.prototype._clearCallbackDataAtIndex = function (index) {
                if (index === 0) {
                  if (!this._isCarryingStackTrace()) {
                    this._fulfillmentHandler0 = undefined
                  }
                  this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = undefined
                } else {
                  var base = index * 5 - 5;
                  this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = undefined
                }
              };
              Promise.prototype._isSettlePromisesQueued = function () {
                return (this._bitField & -1073741824) === -1073741824
              };
              Promise.prototype._setSettlePromisesQueued = function () {
                this._bitField = this._bitField | -1073741824
              };
              Promise.prototype._unsetSettlePromisesQueued = function () {
                this._bitField = this._bitField & ~-1073741824
              };
              Promise.prototype._queueSettlePromises = function () {
                async.settlePromises(this);
                this._setSettlePromisesQueued()
              };
              Promise.prototype._fulfillUnchecked = function (value) {
                if (value === this) {
                  var err = makeSelfResolutionError();
                  this._attachExtraTrace(err);
                  return this._rejectUnchecked(err, undefined)
                }
                this._setFulfilled();
                this._settledValue = value;
                this._cleanValues();
                if (this._length() > 0) {
                  this._queueSettlePromises()
                }
              };
              Promise.prototype._rejectUncheckedCheckError = function (reason) {
                var trace = util.ensureErrorObject(reason);
                this._rejectUnchecked(reason, trace === reason ? undefined : trace)
              };
              Promise.prototype._rejectUnchecked = function (reason, trace) {
                if (reason === this) {
                  var err = makeSelfResolutionError();
                  this._attachExtraTrace(err);
                  return this._rejectUnchecked(err)
                }
                this._setRejected();
                this._settledValue = reason;
                this._cleanValues();
                if (this._isFinal()) {
                  async.throwLater(function (e) {
                    if ('stack' in e) {
                      async.invokeFirst(CapturedTrace.unhandledRejection, undefined, e)
                    }
                    throw e
                  }, trace === undefined ? reason : trace);
                  return
                }
                if (trace !== undefined && trace !== reason) {
                  this._setCarriedStackTrace(trace)
                }
                if (this._length() > 0) {
                  this._queueSettlePromises()
                } else {
                  this._ensurePossibleRejectionHandled()
                }
              };
              Promise.prototype._settlePromises = function () {
                this._unsetSettlePromisesQueued();
                var len = this._length();
                for (var i = 0; i < len; i++) {
                  this._settlePromiseAt(i)
                }
              };
              util.notEnumerableProp(Promise, '_makeSelfResolutionError', makeSelfResolutionError);
              _dereq_('./progress.js')(Promise, PromiseArray);
              _dereq_('./method.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
              _dereq_('./bind.js')(Promise, INTERNAL, tryConvertToPromise);
              _dereq_('./finally.js')(Promise, NEXT_FILTER, tryConvertToPromise);
              _dereq_('./direct_resolve.js')(Promise);
              _dereq_('./synchronous_inspection.js')(Promise);
              _dereq_('./join.js')(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
              Promise.Promise = Promise;
              _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
              _dereq_('./cancel.js')(Promise);
              _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
              _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
              _dereq_('./nodeify.js')(Promise);
              _dereq_('./call_get.js')(Promise);
              _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
              _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
              _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
              _dereq_('./settle.js')(Promise, PromiseArray);
              _dereq_('./some.js')(Promise, PromiseArray, apiRejection);
              _dereq_('./promisify.js')(Promise, INTERNAL);
              _dereq_('./any.js')(Promise);
              _dereq_('./each.js')(Promise, INTERNAL);
              _dereq_('./timers.js')(Promise, INTERNAL);
              _dereq_('./filter.js')(Promise, INTERNAL);
              util.toFastProperties(Promise);
              util.toFastProperties(Promise.prototype);
              function fillTypes(value) {
                var p = new Promise(INTERNAL);
                p._fulfillmentHandler0 = value;
                p._rejectionHandler0 = value;
                p._progressHandler0 = value;
                p._promise0 = value;
                p._receiver0 = value;
                p._settledValue = value
              }
              // Complete slack tracking, opt out of field-type tracking and           
              // stabilize map                                                         
              fillTypes({ a: 1 });
              fillTypes({ b: 2 });
              fillTypes({ c: 3 });
              fillTypes(1);
              fillTypes(function () {
              });
              fillTypes(undefined);
              fillTypes(false);
              fillTypes(new Promise(INTERNAL));
              CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
              return Promise
            }
          },
          {
            './any.js': 1,
            './async.js': 2,
            './bind.js': 3,
            './call_get.js': 5,
            './cancel.js': 6,
            './captured_trace.js': 7,
            './catch_filter.js': 8,
            './context.js': 9,
            './debuggability.js': 10,
            './direct_resolve.js': 11,
            './each.js': 12,
            './errors.js': 13,
            './filter.js': 15,
            './finally.js': 16,
            './generators.js': 17,
            './join.js': 18,
            './map.js': 19,
            './method.js': 20,
            './nodeify.js': 21,
            './progress.js': 22,
            './promise_array.js': 24,
            './promise_resolver.js': 25,
            './promisify.js': 26,
            './props.js': 27,
            './race.js': 29,
            './reduce.js': 30,
            './settle.js': 32,
            './some.js': 33,
            './synchronous_inspection.js': 34,
            './thenables.js': 35,
            './timers.js': 36,
            './using.js': 37,
            './util.js': 38
          }
        ],
        24: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
              var util = _dereq_('./util.js');
              var isArray = util.isArray;
              function toResolutionValue(val) {
                switch (val) {
                case -2:
                  return [];
                case -3:
                  return {}
                }
              }
              function PromiseArray(values) {
                var promise = this._promise = new Promise(INTERNAL);
                var parent;
                if (values instanceof Promise) {
                  parent = values;
                  promise._propagateFrom(parent, 1 | 4)
                }
                this._values = values;
                this._length = 0;
                this._totalResolved = 0;
                this._init(undefined, -2)
              }
              PromiseArray.prototype.length = function () {
                return this._length
              };
              PromiseArray.prototype.promise = function () {
                return this._promise
              };
              PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
                var values = tryConvertToPromise(this._values, this._promise);
                if (values instanceof Promise) {
                  values = values._target();
                  this._values = values;
                  if (values._isFulfilled()) {
                    values = values._value();
                    if (!isArray(values)) {
                      var err = new Promise.TypeError('expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n');
                      this.__hardReject__(err);
                      return
                    }
                  } else if (values._isPending()) {
                    values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
                    return
                  } else {
                    this._reject(values._reason());
                    return
                  }
                } else if (!isArray(values)) {
                  this._promise._reject(apiRejection('expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n')._reason());
                  return
                }
                if (values.length === 0) {
                  if (resolveValueIfEmpty === -5) {
                    this._resolveEmptyArray()
                  } else {
                    this._resolve(toResolutionValue(resolveValueIfEmpty))
                  }
                  return
                }
                var len = this.getActualLength(values.length);
                this._length = len;
                this._values = this.shouldCopyValues() ? new Array(len) : this._values;
                var promise = this._promise;
                for (var i = 0; i < len; ++i) {
                  var isResolved = this._isResolved();
                  var maybePromise = tryConvertToPromise(values[i], promise);
                  if (maybePromise instanceof Promise) {
                    maybePromise = maybePromise._target();
                    if (isResolved) {
                      maybePromise._ignoreRejections()
                    } else if (maybePromise._isPending()) {
                      maybePromise._proxyPromiseArray(this, i)
                    } else if (maybePromise._isFulfilled()) {
                      this._promiseFulfilled(maybePromise._value(), i)
                    } else {
                      this._promiseRejected(maybePromise._reason(), i)
                    }
                  } else if (!isResolved) {
                    this._promiseFulfilled(maybePromise, i)
                  }
                }
              };
              PromiseArray.prototype._isResolved = function () {
                return this._values === null
              };
              PromiseArray.prototype._resolve = function (value) {
                this._values = null;
                this._promise._fulfill(value)
              };
              PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function (reason) {
                this._values = null;
                this._promise._rejectCallback(reason, false, true)
              };
              PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
                this._promise._progress({
                  index: index,
                  value: progressValue
                })
              };
              PromiseArray.prototype._promiseFulfilled = function (value, index) {
                this._values[index] = value;
                var totalResolved = ++this._totalResolved;
                if (totalResolved >= this._length) {
                  this._resolve(this._values)
                }
              };
              PromiseArray.prototype._promiseRejected = function (reason, index) {
                this._totalResolved++;
                this._reject(reason)
              };
              PromiseArray.prototype.shouldCopyValues = function () {
                return true
              };
              PromiseArray.prototype.getActualLength = function (len) {
                return len
              };
              return PromiseArray
            }
          },
          { './util.js': 38 }
        ],
        25: [
          function (_dereq_, module, exports) {
            'use strict';
            var util = _dereq_('./util.js');
            var maybeWrapAsError = util.maybeWrapAsError;
            var errors = _dereq_('./errors.js');
            var TimeoutError = errors.TimeoutError;
            var OperationalError = errors.OperationalError;
            var haveGetters = util.haveGetters;
            var es5 = _dereq_('./es5.js');
            function isUntypedError(obj) {
              return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype
            }
            var rErrorKey = /^(?:name|message|stack|cause)$/;
            function wrapAsOperationalError(obj) {
              var ret;
              if (isUntypedError(obj)) {
                ret = new OperationalError(obj);
                ret.name = obj.name;
                ret.message = obj.message;
                ret.stack = obj.stack;
                var keys = es5.keys(obj);
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  if (!rErrorKey.test(key)) {
                    ret[key] = obj[key]
                  }
                }
                return ret
              }
              util.markAsOriginatingFromRejection(obj);
              return obj
            }
            function nodebackForPromise(promise) {
              return function (err, value) {
                if (promise === null)
                  return;
                if (err) {
                  var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                  promise._attachExtraTrace(wrapped);
                  promise._reject(wrapped)
                } else if (arguments.length > 2) {
                  var $_len = arguments.length;
                  var args = new Array($_len - 1);
                  for (var $_i = 1; $_i < $_len; ++$_i) {
                    args[$_i - 1] = arguments[$_i]
                  }
                  promise._fulfill(args)
                } else {
                  promise._fulfill(value)
                }
                promise = null
              }
            }
            var PromiseResolver;
            if (!haveGetters) {
              PromiseResolver = function (promise) {
                this.promise = promise;
                this.asCallback = nodebackForPromise(promise);
                this.callback = this.asCallback
              }
            } else {
              PromiseResolver = function (promise) {
                this.promise = promise
              }
            }
            if (haveGetters) {
              var prop = {
                get: function () {
                  return nodebackForPromise(this.promise)
                }
              };
              es5.defineProperty(PromiseResolver.prototype, 'asCallback', prop);
              es5.defineProperty(PromiseResolver.prototype, 'callback', prop)
            }
            PromiseResolver._nodebackForPromise = nodebackForPromise;
            PromiseResolver.prototype.toString = function () {
              return '[object PromiseResolver]'
            };
            PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function (value) {
              if (!(this instanceof PromiseResolver)) {
                throw new TypeError('Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n')
              }
              this.promise._resolveCallback(value)
            };
            PromiseResolver.prototype.reject = function (reason) {
              if (!(this instanceof PromiseResolver)) {
                throw new TypeError('Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n')
              }
              this.promise._rejectCallback(reason)
            };
            PromiseResolver.prototype.progress = function (value) {
              if (!(this instanceof PromiseResolver)) {
                throw new TypeError('Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n')
              }
              this.promise._progress(value)
            };
            PromiseResolver.prototype.cancel = function (err) {
              this.promise.cancel(err)
            };
            PromiseResolver.prototype.timeout = function () {
              this.reject(new TimeoutError('timeout'))
            };
            PromiseResolver.prototype.isResolved = function () {
              return this.promise.isResolved()
            };
            PromiseResolver.prototype.toJSON = function () {
              return this.promise.toJSON()
            };
            module.exports = PromiseResolver
          },
          {
            './errors.js': 13,
            './es5.js': 14,
            './util.js': 38
          }
        ],
        26: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
              var THIS = {};
              var util = _dereq_('./util.js');
              var nodebackForPromise = _dereq_('./promise_resolver.js')._nodebackForPromise;
              var withAppended = util.withAppended;
              var maybeWrapAsError = util.maybeWrapAsError;
              var canEvaluate = util.canEvaluate;
              var TypeError = _dereq_('./errors').TypeError;
              var defaultSuffix = 'Async';
              var defaultPromisified = { __isPromisified__: true };
              var noCopyProps = [
                'arity',
                'length',
                'name',
                'arguments',
                'caller',
                'callee',
                'prototype',
                '__isPromisified__'
              ];
              var noCopyPropsPattern = new RegExp('^(?:' + noCopyProps.join('|') + ')$');
              var defaultFilter = function (name) {
                return util.isIdentifier(name) && name.charAt(0) !== '_' && name !== 'constructor'
              };
              function propsFilter(key) {
                return !noCopyPropsPattern.test(key)
              }
              function isPromisified(fn) {
                try {
                  return fn.__isPromisified__ === true
                } catch (e) {
                  return false
                }
              }
              function hasPromisified(obj, key, suffix) {
                var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
                return val ? isPromisified(val) : false
              }
              function checkValid(ret, suffix, suffixRegexp) {
                for (var i = 0; i < ret.length; i += 2) {
                  var key = ret[i];
                  if (suffixRegexp.test(key)) {
                    var keyWithoutAsyncSuffix = key.replace(suffixRegexp, '');
                    for (var j = 0; j < ret.length; j += 2) {
                      if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n".replace('%s', suffix))
                      }
                    }
                  }
                }
              }
              function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
                var keys = util.inheritedDataKeys(obj);
                var ret = [];
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  var value = obj[key];
                  var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
                  if (typeof value === 'function' && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                    ret.push(key, value)
                  }
                }
                checkValid(ret, suffix, suffixRegexp);
                return ret
              }
              var escapeIdentRegex = function (str) {
                return str.replace(/([$])/, '\\$')
              };
              var makeNodePromisifiedEval;
              if (!true) {
                var switchCaseArgumentOrder = function (likelyArgumentCount) {
                  var ret = [likelyArgumentCount];
                  var min = Math.max(0, likelyArgumentCount - 1 - 3);
                  for (var i = likelyArgumentCount - 1; i >= min; --i) {
                    ret.push(i)
                  }
                  for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                    ret.push(i)
                  }
                  return ret
                };
                var argumentSequence = function (argumentCount) {
                  return util.filledRange(argumentCount, '_arg', '')
                };
                var parameterDeclaration = function (parameterCount) {
                  return util.filledRange(Math.max(parameterCount, 3), '_arg', '')
                };
                var parameterCount = function (fn) {
                  if (typeof fn.length === 'number') {
                    return Math.max(Math.min(fn.length, 1023 + 1), 0)
                  }
                  return 0
                };
                makeNodePromisifiedEval = function (callback, receiver, originalName, fn) {
                  var newParameterCount = Math.max(0, parameterCount(fn) - 1);
                  var argumentOrder = switchCaseArgumentOrder(newParameterCount);
                  var shouldProxyThis = typeof callback === 'string' || receiver === THIS;
                  function generateCallForArgumentCount(count) {
                    var args = argumentSequence(count).join(', ');
                    var comma = count > 0 ? ', ' : '';
                    var ret;
                    if (shouldProxyThis) {
                      ret = 'ret = callback.call(this, {{args}}, nodeback); break;\n'
                    } else {
                      ret = receiver === undefined ? 'ret = callback({{args}}, nodeback); break;\n' : 'ret = callback.call(receiver, {{args}}, nodeback); break;\n'
                    }
                    return ret.replace('{{args}}', args).replace(', ', comma)
                  }
                  function generateArgumentSwitchCase() {
                    var ret = '';
                    for (var i = 0; i < argumentOrder.length; ++i) {
                      ret += 'case ' + argumentOrder[i] + ':' + generateCallForArgumentCount(argumentOrder[i])
                    }
                    ret += '                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        '.replace('[CodeForCall]', shouldProxyThis ? 'ret = callback.apply(this, args);\n' : 'ret = callback.apply(receiver, args);\n');
                    return ret
                  }
                  var getFunctionCode = typeof callback === 'string' ? "this != null ? this['" + callback + "'] : fn" : 'fn';
                  return new Function('Promise', 'fn', 'receiver', 'withAppended', 'maybeWrapAsError', 'nodebackForPromise', 'tryCatch', 'errorObj', 'notEnumerableProp', 'INTERNAL', "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ".replace('Parameters', parameterDeclaration(newParameterCount)).replace('[CodeForSwitchCase]', generateArgumentSwitchCase()).replace('[GetFunctionCode]', getFunctionCode))(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL)
                }
              }
              function makeNodePromisifiedClosure(callback, receiver, _, fn) {
                var defaultThis = function () {
                  return this
                }();
                var method = callback;
                if (typeof method === 'string') {
                  callback = fn
                }
                function promisified() {
                  var _receiver = receiver;
                  if (receiver === THIS)
                    _receiver = this;
                  var promise = new Promise(INTERNAL);
                  promise._captureStackTrace();
                  var cb = typeof method === 'string' && this !== defaultThis ? this[method] : callback;
                  var fn = nodebackForPromise(promise);
                  try {
                    cb.apply(_receiver, withAppended(arguments, fn))
                  } catch (e) {
                    promise._rejectCallback(maybeWrapAsError(e), true, true)
                  }
                  return promise
                }
                util.notEnumerableProp(promisified, '__isPromisified__', true);
                return promisified
              }
              var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
              function promisifyAll(obj, suffix, filter, promisifier) {
                var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + '$');
                var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
                for (var i = 0, len = methods.length; i < len; i += 2) {
                  var key = methods[i];
                  var fn = methods[i + 1];
                  var promisifiedKey = key + suffix;
                  obj[promisifiedKey] = promisifier === makeNodePromisified ? makeNodePromisified(key, THIS, key, fn, suffix) : promisifier(fn, function () {
                    return makeNodePromisified(key, THIS, key, fn, suffix)
                  })
                }
                util.toFastProperties(obj);
                return obj
              }
              function promisify(callback, receiver) {
                return makeNodePromisified(callback, receiver, undefined, callback)
              }
              Promise.promisify = function (fn, receiver) {
                if (typeof fn !== 'function') {
                  throw new TypeError('fn must be a function\n\n    See http://goo.gl/916lJJ\n')
                }
                if (isPromisified(fn)) {
                  return fn
                }
                var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
                util.copyDescriptors(fn, ret, propsFilter);
                return ret
              };
              Promise.promisifyAll = function (target, options) {
                if (typeof target !== 'function' && typeof target !== 'object') {
                  throw new TypeError('the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n')
                }
                options = Object(options);
                var suffix = options.suffix;
                if (typeof suffix !== 'string')
                  suffix = defaultSuffix;
                var filter = options.filter;
                if (typeof filter !== 'function')
                  filter = defaultFilter;
                var promisifier = options.promisifier;
                if (typeof promisifier !== 'function')
                  promisifier = makeNodePromisified;
                if (!util.isIdentifier(suffix)) {
                  throw new RangeError('suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n')
                }
                var keys = util.inheritedDataKeys(target);
                for (var i = 0; i < keys.length; ++i) {
                  var value = target[keys[i]];
                  if (keys[i] !== 'constructor' && util.isClass(value)) {
                    promisifyAll(value.prototype, suffix, filter, promisifier);
                    promisifyAll(value, suffix, filter, promisifier)
                  }
                }
                return promisifyAll(target, suffix, filter, promisifier)
              }
            }
          },
          {
            './errors': 13,
            './promise_resolver.js': 25,
            './util.js': 38
          }
        ],
        27: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {
              var util = _dereq_('./util.js');
              var isObject = util.isObject;
              var es5 = _dereq_('./es5.js');
              function PropertiesPromiseArray(obj) {
                var keys = es5.keys(obj);
                var len = keys.length;
                var values = new Array(len * 2);
                for (var i = 0; i < len; ++i) {
                  var key = keys[i];
                  values[i] = obj[key];
                  values[i + len] = key
                }
                this.constructor$(values)
              }
              util.inherits(PropertiesPromiseArray, PromiseArray);
              PropertiesPromiseArray.prototype._init = function () {
                this._init$(undefined, -3)
              };
              PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
                this._values[index] = value;
                var totalResolved = ++this._totalResolved;
                if (totalResolved >= this._length) {
                  var val = {};
                  var keyOffset = this.length();
                  for (var i = 0, len = this.length(); i < len; ++i) {
                    val[this._values[i + keyOffset]] = this._values[i]
                  }
                  this._resolve(val)
                }
              };
              PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
                this._promise._progress({
                  key: this._values[index + this.length()],
                  value: value
                })
              };
              PropertiesPromiseArray.prototype.shouldCopyValues = function () {
                return false
              };
              PropertiesPromiseArray.prototype.getActualLength = function (len) {
                return len >> 1
              };
              function props(promises) {
                var ret;
                var castValue = tryConvertToPromise(promises);
                if (!isObject(castValue)) {
                  return apiRejection('cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n')
                } else if (castValue instanceof Promise) {
                  ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined)
                } else {
                  ret = new PropertiesPromiseArray(castValue).promise()
                }
                if (castValue instanceof Promise) {
                  ret._propagateFrom(castValue, 4)
                }
                return ret
              }
              Promise.prototype.props = function () {
                return props(this)
              };
              Promise.props = function (promises) {
                return props(promises)
              }
            }
          },
          {
            './es5.js': 14,
            './util.js': 38
          }
        ],
        28: [
          function (_dereq_, module, exports) {
            'use strict';
            function arrayMove(src, srcIndex, dst, dstIndex, len) {
              for (var j = 0; j < len; ++j) {
                dst[j + dstIndex] = src[j + srcIndex];
                src[j + srcIndex] = void 0
              }
            }
            function Queue(capacity) {
              this._capacity = capacity;
              this._length = 0;
              this._front = 0
            }
            Queue.prototype._willBeOverCapacity = function (size) {
              return this._capacity < size
            };
            Queue.prototype._pushOne = function (arg) {
              var length = this.length();
              this._checkCapacity(length + 1);
              var i = this._front + length & this._capacity - 1;
              this[i] = arg;
              this._length = length + 1
            };
            Queue.prototype._unshiftOne = function (value) {
              var capacity = this._capacity;
              this._checkCapacity(this.length() + 1);
              var front = this._front;
              var i = (front - 1 & capacity - 1 ^ capacity) - capacity;
              this[i] = value;
              this._front = i;
              this._length = this.length() + 1
            };
            Queue.prototype.unshift = function (fn, receiver, arg) {
              this._unshiftOne(arg);
              this._unshiftOne(receiver);
              this._unshiftOne(fn)
            };
            Queue.prototype.push = function (fn, receiver, arg) {
              var length = this.length() + 3;
              if (this._willBeOverCapacity(length)) {
                this._pushOne(fn);
                this._pushOne(receiver);
                this._pushOne(arg);
                return
              }
              var j = this._front + length - 3;
              this._checkCapacity(length);
              var wrapMask = this._capacity - 1;
              this[j + 0 & wrapMask] = fn;
              this[j + 1 & wrapMask] = receiver;
              this[j + 2 & wrapMask] = arg;
              this._length = length
            };
            Queue.prototype.shift = function () {
              var front = this._front, ret = this[front];
              this[front] = undefined;
              this._front = front + 1 & this._capacity - 1;
              this._length--;
              return ret
            };
            Queue.prototype.length = function () {
              return this._length
            };
            Queue.prototype._checkCapacity = function (size) {
              if (this._capacity < size) {
                this._resizeTo(this._capacity << 1)
              }
            };
            Queue.prototype._resizeTo = function (capacity) {
              var oldCapacity = this._capacity;
              this._capacity = capacity;
              var front = this._front;
              var length = this._length;
              var moveItemsCount = front + length & oldCapacity - 1;
              arrayMove(this, 0, this, oldCapacity, moveItemsCount)
            };
            module.exports = Queue
          },
          {}
        ],
        29: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
              var isArray = _dereq_('./util.js').isArray;
              var raceLater = function (promise) {
                return promise.then(function (array) {
                  return race(array, promise)
                })
              };
              function race(promises, parent) {
                var maybePromise = tryConvertToPromise(promises);
                if (maybePromise instanceof Promise) {
                  return raceLater(maybePromise)
                } else if (!isArray(promises)) {
                  return apiRejection('expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n')
                }
                var ret = new Promise(INTERNAL);
                if (parent !== undefined) {
                  ret._propagateFrom(parent, 4 | 1)
                }
                var fulfill = ret._fulfill;
                var reject = ret._reject;
                for (var i = 0, len = promises.length; i < len; ++i) {
                  var val = promises[i];
                  if (val === undefined && !(i in promises)) {
                    continue
                  }
                  Promise.cast(val)._then(fulfill, reject, undefined, ret, null)
                }
                return ret
              }
              Promise.race = function (promises) {
                return race(promises, undefined)
              };
              Promise.prototype.race = function () {
                return race(this, undefined)
              }
            }
          },
          { './util.js': 38 }
        ],
        30: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
              var getDomain = Promise._getDomain;
              var async = _dereq_('./async.js');
              var util = _dereq_('./util.js');
              var tryCatch = util.tryCatch;
              var errorObj = util.errorObj;
              function ReductionPromiseArray(promises, fn, accum, _each) {
                this.constructor$(promises);
                this._promise._captureStackTrace();
                this._preservedValues = _each === INTERNAL ? [] : null;
                this._zerothIsAccum = accum === undefined;
                this._gotAccum = false;
                this._reducingIndex = this._zerothIsAccum ? 1 : 0;
                this._valuesPhase = undefined;
                var maybePromise = tryConvertToPromise(accum, this._promise);
                var rejected = false;
                var isPromise = maybePromise instanceof Promise;
                if (isPromise) {
                  maybePromise = maybePromise._target();
                  if (maybePromise._isPending()) {
                    maybePromise._proxyPromiseArray(this, -1)
                  } else if (maybePromise._isFulfilled()) {
                    accum = maybePromise._value();
                    this._gotAccum = true
                  } else {
                    this._reject(maybePromise._reason());
                    rejected = true
                  }
                }
                if (!(isPromise || this._zerothIsAccum))
                  this._gotAccum = true;
                var domain = getDomain();
                this._callback = domain === null ? fn : domain.bind(fn);
                this._accum = accum;
                if (!rejected)
                  async.invoke(init, this, undefined)
              }
              function init() {
                this._init$(undefined, -5)
              }
              util.inherits(ReductionPromiseArray, PromiseArray);
              ReductionPromiseArray.prototype._init = function () {
              };
              ReductionPromiseArray.prototype._resolveEmptyArray = function () {
                if (this._gotAccum || this._zerothIsAccum) {
                  this._resolve(this._preservedValues !== null ? [] : this._accum)
                }
              };
              ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
                var values = this._values;
                values[index] = value;
                var length = this.length();
                var preservedValues = this._preservedValues;
                var isEach = preservedValues !== null;
                var gotAccum = this._gotAccum;
                var valuesPhase = this._valuesPhase;
                var valuesPhaseIndex;
                if (!valuesPhase) {
                  valuesPhase = this._valuesPhase = new Array(length);
                  for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {
                    valuesPhase[valuesPhaseIndex] = 0
                  }
                }
                valuesPhaseIndex = valuesPhase[index];
                if (index === 0 && this._zerothIsAccum) {
                  this._accum = value;
                  this._gotAccum = gotAccum = true;
                  valuesPhase[index] = valuesPhaseIndex === 0 ? 1 : 2
                } else if (index === -1) {
                  this._accum = value;
                  this._gotAccum = gotAccum = true
                } else {
                  if (valuesPhaseIndex === 0) {
                    valuesPhase[index] = 1
                  } else {
                    valuesPhase[index] = 2;
                    this._accum = value
                  }
                }
                if (!gotAccum)
                  return;
                var callback = this._callback;
                var receiver = this._promise._boundValue();
                var ret;
                for (var i = this._reducingIndex; i < length; ++i) {
                  valuesPhaseIndex = valuesPhase[i];
                  if (valuesPhaseIndex === 2) {
                    this._reducingIndex = i + 1;
                    continue
                  }
                  if (valuesPhaseIndex !== 1)
                    return;
                  value = values[i];
                  this._promise._pushContext();
                  if (isEach) {
                    preservedValues.push(value);
                    ret = tryCatch(callback).call(receiver, value, i, length)
                  } else {
                    ret = tryCatch(callback).call(receiver, this._accum, value, i, length)
                  }
                  this._promise._popContext();
                  if (ret === errorObj)
                    return this._reject(ret.e);
                  var maybePromise = tryConvertToPromise(ret, this._promise);
                  if (maybePromise instanceof Promise) {
                    maybePromise = maybePromise._target();
                    if (maybePromise._isPending()) {
                      valuesPhase[i] = 4;
                      return maybePromise._proxyPromiseArray(this, i)
                    } else if (maybePromise._isFulfilled()) {
                      ret = maybePromise._value()
                    } else {
                      return this._reject(maybePromise._reason())
                    }
                  }
                  this._reducingIndex = i + 1;
                  this._accum = ret
                }
                this._resolve(isEach ? preservedValues : this._accum)
              };
              function reduce(promises, fn, initialValue, _each) {
                if (typeof fn !== 'function')
                  return apiRejection('fn must be a function\n\n    See http://goo.gl/916lJJ\n');
                var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
                return array.promise()
              }
              Promise.prototype.reduce = function (fn, initialValue) {
                return reduce(this, fn, initialValue, null)
              };
              Promise.reduce = function (promises, fn, initialValue, _each) {
                return reduce(promises, fn, initialValue, _each)
              }
            }
          },
          {
            './async.js': 2,
            './util.js': 38
          }
        ],
        31: [
          function (_dereq_, module, exports) {
            'use strict';
            var schedule;
            var util = _dereq_('./util');
            var noAsyncScheduler = function () {
              throw new Error('No async scheduler available\n\n    See http://goo.gl/m3OTXk\n')
            };
            if (util.isNode && typeof MutationObserver === 'undefined') {
              var GlobalSetImmediate = global.setImmediate;
              var ProcessNextTick = process.nextTick;
              schedule = util.isRecentNode ? function (fn) {
                GlobalSetImmediate.call(global, fn)
              } : function (fn) {
                ProcessNextTick.call(process, fn)
              }
            } else if (typeof MutationObserver !== 'undefined' && !(typeof window !== 'undefined' && window.navigator && window.navigator.standalone)) {
              schedule = function (fn) {
                var div = document.createElement('div');
                var observer = new MutationObserver(fn);
                observer.observe(div, { attributes: true });
                return function () {
                  div.classList.toggle('foo')
                }
              };
              schedule.isStatic = true
            } else if (typeof setImmediate !== 'undefined') {
              schedule = function (fn) {
                setImmediate(fn)
              }
            } else if (typeof setTimeout !== 'undefined') {
              schedule = function (fn) {
                setTimeout(fn, 0)
              }
            } else {
              schedule = noAsyncScheduler
            }
            module.exports = schedule
          },
          { './util': 38 }
        ],
        32: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray) {
              var PromiseInspection = Promise.PromiseInspection;
              var util = _dereq_('./util.js');
              function SettledPromiseArray(values) {
                this.constructor$(values)
              }
              util.inherits(SettledPromiseArray, PromiseArray);
              SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
                this._values[index] = inspection;
                var totalResolved = ++this._totalResolved;
                if (totalResolved >= this._length) {
                  this._resolve(this._values)
                }
              };
              SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
                var ret = new PromiseInspection;
                ret._bitField = 268435456;
                ret._settledValue = value;
                this._promiseResolved(index, ret)
              };
              SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
                var ret = new PromiseInspection;
                ret._bitField = 134217728;
                ret._settledValue = reason;
                this._promiseResolved(index, ret)
              };
              Promise.settle = function (promises) {
                return new SettledPromiseArray(promises).promise()
              };
              Promise.prototype.settle = function () {
                return new SettledPromiseArray(this).promise()
              }
            }
          },
          { './util.js': 38 }
        ],
        33: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, apiRejection) {
              var util = _dereq_('./util.js');
              var RangeError = _dereq_('./errors.js').RangeError;
              var AggregateError = _dereq_('./errors.js').AggregateError;
              var isArray = util.isArray;
              function SomePromiseArray(values) {
                this.constructor$(values);
                this._howMany = 0;
                this._unwrap = false;
                this._initialized = false
              }
              util.inherits(SomePromiseArray, PromiseArray);
              SomePromiseArray.prototype._init = function () {
                if (!this._initialized) {
                  return
                }
                if (this._howMany === 0) {
                  this._resolve([]);
                  return
                }
                this._init$(undefined, -5);
                var isArrayResolved = isArray(this._values);
                if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
                  this._reject(this._getRangeError(this.length()))
                }
              };
              SomePromiseArray.prototype.init = function () {
                this._initialized = true;
                this._init()
              };
              SomePromiseArray.prototype.setUnwrap = function () {
                this._unwrap = true
              };
              SomePromiseArray.prototype.howMany = function () {
                return this._howMany
              };
              SomePromiseArray.prototype.setHowMany = function (count) {
                this._howMany = count
              };
              SomePromiseArray.prototype._promiseFulfilled = function (value) {
                this._addFulfilled(value);
                if (this._fulfilled() === this.howMany()) {
                  this._values.length = this.howMany();
                  if (this.howMany() === 1 && this._unwrap) {
                    this._resolve(this._values[0])
                  } else {
                    this._resolve(this._values)
                  }
                }
              };
              SomePromiseArray.prototype._promiseRejected = function (reason) {
                this._addRejected(reason);
                if (this.howMany() > this._canPossiblyFulfill()) {
                  var e = new AggregateError;
                  for (var i = this.length(); i < this._values.length; ++i) {
                    e.push(this._values[i])
                  }
                  this._reject(e)
                }
              };
              SomePromiseArray.prototype._fulfilled = function () {
                return this._totalResolved
              };
              SomePromiseArray.prototype._rejected = function () {
                return this._values.length - this.length()
              };
              SomePromiseArray.prototype._addRejected = function (reason) {
                this._values.push(reason)
              };
              SomePromiseArray.prototype._addFulfilled = function (value) {
                this._values[this._totalResolved++] = value
              };
              SomePromiseArray.prototype._canPossiblyFulfill = function () {
                return this.length() - this._rejected()
              };
              SomePromiseArray.prototype._getRangeError = function (count) {
                var message = 'Input array must contain at least ' + this._howMany + ' items but contains only ' + count + ' items';
                return new RangeError(message)
              };
              SomePromiseArray.prototype._resolveEmptyArray = function () {
                this._reject(this._getRangeError(0))
              };
              function some(promises, howMany) {
                if ((howMany | 0) !== howMany || howMany < 0) {
                  return apiRejection('expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n')
                }
                var ret = new SomePromiseArray(promises);
                var promise = ret.promise();
                ret.setHowMany(howMany);
                ret.init();
                return promise
              }
              Promise.some = function (promises, howMany) {
                return some(promises, howMany)
              };
              Promise.prototype.some = function (howMany) {
                return some(this, howMany)
              };
              Promise._SomePromiseArray = SomePromiseArray
            }
          },
          {
            './errors.js': 13,
            './util.js': 38
          }
        ],
        34: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise) {
              function PromiseInspection(promise) {
                if (promise !== undefined) {
                  promise = promise._target();
                  this._bitField = promise._bitField;
                  this._settledValue = promise._settledValue
                } else {
                  this._bitField = 0;
                  this._settledValue = undefined
                }
              }
              PromiseInspection.prototype.value = function () {
                if (!this.isFulfilled()) {
                  throw new TypeError('cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n')
                }
                return this._settledValue
              };
              PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {
                if (!this.isRejected()) {
                  throw new TypeError('cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n')
                }
                return this._settledValue
              };
              PromiseInspection.prototype.isFulfilled = Promise.prototype._isFulfilled = function () {
                return (this._bitField & 268435456) > 0
              };
              PromiseInspection.prototype.isRejected = Promise.prototype._isRejected = function () {
                return (this._bitField & 134217728) > 0
              };
              PromiseInspection.prototype.isPending = Promise.prototype._isPending = function () {
                return (this._bitField & 402653184) === 0
              };
              PromiseInspection.prototype.isResolved = Promise.prototype._isResolved = function () {
                return (this._bitField & 402653184) > 0
              };
              Promise.prototype.isPending = function () {
                return this._target()._isPending()
              };
              Promise.prototype.isRejected = function () {
                return this._target()._isRejected()
              };
              Promise.prototype.isFulfilled = function () {
                return this._target()._isFulfilled()
              };
              Promise.prototype.isResolved = function () {
                return this._target()._isResolved()
              };
              Promise.prototype._value = function () {
                return this._settledValue
              };
              Promise.prototype._reason = function () {
                this._unsetRejectionIsUnhandled();
                return this._settledValue
              };
              Promise.prototype.value = function () {
                var target = this._target();
                if (!target.isFulfilled()) {
                  throw new TypeError('cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n')
                }
                return target._settledValue
              };
              Promise.prototype.reason = function () {
                var target = this._target();
                if (!target.isRejected()) {
                  throw new TypeError('cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n')
                }
                target._unsetRejectionIsUnhandled();
                return target._settledValue
              };
              Promise.PromiseInspection = PromiseInspection
            }
          },
          {}
        ],
        35: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
              var util = _dereq_('./util.js');
              var errorObj = util.errorObj;
              var isObject = util.isObject;
              function tryConvertToPromise(obj, context) {
                if (isObject(obj)) {
                  if (obj instanceof Promise) {
                    return obj
                  } else if (isAnyBluebirdPromise(obj)) {
                    var ret = new Promise(INTERNAL);
                    obj._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null);
                    return ret
                  }
                  var then = util.tryCatch(getThen)(obj);
                  if (then === errorObj) {
                    if (context)
                      context._pushContext();
                    var ret = Promise.reject(then.e);
                    if (context)
                      context._popContext();
                    return ret
                  } else if (typeof then === 'function') {
                    return doThenable(obj, then, context)
                  }
                }
                return obj
              }
              function getThen(obj) {
                return obj.then
              }
              var hasProp = {}.hasOwnProperty;
              function isAnyBluebirdPromise(obj) {
                return hasProp.call(obj, '_promise0')
              }
              function doThenable(x, then, context) {
                var promise = new Promise(INTERNAL);
                var ret = promise;
                if (context)
                  context._pushContext();
                promise._captureStackTrace();
                if (context)
                  context._popContext();
                var synchronous = true;
                var result = util.tryCatch(then).call(x, resolveFromThenable, rejectFromThenable, progressFromThenable);
                synchronous = false;
                if (promise && result === errorObj) {
                  promise._rejectCallback(result.e, true, true);
                  promise = null
                }
                function resolveFromThenable(value) {
                  if (!promise)
                    return;
                  promise._resolveCallback(value);
                  promise = null
                }
                function rejectFromThenable(reason) {
                  if (!promise)
                    return;
                  promise._rejectCallback(reason, synchronous, true);
                  promise = null
                }
                function progressFromThenable(value) {
                  if (!promise)
                    return;
                  if (typeof promise._progress === 'function') {
                    promise._progress(value)
                  }
                }
                return ret
              }
              return tryConvertToPromise
            }
          },
          { './util.js': 38 }
        ],
        36: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
              var util = _dereq_('./util.js');
              var TimeoutError = Promise.TimeoutError;
              var afterTimeout = function (promise, message) {
                if (!promise.isPending())
                  return;
                if (typeof message !== 'string') {
                  message = 'operation timed out'
                }
                var err = new TimeoutError(message);
                util.markAsOriginatingFromRejection(err);
                promise._attachExtraTrace(err);
                promise._cancel(err)
              };
              var afterValue = function (value) {
                return delay(+this).thenReturn(value)
              };
              var delay = Promise.delay = function (value, ms) {
                if (ms === undefined) {
                  ms = value;
                  value = undefined;
                  var ret = new Promise(INTERNAL);
                  setTimeout(function () {
                    ret._fulfill()
                  }, ms);
                  return ret
                }
                ms = +ms;
                return Promise.resolve(value)._then(afterValue, null, null, ms, undefined)
              };
              Promise.prototype.delay = function (ms) {
                return delay(this, ms)
              };
              function successClear(value) {
                var handle = this;
                if (handle instanceof Number)
                  handle = +handle;
                clearTimeout(handle);
                return value
              }
              function failureClear(reason) {
                var handle = this;
                if (handle instanceof Number)
                  handle = +handle;
                clearTimeout(handle);
                throw reason
              }
              Promise.prototype.timeout = function (ms, message) {
                ms = +ms;
                var ret = this.then().cancellable();
                ret._cancellationParent = this;
                var handle = setTimeout(function timeoutTimeout() {
                  afterTimeout(ret, message)
                }, ms);
                return ret._then(successClear, failureClear, undefined, handle, undefined)
              }
            }
          },
          { './util.js': 38 }
        ],
        37: [
          function (_dereq_, module, exports) {
            'use strict';
            module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext) {
              var TypeError = _dereq_('./errors.js').TypeError;
              var inherits = _dereq_('./util.js').inherits;
              var PromiseInspection = Promise.PromiseInspection;
              function inspectionMapper(inspections) {
                var len = inspections.length;
                for (var i = 0; i < len; ++i) {
                  var inspection = inspections[i];
                  if (inspection.isRejected()) {
                    return Promise.reject(inspection.error())
                  }
                  inspections[i] = inspection._settledValue
                }
                return inspections
              }
              function thrower(e) {
                setTimeout(function () {
                  throw e
                }, 0)
              }
              function castPreservingDisposable(thenable) {
                var maybePromise = tryConvertToPromise(thenable);
                if (maybePromise !== thenable && typeof thenable._isDisposable === 'function' && typeof thenable._getDisposer === 'function' && thenable._isDisposable()) {
                  maybePromise._setDisposable(thenable._getDisposer())
                }
                return maybePromise
              }
              function dispose(resources, inspection) {
                var i = 0;
                var len = resources.length;
                var ret = Promise.defer();
                function iterator() {
                  if (i >= len)
                    return ret.resolve();
                  var maybePromise = castPreservingDisposable(resources[i++]);
                  if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                    try {
                      maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise)
                    } catch (e) {
                      return thrower(e)
                    }
                    if (maybePromise instanceof Promise) {
                      return maybePromise._then(iterator, thrower, null, null, null)
                    }
                  }
                  iterator()
                }
                iterator();
                return ret.promise
              }
              function disposerSuccess(value) {
                var inspection = new PromiseInspection;
                inspection._settledValue = value;
                inspection._bitField = 268435456;
                return dispose(this, inspection).thenReturn(value)
              }
              function disposerFail(reason) {
                var inspection = new PromiseInspection;
                inspection._settledValue = reason;
                inspection._bitField = 134217728;
                return dispose(this, inspection).thenThrow(reason)
              }
              function Disposer(data, promise, context) {
                this._data = data;
                this._promise = promise;
                this._context = context
              }
              Disposer.prototype.data = function () {
                return this._data
              };
              Disposer.prototype.promise = function () {
                return this._promise
              };
              Disposer.prototype.resource = function () {
                if (this.promise().isFulfilled()) {
                  return this.promise().value()
                }
                return null
              };
              Disposer.prototype.tryDispose = function (inspection) {
                var resource = this.resource();
                var context = this._context;
                if (context !== undefined)
                  context._pushContext();
                var ret = resource !== null ? this.doDispose(resource, inspection) : null;
                if (context !== undefined)
                  context._popContext();
                this._promise._unsetDisposable();
                this._data = null;
                return ret
              };
              Disposer.isDisposer = function (d) {
                return d != null && typeof d.resource === 'function' && typeof d.tryDispose === 'function'
              };
              function FunctionDisposer(fn, promise, context) {
                this.constructor$(fn, promise, context)
              }
              inherits(FunctionDisposer, Disposer);
              FunctionDisposer.prototype.doDispose = function (resource, inspection) {
                var fn = this.data();
                return fn.call(resource, resource, inspection)
              };
              function maybeUnwrapDisposer(value) {
                if (Disposer.isDisposer(value)) {
                  this.resources[this.index]._setDisposable(value);
                  return value.promise()
                }
                return value
              }
              Promise.using = function () {
                var len = arguments.length;
                if (len < 2)
                  return apiRejection('you must pass at least 2 arguments to Promise.using');
                var fn = arguments[len - 1];
                if (typeof fn !== 'function')
                  return apiRejection('fn must be a function\n\n    See http://goo.gl/916lJJ\n');
                len--;
                var resources = new Array(len);
                for (var i = 0; i < len; ++i) {
                  var resource = arguments[i];
                  if (Disposer.isDisposer(resource)) {
                    var disposer = resource;
                    resource = resource.promise();
                    resource._setDisposable(disposer)
                  } else {
                    var maybePromise = tryConvertToPromise(resource);
                    if (maybePromise instanceof Promise) {
                      resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                        resources: resources,
                        index: i
                      }, undefined)
                    }
                  }
                  resources[i] = resource
                }
                var promise = Promise.settle(resources).then(inspectionMapper).then(function (vals) {
                  promise._pushContext();
                  var ret;
                  try {
                    ret = fn.apply(undefined, vals)
                  } finally {
                    promise._popContext()
                  }
                  return ret
                })._then(disposerSuccess, disposerFail, undefined, resources, undefined);
                resources.promise = promise;
                return promise
              };
              Promise.prototype._setDisposable = function (disposer) {
                this._bitField = this._bitField | 262144;
                this._disposer = disposer
              };
              Promise.prototype._isDisposable = function () {
                return (this._bitField & 262144) > 0
              };
              Promise.prototype._getDisposer = function () {
                return this._disposer
              };
              Promise.prototype._unsetDisposable = function () {
                this._bitField = this._bitField & ~262144;
                this._disposer = undefined
              };
              Promise.prototype.disposer = function (fn) {
                if (typeof fn === 'function') {
                  return new FunctionDisposer(fn, this, createContext())
                }
                throw new TypeError
              }
            }
          },
          {
            './errors.js': 13,
            './util.js': 38
          }
        ],
        38: [
          function (_dereq_, module, exports) {
            'use strict';
            var es5 = _dereq_('./es5.js');
            var canEvaluate = typeof navigator == 'undefined';
            var haveGetters = function () {
              try {
                var o = {};
                es5.defineProperty(o, 'f', {
                  get: function () {
                    return 3
                  }
                });
                return o.f === 3
              } catch (e) {
                return false
              }
            }();
            var errorObj = { e: {} };
            var tryCatchTarget;
            function tryCatcher() {
              try {
                var target = tryCatchTarget;
                tryCatchTarget = null;
                return target.apply(this, arguments)
              } catch (e) {
                errorObj.e = e;
                return errorObj
              }
            }
            function tryCatch(fn) {
              tryCatchTarget = fn;
              return tryCatcher
            }
            var inherits = function (Child, Parent) {
              var hasProp = {}.hasOwnProperty;
              function T() {
                this.constructor = Child;
                this.constructor$ = Parent;
                for (var propertyName in Parent.prototype) {
                  if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== '$') {
                    this[propertyName + '$'] = Parent.prototype[propertyName]
                  }
                }
              }
              T.prototype = Parent.prototype;
              Child.prototype = new T;
              return Child.prototype
            };
            function isPrimitive(val) {
              return val == null || val === true || val === false || typeof val === 'string' || typeof val === 'number'
            }
            function isObject(value) {
              return !isPrimitive(value)
            }
            function maybeWrapAsError(maybeError) {
              if (!isPrimitive(maybeError))
                return maybeError;
              return new Error(safeToString(maybeError))
            }
            function withAppended(target, appendee) {
              var len = target.length;
              var ret = new Array(len + 1);
              var i;
              for (i = 0; i < len; ++i) {
                ret[i] = target[i]
              }
              ret[i] = appendee;
              return ret
            }
            function getDataPropertyOrDefault(obj, key, defaultValue) {
              if (es5.isES5) {
                var desc = Object.getOwnPropertyDescriptor(obj, key);
                if (desc != null) {
                  return desc.get == null && desc.set == null ? desc.value : defaultValue
                }
              } else {
                return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined
              }
            }
            function notEnumerableProp(obj, name, value) {
              if (isPrimitive(obj))
                return obj;
              var descriptor = {
                value: value,
                configurable: true,
                enumerable: false,
                writable: true
              };
              es5.defineProperty(obj, name, descriptor);
              return obj
            }
            function thrower(r) {
              throw r
            }
            var inheritedDataKeys = function () {
              var excludedPrototypes = [
                Array.prototype,
                Object.prototype,
                Function.prototype
              ];
              var isExcludedProto = function (val) {
                for (var i = 0; i < excludedPrototypes.length; ++i) {
                  if (excludedPrototypes[i] === val) {
                    return true
                  }
                }
                return false
              };
              if (es5.isES5) {
                var getKeys = Object.getOwnPropertyNames;
                return function (obj) {
                  var ret = [];
                  var visitedKeys = Object.create(null);
                  while (obj != null && !isExcludedProto(obj)) {
                    var keys;
                    try {
                      keys = getKeys(obj)
                    } catch (e) {
                      return ret
                    }
                    for (var i = 0; i < keys.length; ++i) {
                      var key = keys[i];
                      if (visitedKeys[key])
                        continue;
                      visitedKeys[key] = true;
                      var desc = Object.getOwnPropertyDescriptor(obj, key);
                      if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key)
                      }
                    }
                    obj = es5.getPrototypeOf(obj)
                  }
                  return ret
                }
              } else {
                var hasProp = {}.hasOwnProperty;
                return function (obj) {
                  if (isExcludedProto(obj))
                    return [];
                  var ret = [];
                  /*jshint forin:false */
                  enumeration:
                    for (var key in obj) {
                      if (hasProp.call(obj, key)) {
                        ret.push(key)
                      } else {
                        for (var i = 0; i < excludedPrototypes.length; ++i) {
                          if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration
                          }
                        }
                        ret.push(key)
                      }
                    }
                  return ret
                }
              }
            }();
            var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
            function isClass(fn) {
              try {
                if (typeof fn === 'function') {
                  var keys = es5.names(fn.prototype);
                  var hasMethods = es5.isES5 && keys.length > 1;
                  var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === 'constructor');
                  var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + '') && es5.names(fn).length > 0;
                  if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                    return true
                  }
                }
                return false
              } catch (e) {
                return false
              }
            }
            function toFastProperties(obj) {
              /*jshint -W027,-W055,-W031*/
              function f() {
              }
              f.prototype = obj;
              var l = 8;
              while (l--)
                new f;
              return obj;
              eval(obj)
            }
            var rident = /^[a-z$_][a-z$_0-9]*$/i;
            function isIdentifier(str) {
              return rident.test(str)
            }
            function filledRange(count, prefix, suffix) {
              var ret = new Array(count);
              for (var i = 0; i < count; ++i) {
                ret[i] = prefix + i + suffix
              }
              return ret
            }
            function safeToString(obj) {
              try {
                return obj + ''
              } catch (e) {
                return '[no string representation]'
              }
            }
            function markAsOriginatingFromRejection(e) {
              try {
                notEnumerableProp(e, 'isOperational', true)
              } catch (ignore) {
              }
            }
            function originatesFromRejection(e) {
              if (e == null)
                return false;
              return e instanceof Error['__BluebirdErrorTypes__'].OperationalError || e['isOperational'] === true
            }
            function canAttachTrace(obj) {
              return obj instanceof Error && es5.propertyIsWritable(obj, 'stack')
            }
            var ensureErrorObject = function () {
              if (!('stack' in new Error)) {
                return function (value) {
                  if (canAttachTrace(value))
                    return value;
                  try {
                    throw new Error(safeToString(value))
                  } catch (err) {
                    return err
                  }
                }
              } else {
                return function (value) {
                  if (canAttachTrace(value))
                    return value;
                  return new Error(safeToString(value))
                }
              }
            }();
            function classString(obj) {
              return {}.toString.call(obj)
            }
            function copyDescriptors(from, to, filter) {
              var keys = es5.names(from);
              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (filter(key)) {
                  try {
                    es5.defineProperty(to, key, es5.getDescriptor(from, key))
                  } catch (ignore) {
                  }
                }
              }
            }
            var ret = {
              isClass: isClass,
              isIdentifier: isIdentifier,
              inheritedDataKeys: inheritedDataKeys,
              getDataPropertyOrDefault: getDataPropertyOrDefault,
              thrower: thrower,
              isArray: es5.isArray,
              haveGetters: haveGetters,
              notEnumerableProp: notEnumerableProp,
              isPrimitive: isPrimitive,
              isObject: isObject,
              canEvaluate: canEvaluate,
              errorObj: errorObj,
              tryCatch: tryCatch,
              inherits: inherits,
              withAppended: withAppended,
              maybeWrapAsError: maybeWrapAsError,
              toFastProperties: toFastProperties,
              filledRange: filledRange,
              toString: safeToString,
              canAttachTrace: canAttachTrace,
              ensureErrorObject: ensureErrorObject,
              originatesFromRejection: originatesFromRejection,
              markAsOriginatingFromRejection: markAsOriginatingFromRejection,
              classString: classString,
              copyDescriptors: copyDescriptors,
              hasDevTools: typeof chrome !== 'undefined' && chrome && typeof chrome.loadTimes === 'function',
              isNode: typeof process !== 'undefined' && classString(process).toLowerCase() === '[object process]'
            };
            ret.isRecentNode = ret.isNode && function () {
              var version = process.versions.node.split('.').map(Number);
              return version[0] === 0 && version[1] > 10 || version[0] > 0
            }();
            if (ret.isNode)
              ret.toFastProperties(process);
            try {
              throw new Error
            } catch (e) {
              ret.lastLineError = e
            }
            module.exports = ret
          },
          { './es5.js': 14 }
        ]
      }, {}, [4])(4)
    });
    ;
    if (typeof window !== 'undefined' && window !== null) {
      window.P = window.Promise
    } else if (typeof self !== 'undefined' && self !== null) {
      self.P = self.Promise
    }
  });
  // source: node_modules/xhr-promise/index.js
  rqzt.define('xhr-promise', function (module, exports, __dirname, __filename, process) {
    module.exports = rqzt('xhr-promise/lib/xhr-promise')
  });
  // source: node_modules/xhr-promise/lib/xhr-promise.js
  rqzt.define('xhr-promise/lib/xhr-promise', function (module, exports, __dirname, __filename, process) {
    /*
 * Copyright 2015 Scott Brady
 * MIT License
 * https://github.com/scottbrady/xhr-promise/blob/master/LICENSE
 */
    var ParseHeaders, Promise, XMLHttpRequestPromise, extend;
    Promise = rqzt('bluebird/js/browser/bluebird');
    extend = rqzt('extend');
    ParseHeaders = rqzt('parse-headers/parse-headers');
    /*
 * Module to wrap an XMLHttpRequest in a promise.
 */
    module.exports = XMLHttpRequestPromise = function () {
      function XMLHttpRequestPromise() {
      }
      XMLHttpRequestPromise.DEFAULT_CONTENT_TYPE = 'application/x-www-form-urlencoded; charset=UTF-8';
      /*
   * XMLHttpRequestPromise.send(options) -> Promise
   * - options (Object): URL, method, data, etc.
   *
   * Create the XHR object and wire up event handlers to use a promise.
   */
      XMLHttpRequestPromise.prototype.send = function (options) {
        var defaults;
        if (options == null) {
          options = {}
        }
        defaults = {
          method: 'GET',
          data: null,
          headers: {},
          async: true,
          username: null,
          password: null
        };
        options = extend({}, defaults, options);
        return new Promise(function (_this) {
          return function (resolve, reject) {
            var e, header, ref, value, xhr;
            if (!XMLHttpRequest) {
              _this._handleError('browser', reject, null, "browser doesn't support XMLHttpRequest");
              return
            }
            if (typeof options.url !== 'string' || options.url.length === 0) {
              _this._handleError('url', reject, null, 'URL is a required parameter');
              return
            }
            _this._xhr = xhr = new XMLHttpRequest;
            xhr.onload = function () {
              var responseText;
              _this._detachWindowUnload();
              try {
                responseText = _this._getResponseText()
              } catch (_error) {
                _this._handleError('parse', reject, null, 'invalid JSON response');
                return
              }
              return resolve({
                url: _this._getResponseUrl(),
                status: xhr.status,
                statusText: xhr.statusText,
                responseText: responseText,
                headers: _this._getHeaders(),
                xhr: xhr
              })
            };
            xhr.onerror = function () {
              return _this._handleError('error', reject)
            };
            xhr.ontimeout = function () {
              return _this._handleError('timeout', reject)
            };
            xhr.onabort = function () {
              return _this._handleError('abort', reject)
            };
            _this._attachWindowUnload();
            xhr.open(options.method, options.url, options.async, options.username, options.password);
            if (options.data != null && !options.headers['Content-Type']) {
              options.headers['Content-Type'] = _this.constructor.DEFAULT_CONTENT_TYPE
            }
            ref = options.headers;
            for (header in ref) {
              value = ref[header];
              xhr.setRequestHeader(header, value)
            }
            try {
              return xhr.send(options.data)
            } catch (_error) {
              e = _error;
              return _this._handleError('send', reject, null, e.toString())
            }
          }
        }(this))
      };
      /*
   * XMLHttpRequestPromise.getXHR() -> XMLHttpRequest
   */
      XMLHttpRequestPromise.prototype.getXHR = function () {
        return this._xhr
      };
      /*
   * XMLHttpRequestPromise._attachWindowUnload()
   *
   * Fix for IE 9 and IE 10
   * Internet Explorer freezes when you close a webpage during an XHR request
   * https://support.microsoft.com/kb/2856746
   *
   */
      XMLHttpRequestPromise.prototype._attachWindowUnload = function () {
        this._unloadHandler = this._handleWindowUnload.bind(this);
        if (window.attachEvent) {
          return window.attachEvent('onunload', this._unloadHandler)
        }
      };
      /*
   * XMLHttpRequestPromise._detachWindowUnload()
   */
      XMLHttpRequestPromise.prototype._detachWindowUnload = function () {
        if (window.detachEvent) {
          return window.detachEvent('onunload', this._unloadHandler)
        }
      };
      /*
   * XMLHttpRequestPromise._getHeaders() -> Object
   */
      XMLHttpRequestPromise.prototype._getHeaders = function () {
        return ParseHeaders(this._xhr.getAllResponseHeaders())
      };
      /*
   * XMLHttpRequestPromise._getResponseText() -> Mixed
   *
   * Parses response text JSON if present.
   */
      XMLHttpRequestPromise.prototype._getResponseText = function () {
        var responseText;
        responseText = typeof this._xhr.responseText === 'string' ? this._xhr.responseText : '';
        switch (this._xhr.getResponseHeader('Content-Type')) {
        case 'application/json':
        case 'text/javascript':
          responseText = JSON.parse(responseText + '')
        }
        return responseText
      };
      /*
   * XMLHttpRequestPromise._getResponseUrl() -> String
   *
   * Actual response URL after following redirects.
   */
      XMLHttpRequestPromise.prototype._getResponseUrl = function () {
        if (this._xhr.responseURL != null) {
          return this._xhr.responseURL
        }
        if (/^X-Request-URL:/m.test(this._xhr.getAllResponseHeaders())) {
          return this._xhr.getResponseHeader('X-Request-URL')
        }
        return ''
      };
      /*
   * XMLHttpRequestPromise._handleError(reason, reject, status, statusText)
   * - reason (String)
   * - reject (Function)
   * - status (String)
   * - statusText (String)
   */
      XMLHttpRequestPromise.prototype._handleError = function (reason, reject, status, statusText) {
        this._detachWindowUnload();
        return reject({
          reason: reason,
          status: status || this._xhr.status,
          statusText: statusText || this._xhr.statusText,
          xhr: this._xhr
        })
      };
      /*
   * XMLHttpRequestPromise._handleWindowUnload()
   */
      XMLHttpRequestPromise.prototype._handleWindowUnload = function () {
        return this._xhr.abort()
      };
      return XMLHttpRequestPromise
    }()
  });
  // source: node_modules/xhr-promise/node_modules/extend/index.js
  rqzt.define('extend', function (module, exports, __dirname, __filename, process) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var undefined;
    var isArray = function isArray(arr) {
      if (typeof Array.isArray === 'function') {
        return Array.isArray(arr)
      }
      return toStr.call(arr) === '[object Array]'
    };
    var isPlainObject = function isPlainObject(obj) {
      'use strict';
      if (!obj || toStr.call(obj) !== '[object Object]') {
        return false
      }
      var has_own_constructor = hasOwn.call(obj, 'constructor');
      var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
      // Not own constructor property must be Object
      if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
        return false
      }
      // Own properties are enumerated firstly, so to speed up,
      // if last one is own, then all properties are own.
      var key;
      for (key in obj) {
      }
      return key === undefined || hasOwn.call(obj, key)
    };
    module.exports = function extend() {
      'use strict';
      var options, name, src, copy, copyIsArray, clone, target = arguments[0], i = 1, length = arguments.length, deep = false;
      // Handle a deep copy situation
      if (typeof target === 'boolean') {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2
      } else if (typeof target !== 'object' && typeof target !== 'function' || target == null) {
        target = {}
      }
      for (; i < length; ++i) {
        options = arguments[i];
        // Only deal with non-null/undefined values
        if (options != null) {
          // Extend the base object
          for (name in options) {
            src = target[name];
            copy = options[name];
            // Prevent never-ending loop
            if (target === copy) {
              continue
            }
            // Recurse if we're merging plain objects or arrays
            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : []
              } else {
                clone = src && isPlainObject(src) ? src : {}
              }
              // Never move original objects, clone them
              target[name] = extend(deep, clone, copy)  // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy
            }
          }
        }
      }
      // Return the modified object
      return target
    }
  });
  // source: node_modules/parse-headers/parse-headers.js
  rqzt.define('parse-headers/parse-headers', function (module, exports, __dirname, __filename, process) {
    var trim = rqzt('trim'), forEach = rqzt('for-each'), isArray = function (arg) {
        return Object.prototype.toString.call(arg) === '[object Array]'
      };
    module.exports = function (headers) {
      if (!headers)
        return {};
      var result = {};
      forEach(trim(headers).split('\n'), function (row) {
        var index = row.indexOf(':'), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
        if (typeof result[key] === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [
            result[key],
            value
          ]
        }
      });
      return result
    }
  });
  // source: node_modules/trim/index.js
  rqzt.define('trim', function (module, exports, __dirname, __filename, process) {
    exports = module.exports = trim;
    function trim(str) {
      return str.replace(/^\s*|\s*$/g, '')
    }
    exports.left = function (str) {
      return str.replace(/^\s*/, '')
    };
    exports.right = function (str) {
      return str.replace(/\s*$/, '')
    }
  });
  // source: node_modules/for-each/index.js
  rqzt.define('for-each', function (module, exports, __dirname, __filename, process) {
    var isFunction = rqzt('is-function');
    module.exports = forEach;
    var toString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function forEach(list, iterator, context) {
      if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
      }
      if (arguments.length < 3) {
        context = this
      }
      if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context);
      else if (typeof list === 'string')
        forEachString(list, iterator, context);
      else
        forEachObject(list, iterator, context)
    }
    function forEachArray(array, iterator, context) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          iterator.call(context, array[i], i, array)
        }
      }
    }
    function forEachString(string, iterator, context) {
      for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
      }
    }
    function forEachObject(object, iterator, context) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          iterator.call(context, object[k], k, object)
        }
      }
    }
  });
  // source: node_modules/is-function/index.js
  rqzt.define('is-function', function (module, exports, __dirname, __filename, process) {
    module.exports = isFunction;
    var toString = Object.prototype.toString;
    function isFunction(fn) {
      var string = toString.call(fn);
      return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt)
    }
    ;
  });
  // source: node_modules/raf/index.js
  rqzt.define('raf', function (module, exports, __dirname, __filename, process) {
    var now = rqzt('performance-now/lib/performance-now'), root = typeof window === 'undefined' ? global : window, vendors = [
        'moz',
        'webkit'
      ], suffix = 'AnimationFrame', raf = root['request' + suffix], caf = root['cancel' + suffix] || root['cancelRequest' + suffix];
    for (var i = 0; !raf && i < vendors.length; i++) {
      raf = root[vendors[i] + 'Request' + suffix];
      caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix]
    }
    // Some versions of FF have rAF but not cAF
    if (!raf || !caf) {
      var last = 0, id = 0, queue = [], frameDuration = 1000 / 60;
      raf = function (callback) {
        if (queue.length === 0) {
          var _now = now(), next = Math.max(0, frameDuration - (_now - last));
          last = next + _now;
          setTimeout(function () {
            var cp = queue.slice(0);
            // Clear queue here to prevent
            // callbacks from appending listeners
            // to the current frame's queue
            queue.length = 0;
            for (var i = 0; i < cp.length; i++) {
              if (!cp[i].cancelled) {
                try {
                  cp[i].callback(last)
                } catch (e) {
                  setTimeout(function () {
                    throw e
                  }, 0)
                }
              }
            }
          }, Math.round(next))
        }
        queue.push({
          handle: ++id,
          callback: callback,
          cancelled: false
        });
        return id
      };
      caf = function (handle) {
        for (var i = 0; i < queue.length; i++) {
          if (queue[i].handle === handle) {
            queue[i].cancelled = true
          }
        }
      }
    }
    module.exports = function (fn) {
      // Wrap in a new function to prevent
      // `cancel` potentially being assigned
      // to the native rAF function
      return raf.call(root, fn)
    };
    module.exports.cancel = function () {
      caf.apply(root, arguments)
    };
    module.exports.polyfill = function () {
      root.requestAnimationFrame = raf;
      root.cancelAnimationFrame = caf
    }
  });
  // source: node_modules/performance-now/lib/performance-now.js
  rqzt.define('performance-now/lib/performance-now', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.7.1
    (function () {
      var getNanoSeconds, hrtime, loadTime;
      if (typeof performance !== 'undefined' && performance !== null && performance.now) {
        module.exports = function () {
          return performance.now()
        }
      } else if (typeof process !== 'undefined' && process !== null && process.hrtime) {
        module.exports = function () {
          return (getNanoSeconds() - loadTime) / 1000000
        };
        hrtime = process.hrtime;
        getNanoSeconds = function () {
          var hr;
          hr = hrtime();
          return hr[0] * 1000000000 + hr[1]
        };
        loadTime = getNanoSeconds()
      } else if (Date.now) {
        module.exports = function () {
          return Date.now() - loadTime
        };
        loadTime = Date.now()
      } else {
        module.exports = function () {
          return new Date().getTime() - loadTime
        };
        loadTime = new Date().getTime()
      }
    }.call(this))
  });
  // source: node_modules/crowdcontrol/lib/utils/log.js
  rqzt.define('crowdcontrol/lib/utils/log', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var log;
    log = function () {
      if (log.DEBUG) {
        return console.log.apply(console, arguments)
      }
    };
    log.DEBUG = false;
    log.debug = log;
    log.info = function () {
      return console.log.apply(console, arguments)
    };
    log.warn = function () {
      console.log('WARN:');
      return console.log.apply(console, arguments)
    };
    log.error = function () {
      console.log('ERROR:');
      console.log.apply(console, arguments);
      throw new arguments[0]
    };
    module.exports = log  //# sourceMappingURL=log.js.map
  });
  // source: node_modules/crowdcontrol/lib/utils/mediator.js
  rqzt.define('crowdcontrol/lib/utils/mediator', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var mediator, riot;
    riot = rqzt('crowdcontrol/lib/utils/shim').riot;
    mediator = {};
    riot.observable(mediator);
    module.exports = mediator  //# sourceMappingURL=mediator.js.map
  });
  // source: node_modules/crowdcontrol/lib/data/source.js
  rqzt.define('crowdcontrol/lib/data/source', function (module, exports, __dirname, __filename, process) {
  });
  // source: node_modules/crowdcontrol/lib/view/index.js
  rqzt.define('crowdcontrol/lib/view', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    module.exports = {
      form: rqzt('crowdcontrol/lib/view/form'),
      View: rqzt('crowdcontrol/lib/view/view')
    }  //# sourceMappingURL=index.js.map
  });
  // source: node_modules/crowdcontrol/lib/view/form.js
  rqzt.define('crowdcontrol/lib/view/form', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var Events, FormView, Input, InputCondition, InputConfig, InputView, ValidatorCondition, View, helpers, isArray, isFunction, isNumber, isObject, log, promise, riot, tokenize, traverse, utils, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    isArray = rqzt('is-array');
    isFunction = rqzt('is-function');
    isNumber = rqzt('is-number');
    isObject = rqzt('is-object');
    Events = rqzt('crowdcontrol/lib/events');
    utils = rqzt('crowdcontrol/lib/utils');
    log = utils.log;
    riot = utils.shim.riot;
    promise = utils.shim.promise;
    View = rqzt('crowdcontrol/lib/view/view');
    tokenize = function (str) {
      var dict, j, k, len, ref, token, tokens, v;
      tokens = str.split(' ');
      dict = {};
      for (j = 0, len = tokens.length; j < len; j++) {
        token = tokens[j];
        if (token.indexOf(':') >= 0) {
          ref = token.split(':'), k = ref[0], v = ref[1];
          dict[k] = v
        } else {
          dict[token] = true
        }
      }
      return dict
    };
    InputConfig = function () {
      InputConfig.prototype.name = '';
      InputConfig.prototype['default'] = '';
      InputConfig.prototype.placeholder = '';
      InputConfig.prototype.hints = null;
      function InputConfig(name1, _default, placeholder, hints) {
        this.name = name1;
        this['default'] = _default != null ? _default : '';
        this.placeholder = placeholder != null ? placeholder : '';
        if (hints == null) {
          hints = ''
        }
        this.hints = tokenize(hints)
      }
      return InputConfig
    }();
    Input = function () {
      Input.prototype.tag = '';
      Input.prototype.model = {};
      Input.prototype.validator = function () {
      };
      Input.prototype.obs = null;
      function Input(tag1, model1, validator1) {
        this.tag = tag1;
        this.model = model1;
        this.validator = validator1
      }
      return Input
    }();
    ValidatorCondition = function () {
      function ValidatorCondition(predicate1, validatorFn1) {
        this.predicate = predicate1;
        this.validatorFn = validatorFn1
      }
      return ValidatorCondition
    }();
    InputCondition = function () {
      function InputCondition(predicate1, tagName1) {
        this.predicate = predicate1;
        this.tagName = tagName1
      }
      return InputCondition
    }();
    helpers = {
      tagLookup: [],
      validatorLookup: [],
      defaultTagName: 'form-input',
      errorTag: 'form-error',
      registerValidator: function (predicate, validatorFn) {
        if (isFunction(validatorFn)) {
          return this.validatorLookup.push(new ValidatorCondition(predicate, validatorFn))
        }
      },
      registerTag: function (predicate, tagName) {
        return this.tagLookup.push(new InputCondition(predicate, tagName))
      },
      deleteTag: function (tagName) {
        var i, j, len, lookup, ref, results1;
        ref = this.tagLookup;
        results1 = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          lookup = ref[i];
          if (lookup.tagName === tagName) {
            results1.push(this.tagLookup[i] = null)
          } else {
            results1.push(void 0)
          }
        }
        return results1
      },
      deleteValidator: function (predicate, validatorFn) {
        var i, j, len, lookup, ref, results1;
        ref = this.validatorLookup;
        results1 = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          lookup = ref[i];
          if (lookup.validatorFn === validatorFn) {
            results1.push(this.validatorLookup[i] = null)
          } else {
            results1.push(void 0)
          }
        }
        return results1
      },
      render: function (inputCfgs) {
        var fn1, i, inputCfg, inputs, j, len, validators;
        inputs = {};
        fn1 = function (_this) {
          return function (validators, inputCfg) {
            var found, l, len1, len2, lookup, m, model, ref, ref1, tag, validator, validatorFn;
            ref = _this.validatorLookup;
            for (l = 0, len1 = ref.length; l < len1; l++) {
              lookup = ref[l];
              if (lookup.predicate(inputCfg)) {
                validatorFn = lookup.validatorFn;
                (function (validatorFn) {
                  return validators.push(function (pair) {
                    var model, name, p;
                    model = pair[0], name = pair[1];
                    p = promise['new'](function (resolve, reject) {
                      return resolve(pair)
                    });
                    return p.then(function (pair) {
                      return validatorFn.call(inputCfg, pair[0], pair[1])
                    }).then(function (v) {
                      model[name] = v;
                      return promise['new'](function (resolve, reject) {
                        return resolve(pair)
                      })
                    })
                  })
                }(validatorFn))
              }
            }
            validators.push(function (pair) {
              var model, name;
              model = pair[0], name = pair[1];
              return promise['new'](function (resolve, reject) {
                return resolve(model[name])
              })
            });
            validator = function (model, name) {
              var len2, m, p;
              p = promise['new'](function (resolve, reject) {
                return resolve([
                  model,
                  name
                ])
              });
              for (m = 0, len2 = validators.length; m < len2; m++) {
                validatorFn = validators[m];
                p = p.then(validatorFn)
              }
              return p
            };
            found = false;
            ref1 = _this.tagLookup;
            for (m = 0, len2 = ref1.length; m < len2; m++) {
              lookup = ref1[m];
              if (lookup == null) {
                continue
              }
              if (lookup.predicate(inputCfg)) {
                tag = lookup.tagName;
                found = true;
                break
              }
            }
            if (!found) {
              tag = _this.defaultTagName
            }
            model = {
              name: inputCfg.name,
              value: inputCfg['default'],
              placeholder: inputCfg.placeholder,
              cfg: inputCfg
            };
            return inputs[inputCfg.name] = new Input(tag, model, validator)
          }
        }(this);
        for (i = j = 0, len = inputCfgs.length; j < len; i = ++j) {
          inputCfg = inputCfgs[i];
          if (inputCfg == null) {
            continue
          }
          validators = [];
          fn1(validators, inputCfg)
        }
        return inputs
      }
    };
    Events.Input = {
      Result: 'input-result',
      Get: 'input-get',
      Set: 'input-set',
      Change: 'input-change',
      Error: 'input-error',
      ClearError: 'input-clear-error'
    };
    InputView = function (superClass) {
      var obj1;
      extend(InputView, superClass);
      function InputView() {
        return InputView.__super__.constructor.apply(this, arguments)
      }
      InputView.prototype.getValue = function (el) {
        return el.value
      };
      InputView.prototype.errorHtml = '<div class="error-container" if="{ hasError() }">\n  <div class="error-message">{ error }</div>\n</div>';
      InputView.prototype.init = function () {
        return this.html += this.errorHtml
      };
      InputView.prototype.events = (obj1 = {}, obj1['' + Events.Input.Set] = function () {
        return this._set.apply(this, arguments)
      }, obj1['' + Events.Input.Error] = function () {
        return this._error.apply(this, arguments)
      }, obj1['' + Events.Input.ClearError] = function () {
        return this._clearError.apply(this, arguments)
      }, obj1);
      InputView.prototype._clearError = function (name) {
        if (name === this.model.name) {
          this.clearError();
          return this.update()
        }
      };
      InputView.prototype._error = function (name, message) {
        if (name === this.model.name) {
          this.setError(message);
          return this.update()
        }
      };
      InputView.prototype._set = function (name, value) {
        if (name === this.model.name) {
          this.clearError();
          this.model.value = value;
          return this.update()
        }
      };
      InputView.prototype.change = function (event) {
        var value;
        value = this.getValue(event.target);
        if (value === '' || value !== this.model.value) {
          this.obs.trigger(Events.Input.Change, this.model.name, value)
        }
        return this.model.value = value
      };
      InputView.prototype.hasError = function () {
        var error;
        error = this.error;
        return error != null && error.length != null && error.length > 0
      };
      InputView.prototype.setError = function (message) {
        return this.error = message
      };
      InputView.prototype.clearError = function () {
        return this.setError(null)
      };
      InputView.prototype.js = function (opts) {
        return this.model = opts.input.model
      };
      return InputView
    }(View);
    riot.tag('control', '', function (opts) {
      var input;
      input = opts.input;
      if (input != null) {
        opts.obs = input.obs;
        return riot.mount(this.root, input.tag, opts)
      }
    });
    Events.Form = {
      SubmitSuccess: 'form-submit-success',
      SubmitFailed: 'form-submit-failed'
    };
    FormView = function (superClass) {
      var obj1;
      extend(FormView, superClass);
      function FormView() {
        return FormView.__super__.constructor.apply(this, arguments)
      }
      FormView.prototype.inputConfigs = null;
      FormView.prototype.events = (obj1 = {}, obj1['' + Events.Input.Get] = function () {
        return this._result.apply(this, arguments)
      }, obj1['' + Events.Input.Change] = function () {
        return this._change.apply(this, arguments)
      }, obj1);
      FormView.prototype._change = function (name, newValue) {
        var input, lastName, model, ref;
        this.fullyValidated = false;
        ref = this._set(this.model, name, newValue), model = ref[0], lastName = ref[1];
        input = this.inputs[name];
        if (input != null) {
          return input.validator(model, lastName).then(function (_this) {
            return function (value) {
              return _this.obs.trigger(Events.Input.Set, name, value)
            }
          }(this))['catch'](function (_this) {
            return function (err) {
              log('Validation error has occured', err.stack);
              return _this.obs.trigger(Events.Input.Error, name, err.message)
            }
          }(this))
        }
      };
      FormView.prototype._result = function (name) {
        return this.obs.trigger(Events.Input.Result, this._get(this.model, name))
      };
      FormView.prototype._submit = function (event) {
      };
      FormView.prototype.submit = function (event) {
        var input, lastName, model, name, names, promises, ref, ref1;
        if (event != null) {
          event.preventDefault()
        }
        if (this.fullyValidated) {
          this._submit(event);
          return
        }
        names = [];
        promises = [];
        ref = this.inputs;
        for (name in ref) {
          input = ref[name];
          names.push(name);
          ref1 = this._find(this.model, name), model = ref1[0], lastName = ref1[1];
          promises.push(input.validator(model, lastName))
        }
        return promise.settle(promises).then(function (_this) {
          return function (results) {
            var i, j, len, rejected, result;
            rejected = false;
            for (i = j = 0, len = results.length; j < len; i = ++j) {
              result = results[i];
              if (result.isRejected()) {
                rejected = true;
                _this.obs.trigger(Events.Input.Error, names[i], result.reason().message)
              }
            }
            if (rejected) {
              _this.obs.trigger(Events.Form.SubmitFailed, _this.model);
              return
            }
            _this.fullyValidated = true;
            _this.obs.trigger(Events.Form.SubmitSuccess, _this.model);
            return _this._submit(event)
          }
        }(this))
      };
      FormView.prototype._get = function (model, path) {
        var currentObject, j, len, name, names;
        names = path.split('.');
        if (names.length === 1) {
          return model[path]
        }
        currentObject = model;
        for (j = 0, len = names.length; j < len; j++) {
          name = names[j];
          if (currentObject[name] == null) {
            return void 0
          }
          currentObject = currentObject[name]
        }
        return currentObject[lastName]
      };
      FormView.prototype._set = function (model, path, value) {
        var currentObject, lastName, ref;
        ref = this._find(model, path), currentObject = ref[0], lastName = ref[1];
        currentObject[lastName] = value;
        return [
          currentObject,
          lastName
        ]
      };
      FormView.prototype._find = function (model, path) {
        var currentObject, j, lastName, len, name, names;
        names = path.split('.');
        if (names.length === 1) {
          return [
            model,
            path
          ]
        }
        lastName = names.pop();
        currentObject = model;
        for (j = 0, len = names.length; j < len; j++) {
          name = names[j];
          if (currentObject[name] != null) {
            currentObject = currentObject[name];
            continue
          }
          if (isNumber(name)) {
            currentObject[name] = []
          } else {
            currentObject[name] = {}
          }
          currentObject = currentObject[name]
        }
        return [
          currentObject,
          lastName
        ]
      };
      FormView.prototype.js = function () {
        return this.initFormGroup()
      };
      FormView.prototype.initFormGroup = function () {
        var input, inputs, key;
        if (this.inputConfigs != null) {
          if (this.inputs == null) {
            this.inputs = inputs = helpers.render(this.inputConfigs)
          } else {
            inputs = this.inputs
          }
          for (key in inputs) {
            input = inputs[key];
            input.obs = this.obs
          }
          this.fullyValidated = false;
          return traverse(this.model, function (key, value) {
            if (inputs[key] != null) {
              return inputs[key].model.value = value
            }
          })
        }
      };
      return FormView
    }(View);
    traverse = function (obj, fn, key) {
      var k, results1, v;
      if (key == null) {
        key = ''
      }
      if (isArray(obj) || isObject(obj)) {
        results1 = [];
        for (k in obj) {
          v = obj[k];
          results1.push(traverse(v, fn, key === '' ? k : key + '.' + k))
        }
        return results1
      } else {
        return fn(key, obj)
      }
    };
    module.exports = {
      helpers: helpers,
      FormView: FormView,
      InputView: InputView,
      Input: Input,
      InputConfig: InputConfig,
      tokenize: tokenize
    }  //# sourceMappingURL=form.js.map
  });
  // source: node_modules/is-array/index.js
  rqzt.define('is-array', function (module, exports, __dirname, __filename, process) {
    /**
 * isArray
 */
    var isArray = Array.isArray;
    /**
 * toString
 */
    var str = Object.prototype.toString;
    /**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */
    module.exports = isArray || function (val) {
      return !!val && '[object Array]' == str.call(val)
    }
  });
  // source: node_modules/is-number/index.js
  rqzt.define('is-number', function (module, exports, __dirname, __filename, process) {
    /*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
    'use strict';
    var typeOf = rqzt('kind-of');
    module.exports = function isNumber(num) {
      var type = typeOf(num);
      if (type !== 'number' && type !== 'string') {
        return false
      }
      var n = +num;
      return n - n + 1 >= 0 && num !== ''
    }
  });
  // source: node_modules/kind-of/index.js
  rqzt.define('kind-of', function (module, exports, __dirname, __filename, process) {
    var isBuffer = rqzt('is-buffer');
    var toString = Object.prototype.toString;
    /**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */
    module.exports = function kindOf(val) {
      // primitivies
      if (typeof val === 'undefined') {
        return 'undefined'
      }
      if (val === null) {
        return 'null'
      }
      if (val === true || val === false || val instanceof Boolean) {
        return 'boolean'
      }
      if (typeof val === 'string' || val instanceof String) {
        return 'string'
      }
      if (typeof val === 'number' || val instanceof Number) {
        return 'number'
      }
      // functions
      if (typeof val === 'function' || val instanceof Function) {
        return 'function'
      }
      // array
      if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array'
      }
      // check for instances of RegExp and Date before calling `toString`
      if (val instanceof RegExp) {
        return 'regexp'
      }
      if (val instanceof Date) {
        return 'date'
      }
      // other objects
      var type = toString.call(val);
      if (type === '[object RegExp]') {
        return 'regexp'
      }
      if (type === '[object Date]') {
        return 'date'
      }
      if (type === '[object Arguments]') {
        return 'arguments'
      }
      if (type === '[object Error]') {
        return 'error'
      }
      // buffer
      if (typeof Buffer !== 'undefined' && isBuffer(val)) {
        return 'buffer'
      }
      // es6: Map, WeakMap, Set, WeakSet
      if (type === '[object Set]') {
        return 'set'
      }
      if (type === '[object WeakSet]') {
        return 'weakset'
      }
      if (type === '[object Map]') {
        return 'map'
      }
      if (type === '[object WeakMap]') {
        return 'weakmap'
      }
      if (type === '[object Symbol]') {
        return 'symbol'
      }
      // typed arrays
      if (type === '[object Int8Array]') {
        return 'int8array'
      }
      if (type === '[object Uint8Array]') {
        return 'uint8array'
      }
      if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray'
      }
      if (type === '[object Int16Array]') {
        return 'int16array'
      }
      if (type === '[object Uint16Array]') {
        return 'uint16array'
      }
      if (type === '[object Int32Array]') {
        return 'int32array'
      }
      if (type === '[object Uint32Array]') {
        return 'uint32array'
      }
      if (type === '[object Float32Array]') {
        return 'float32array'
      }
      if (type === '[object Float64Array]') {
        return 'float64array'
      }
      // must be a plain object
      return 'object'
    }
  });
  // source: node_modules/is-buffer/index.js
  rqzt.define('is-buffer', function (module, exports, __dirname, __filename, process) {
    /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    module.exports = function (obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }
    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
    }
  });
  // source: node_modules/is-object/index.js
  rqzt.define('is-object', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function isObject(x) {
      return typeof x === 'object' && x !== null
    }
  });
  // source: node_modules/crowdcontrol/lib/events.js
  rqzt.define('crowdcontrol/lib/events', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    module.exports = {}  //# sourceMappingURL=events.js.map
  });
  // source: node_modules/crowdcontrol/lib/view/view.js
  rqzt.define('crowdcontrol/lib/view/view', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var View, extend, isFunction, riot, utils;
    extend = rqzt('extend');
    isFunction = rqzt('is-function');
    utils = rqzt('crowdcontrol/lib/utils');
    riot = utils.shim.riot;
    View = function () {
      View.register = function () {
        return new this
      };
      View.prototype.tag = '';
      View.prototype.html = '';
      View.prototype.css = '';
      View.prototype.attrs = '';
      View.prototype.events = null;
      View.prototype.mixins = null;
      View.prototype.model = null;
      View.prototype.js = function () {
      };
      function View() {
        var parentProto, proto, temp, view;
        proto = Object.getPrototypeOf(this);
        parentProto = proto;
        temp = {};
        while (parentProto !== View.prototype) {
          parentProto = Object.getPrototypeOf(parentProto);
          proto.events = extend({}, parentProto.events || {}, proto.events);
          extend(temp, parentProto || {}, proto)
        }
        extend(proto, temp);
        view = this;
        this.init();
        riot.tag(this.tag, this.html, this.css, this.attrs, function (opts) {
          var fn, handler, k, name, obs, optsP, ref, ref1, v;
          optsP = Object.getPrototypeOf(opts);
          for (k in opts) {
            v = opts[k];
            if (optsP[k] != null && v == null) {
              opts[k] = optsP[k]
            }
          }
          if (view != null) {
            ref = Object.getPrototypeOf(view);
            for (k in ref) {
              v = ref[k];
              if (isFunction(v)) {
                (function (_this) {
                  return function (v) {
                    var oldFn;
                    if (_this[k] != null) {
                      oldFn = _this[k];
                      return _this[k] = function () {
                        oldFn.apply(_this, arguments);
                        return v.apply(_this, arguments)
                      }
                    } else {
                      return _this[k] = function () {
                        return v.apply(_this, arguments)
                      }
                    }
                  }
                }(this)(v))
              } else {
                this[k] = v
              }
            }
          }
          this.model = opts.model || this.model;
          if (this.model == null) {
            this.model = {}
          }
          obs = this.obs = opts.obs;
          if (this.obs == null) {
            obs = this.obs = {};
            utils.shim.observable(obs)
          }
          if (view.events != null) {
            ref1 = view.events;
            fn = function (_this) {
              return function (name, handler) {
                return obs.on(name, function () {
                  return handler.apply(_this, arguments)
                })
              }
            }(this);
            for (name in ref1) {
              handler = ref1[name];
              fn(name, handler)
            }
          }
          if (this.js) {
            return this.js(opts)
          }
        })
      }
      View.prototype.init = function () {
      };
      return View
    }();
    module.exports = View  //# sourceMappingURL=view.js.map
  });
  // source: node_modules/crowdcontrol/lib/config.js
  rqzt.define('crowdcontrol/lib/config', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    module.exports = {}  //# sourceMappingURL=config.js.map
  });
  // source: node_modules/moment/moment.js
  rqzt.define('moment/moment', function (module, exports, __dirname, __filename, process) {
    //! moment.js
    //! version : 2.10.6
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory()
    }(this, function () {
      'use strict';
      var hookCallback;
      function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments)
      }
      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback(callback) {
        hookCallback = callback
      }
      function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]'
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]'
      }
      function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i))
        }
        return res
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b)
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i]
          }
        }
        if (hasOwnProp(b, 'toString')) {
          a.toString = b.toString
        }
        if (hasOwnProp(b, 'valueOf')) {
          a.valueOf = b.valueOf
        }
        return a
      }
      function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc()
      }
      function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false
        }
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags()
        }
        return m._pf
      }
      function valid__isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m);
          m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
          if (m._strict) {
            m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined
          }
        }
        return m._isValid
      }
      function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags)
        } else {
          getParsingFlags(m).userInvalidated = true
        }
        return m
      }
      var momentProperties = utils_hooks__hooks.momentProperties = [];
      function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== 'undefined') {
          to._isAMomentObject = from._isAMomentObject
        }
        if (typeof from._i !== 'undefined') {
          to._i = from._i
        }
        if (typeof from._f !== 'undefined') {
          to._f = from._f
        }
        if (typeof from._l !== 'undefined') {
          to._l = from._l
        }
        if (typeof from._strict !== 'undefined') {
          to._strict = from._strict
        }
        if (typeof from._tzm !== 'undefined') {
          to._tzm = from._tzm
        }
        if (typeof from._isUTC !== 'undefined') {
          to._isUTC = from._isUTC
        }
        if (typeof from._offset !== 'undefined') {
          to._offset = from._offset
        }
        if (typeof from._pf !== 'undefined') {
          to._pf = getParsingFlags(from)
        }
        if (typeof from._locale !== 'undefined') {
          to._locale = from._locale
        }
        if (momentProperties.length > 0) {
          for (i in momentProperties) {
            prop = momentProperties[i];
            val = from[prop];
            if (typeof val !== 'undefined') {
              to[prop] = val
            }
          }
        }
        return to
      }
      var updateInProgress = false;
      // Moment prototype object
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
          updateInProgress = true;
          utils_hooks__hooks.updateOffset(this);
          updateInProgress = false
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number)
        } else {
          return Math.floor(number)
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber)
        }
        return value
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++
          }
        }
        return diffs + lengthDiff
      }
      function Locale() {
      }
      var locales = {};
      var globalLocale;
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key
      }
      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split('-');
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split('-') : null;
          while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
              return locale
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
              //the next array item is better than a shallower substring of this one
              break
            }
            j--
          }
          i++
        }
        return null
      }
      function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
          try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            locale_locales__getSetGlobalLocale(oldLocale)
          } catch (e) {
          }
        }
        return locales[name]
      }
      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (typeof values === 'undefined') {
            data = locale_locales__getLocale(key)
          } else {
            data = defineLocale(key, values)
          }
          if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data
          }
        }
        return globalLocale._abbr
      }
      function defineLocale(name, values) {
        if (values !== null) {
          values.abbr = name;
          locales[name] = locales[name] || new Locale;
          locales[name].set(values);
          // backwards compat for now: also set the locale
          locale_locales__getSetGlobalLocale(name);
          return locales[name]
        } else {
          // useful for testing
          delete locales[name];
          return null
        }
      }
      // returns locale data
      function locale_locales__getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr
        }
        if (!key) {
          return globalLocale
        }
        if (!isArray(key)) {
          //short-circuit everything else
          locale = loadLocale(key);
          if (locale) {
            return locale
          }
          key = [key]
        }
        return chooseLocale(key)
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit
      }
      function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop]
            }
          }
        }
        return normalizedInput
      }
      function makeGetSet(unit, keepTime) {
        return function (value) {
          if (value != null) {
            get_set__set(this, unit, value);
            utils_hooks__hooks.updateOffset(this, keepTime);
            return this
          } else {
            return get_set__get(this, unit)
          }
        }
      }
      function get_set__get(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
      }
      function get_set__set(mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value)
      }
      // MOMENTS
      function getSet(units, value) {
        var unit;
        if (typeof units === 'object') {
          for (unit in units) {
            this.set(unit, units[unit])
          }
        } else {
          units = normalizeUnits(units);
          if (typeof this[units] === 'function') {
            return this[units](value)
          }
        }
        return this
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
      var formatFunctions = {};
      var formatTokenFunctions = {};
      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
          func = function () {
            return this[callback]()
          }
        }
        if (token) {
          formatTokenFunctions[token] = func
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2])
          }
        }
        if (ordinal) {
          formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token)
          }
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, '')
        }
        return input.replace(/\\/g, '')
      }
      function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]]
          } else {
            array[i] = removeFormattingTokens(array[i])
          }
        }
        return function (mom) {
          var output = '';
          for (i = 0; i < length; i++) {
            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i]
          }
          return output
        }
      }
      // format date using native date object
      function formatMoment(m, format) {
        if (!m.isValid()) {
          return m.localeData().invalidDate()
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m)
      }
      function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1
        }
        return format
      }
      var match1 = /\d/;
      //       0 - 9
      var match2 = /\d\d/;
      //      00 - 99
      var match3 = /\d{3}/;
      //     000 - 999
      var match4 = /\d{4}/;
      //    0000 - 9999
      var match6 = /[+-]?\d{6}/;
      // -999999 - 999999
      var match1to2 = /\d\d?/;
      //       0 - 99
      var match1to3 = /\d{1,3}/;
      //       0 - 999
      var match1to4 = /\d{1,4}/;
      //       0 - 9999
      var match1to6 = /[+-]?\d{1,6}/;
      // -999999 - 999999
      var matchUnsigned = /\d+/;
      //       0 - inf
      var matchSigned = /[+-]?\d+/;
      //    -inf - inf
      var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
      // +00:00 -00:00 +0000 -0000 or Z
      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
      // 123456789 123456789.123
      // any word (or two) characters or numbers including two/three word month in arabic.
      var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
      var regexes = {};
      function isFunction(sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' && Object.prototype.toString.call(sth) === '[object Function]'
      }
      function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
          return isStrict && strictRegex ? strictRegex : regex
        }
      }
      function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token))
        }
        return regexes[token](config._strict, config._locale)
      }
      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
      }
      var tokens = {};
      function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
          token = [token]
        }
        if (typeof callback === 'number') {
          func = function (input, array) {
            array[callback] = toInt(input)
          }
        }
        for (i = 0; i < token.length; i++) {
          tokens[token[i]] = func
        }
      }
      function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token)
        })
      }
      function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token)
        }
      }
      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate()
      }
      // FORMATTING
      addFormatToken('M', [
        'MM',
        2
      ], 'Mo', function () {
        return this.month() + 1
      });
      addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format)
      });
      addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format)
      });
      // ALIASES
      addUnitAlias('month', 'M');
      // PARSING
      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', matchWord);
      addRegexToken('MMMM', matchWord);
      addParseToken([
        'M',
        'MM'
      ], function (input, array) {
        array[MONTH] = toInt(input) - 1
      });
      addParseToken([
        'MMM',
        'MMMM'
      ], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
          array[MONTH] = month
        } else {
          getParsingFlags(config).invalidMonth = input
        }
      });
      // LOCALES
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths(m) {
        return this._months[m.month()]
      }
      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
      function localeMonthsShort(m) {
        return this._monthsShort[m.month()]
      }
      function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = []
        }
        for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = create_utc__createUTC([
            2000,
            i
          ]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i')
          }
          if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i')
          }
          // test the regex
          if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i
          } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i
          }
        }
      }
      // MOMENTS
      function setMonth(mom, value) {
        var dayOfMonth;
        // TODO: Move this out of here!
        if (typeof value === 'string') {
          value = mom.localeData().monthsParse(value);
          // TODO: Another silent failure?
          if (typeof value !== 'number') {
            return mom
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          utils_hooks__hooks.updateOffset(this, true);
          return this
        } else {
          return get_set__get(this, 'Month')
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month())
      }
      function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE
          }
          getParsingFlags(m).overflow = overflow
        }
        return m
      }
      function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
          console.warn('Deprecation warning: ' + msg)
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
          if (firstTime) {
            warn(msg + '\n' + new Error().stack);
            firstTime = false
          }
          return fn.apply(this, arguments)
        }, fn)
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true
        }
      }
      utils_hooks__hooks.suppressDeprecationWarnings = false;
      var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
      var isoDates = [
        [
          'YYYYYY-MM-DD',
          /[+-]\d{6}-\d{2}-\d{2}/
        ],
        [
          'YYYY-MM-DD',
          /\d{4}-\d{2}-\d{2}/
        ],
        [
          'GGGG-[W]WW-E',
          /\d{4}-W\d{2}-\d/
        ],
        [
          'GGGG-[W]WW',
          /\d{4}-W\d{2}/
        ],
        [
          'YYYY-DDD',
          /\d{4}-\d{3}/
        ]
      ];
      // iso time formats and regexes
      var isoTimes = [
        [
          'HH:mm:ss.SSSS',
          /(T| )\d\d:\d\d:\d\d\.\d+/
        ],
        [
          'HH:mm:ss',
          /(T| )\d\d:\d\d:\d\d/
        ],
        [
          'HH:mm',
          /(T| )\d\d:\d\d/
        ],
        [
          'HH',
          /(T| )\d\d/
        ]
      ];
      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
      // date from iso format
      function configFromISO(config) {
        var i, l, string = config._i, match = from_string__isoRegex.exec(string);
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(string)) {
              config._f = isoDates[i][0];
              break
            }
          }
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(string)) {
              // match[6] should be 'T' or space
              config._f += (match[6] || ' ') + isoTimes[i][0];
              break
            }
          }
          if (string.match(matchOffset)) {
            config._f += 'Z'
          }
          configFromStringAndFormat(config)
        } else {
          config._isValid = false
        }
      }
      // date from iso format or fallback
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
          utils_hooks__hooks.createFromInputFallback(config)
        }
      }
      utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'https://github.com/moment/moment/issues/1407 for more info.', function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''))
      });
      function createDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);
        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
          date.setFullYear(y)
        }
        return date
      }
      function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
          date.setUTCFullYear(y)
        }
        return date
      }
      addFormatToken(0, [
        'YY',
        2
      ], 0, function () {
        return this.year() % 100
      });
      addFormatToken(0, [
        'YYYY',
        4
      ], 0, 'year');
      addFormatToken(0, [
        'YYYYY',
        5
      ], 0, 'year');
      addFormatToken(0, [
        'YYYYYY',
        6,
        true
      ], 0, 'year');
      // ALIASES
      addUnitAlias('year', 'y');
      // PARSING
      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);
      addParseToken([
        'YYYYY',
        'YYYYYY'
      ], YEAR);
      addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input)
      });
      addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input)
      });
      // HELPERS
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
      }
      // HOOKS
      utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000)
      };
      // MOMENTS
      var getSetYear = makeGetSet('FullYear', false);
      function getIsLeapYear() {
        return isLeapYear(this.year())
      }
      addFormatToken('w', [
        'ww',
        2
      ], 'wo', 'week');
      addFormatToken('W', [
        'WW',
        2
      ], 'Wo', 'isoWeek');
      // ALIASES
      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');
      // PARSING
      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);
      addWeekParseToken([
        'w',
        'ww',
        'W',
        'WW'
      ], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input)
      });
      // HELPERS
      // firstDayOfWeek       0 = sun, 6 = sat
      //                      the day of the week that starts the week
      //                      (usually sunday or monday)
      // firstDayOfWeekOfYear 0 = sun, 6 = sat
      //                      the first week is the week that contains the first
      //                      of this day of the week
      //                      (eg. ISO weeks use thursday (4))
      function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
          daysToDayOfWeek -= 7
        }
        if (daysToDayOfWeek < end - 7) {
          daysToDayOfWeek += 7
        }
        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
          week: Math.ceil(adjustedMoment.dayOfYear() / 7),
          year: adjustedMoment.year()
        }
      }
      // LOCALES
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6  // The week that contains Jan 1st is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow
      }
      function localeFirstDayOfYear() {
        return this._week.doy
      }
      // MOMENTS
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd')
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd')
      }
      addFormatToken('DDD', [
        'DDDD',
        3
      ], 'DDDo', 'dayOfYear');
      // ALIASES
      addUnitAlias('dayOfYear', 'DDD');
      // PARSING
      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken([
        'DDD',
        'DDDD'
      ], function (input, array, config) {
        config._dayOfYear = toInt(input)
      });
      // HELPERS
      //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
          d += 7
        }
        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;
        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;
        return {
          year: dayOfYear > 0 ? year : year - 1,
          dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        }
      }
      // MOMENTS
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 86400000) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd')
      }
      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
        if (a != null) {
          return a
        }
        if (b != null) {
          return b
        }
        return c
      }
      function currentDateArray(config) {
        var now = new Date;
        if (config._useUTC) {
          return [
            now.getUTCFullYear(),
            now.getUTCMonth(),
            now.getUTCDate()
          ]
        }
        return [
          now.getFullYear(),
          now.getMonth(),
          now.getDate()
        ]
      }
      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
          return
        }
        currentDate = currentDateArray(config);
        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config)
        }
        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse)) {
            getParsingFlags(config)._overflowDayOfYear = true
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate()
        }
        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i]
        }
        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i]
        }
        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm)
        }
        if (config._nextDay) {
          config._a[HOUR] = 24
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          // TODO: We need to take the current isoWeekYear, but that depends on
          // how we interpret now (local, utc, fixed offset). So create
          // a now version of current config (take local/utc/offset flags, and
          // create now).
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1)
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
          week = defaults(w.w, 1);
          if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < dow) {
              ++week
            }
          } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow
          } else {
            // default to begining of week
            weekday = dow
          }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear
      }
      utils_hooks__hooks.ISO_8601 = function () {
      };
      // date from string and format string
      function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
          configFromISO(config);
          return
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped)
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length
          }
          // don't parse if it's not a known token
          if (formatTokenFunctions[token]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false
            } else {
              getParsingFlags(config).unusedTokens.push(token)
            }
            addTimeToArrayFromToken(token, parsedInput, config)
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token)
          }
        }
        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string)
        }
        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = undefined
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config)
      }
      function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
          // nothing to do
          return hour
        }
        if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem)
        } else if (locale.isPM != null) {
          // Fallback
          isPm = locale.isPM(meridiem);
          if (isPm && hour < 12) {
            hour += 12
          }
          if (!isPm && hour === 12) {
            hour = 0
          }
          return hour
        } else {
          // this is not supposed to happen
          return hour
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (!valid__isValid(tempConfig)) {
            continue
          }
          // if there is any input that was not parsed add a penalty for that format
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          //or tokens
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig
          }
        }
        extend(config, bestMoment || tempConfig)
      }
      function configFromObject(config) {
        if (config._d) {
          return
        }
        var i = normalizeObjectUnits(config._i);
        config._a = [
          i.year,
          i.month,
          i.day || i.date,
          i.hour,
          i.minute,
          i.second,
          i.millisecond
        ];
        configFromArray(config)
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          // Adding is smart enough around DST
          res.add(1, 'd');
          res._nextDay = undefined
        }
        return res
      }
      function prepareConfig(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || locale_locales__getLocale(config._l);
        if (input === null || format === undefined && input === '') {
          return valid__createInvalid({ nullInput: true })
        }
        if (typeof input === 'string') {
          config._i = input = config._locale.preparse(input)
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input))
        } else if (isArray(format)) {
          configFromStringAndArray(config)
        } else if (format) {
          configFromStringAndFormat(config)
        } else if (isDate(input)) {
          config._d = input
        } else {
          configFromInput(config)
        }
        return config
      }
      function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
          config._d = new Date
        } else if (isDate(input)) {
          config._d = new Date(+input)
        } else if (typeof input === 'string') {
          configFromString(config)
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10)
          });
          configFromArray(config)
        } else if (typeof input === 'object') {
          configFromObject(config)
        } else if (typeof input === 'number') {
          // from milliseconds
          config._d = new Date(input)
        } else {
          utils_hooks__hooks.createFromInputFallback(config)
        }
      }
      function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (typeof locale === 'boolean') {
          strict = locale;
          locale = undefined
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c)
      }
      function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false)
      }
      var prototypeMin = deprecate('moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548', function () {
        var other = local__createLocal.apply(null, arguments);
        return other < this ? this : other
      });
      var prototypeMax = deprecate('moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548', function () {
        var other = local__createLocal.apply(null, arguments);
        return other > this ? this : other
      });
      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0]
        }
        if (!moments.length) {
          return local__createLocal()
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i]
          }
        }
        return res
      }
      // TODO: Use [].sort instead?
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args)
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args)
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        // representation for dateAddRemove
        this._milliseconds = +milliseconds + seconds * 1000 + // 1000
        minutes * 60000 + // 1000 * 60
        hours * 3600000;
        // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = locale_locales__getLocale();
        this._bubble()
      }
      function isDuration(obj) {
        return obj instanceof Duration
      }
      function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
          var offset = this.utcOffset();
          var sign = '+';
          if (offset < 0) {
            offset = -offset;
            sign = '-'
          }
          return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2)
        })
      }
      offset('Z', ':');
      offset('ZZ', '');
      // PARSING
      addRegexToken('Z', matchOffset);
      addRegexToken('ZZ', matchOffset);
      addParseToken([
        'Z',
        'ZZ'
      ], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input)
      });
      // HELPERS
      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(string) {
        var matches = (string || '').match(matchOffset) || [];
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || [
          '-',
          0,
          0
        ];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === '+' ? minutes : -minutes
      }
      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
          res = model.clone();
          diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - +res;
          // Use low-level api, because this fn is low-level api.
          res._d.setTime(+res._d + diff);
          utils_hooks__hooks.updateOffset(res, false);
          return res
        } else {
          return local__createLocal(input).local()
        }
      }
      function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15
      }
      // HOOKS
      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      utils_hooks__hooks.updateOffset = function () {
      };
      // MOMENTS
      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0, localAdjust;
        if (input != null) {
          if (typeof input === 'string') {
            input = offsetFromString(input)
          }
          if (Math.abs(input) < 16) {
            input = input * 60
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this)
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, 'm')
          }
          if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false)
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              utils_hooks__hooks.updateOffset(this, true);
              this._changeInProgress = null
            }
          }
          return this
        } else {
          return this._isUTC ? offset : getDateOffset(this)
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== 'string') {
            input = -input
          }
          this.utcOffset(input, keepLocalTime);
          return this
        } else {
          return -this.utcOffset()
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime)
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm')
          }
        }
        return this
      }
      function setOffsetToParsedOffset() {
        if (this._tzm) {
          this.utcOffset(this._tzm)
        } else if (typeof this._i === 'string') {
          this.utcOffset(offsetFromString(this._i))
        }
        return this
      }
      function hasAlignedHourOffset(input) {
        input = input ? local__createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
      }
      function isDaylightSavingTimeShifted() {
        if (typeof this._isDSTShifted !== 'undefined') {
          return this._isDSTShifted
        }
        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0
        } else {
          this._isDSTShifted = false
        }
        return this._isDSTShifted
      }
      function isLocal() {
        return !this._isUTC
      }
      function isUtcOffset() {
        return this._isUTC
      }
      function isUtc() {
        return this._isUTC && this._offset === 0
      }
      var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
      function create__createDuration(input, key) {
        var duration = input,
          // matching against regexp is expensive, do it on demand
          match = null, sign, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          }
        } else if (typeof input === 'number') {
          duration = {};
          if (key) {
            duration[key] = input
          } else {
            duration.milliseconds = input
          }
        } else if (!!(match = aspNetRegex.exec(input))) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(match[MILLISECOND]) * sign
          }
        } else if (!!(match = create__isoRegex.exec(input))) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            d: parseIso(match[4], sign),
            h: parseIso(match[5], sign),
            m: parseIso(match[6], sign),
            s: parseIso(match[7], sign),
            w: parseIso(match[8], sign)
          }
        } else if (duration == null) {
          // checks for null or undefined
          duration = {}
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
          diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
          ret._locale = input._locale
        }
        return ret
      }
      create__createDuration.fn = Duration.prototype;
      function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign
      }
      function positiveMomentsDifference(base, other) {
        var res = {
          milliseconds: 0,
          months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
          --res.months
        }
        res.milliseconds = +other - +base.clone().add(res.months, 'M');
        return res
      }
      function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other)
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months
        }
        return res
      }
      function createAdder(direction, name) {
        return function (val, period) {
          var dur, tmp;
          //invert the arguments, but complain about it
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
            tmp = val;
            val = period;
            period = tmp
          }
          val = typeof val === 'string' ? +val : val;
          dur = create__createDuration(val, period);
          add_subtract__addSubtract(this, dur, direction);
          return this
        }
      }
      function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
          mom._d.setTime(+mom._d + milliseconds * isAdding)
        }
        if (days) {
          get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding)
        }
        if (months) {
          setMonth(mom, get_set__get(mom, 'Month') + months * isAdding)
        }
        if (updateOffset) {
          utils_hooks__hooks.updateOffset(mom, days || months)
        }
      }
      var add_subtract__add = createAdder(1, 'add');
      var add_subtract__subtract = createAdder(-1, 'subtract');
      function moment_calendar__calendar(time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(), sod = cloneWithOffset(now, this).startOf('day'), diff = this.diff(sod, 'days', true), format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)))
      }
      function clone() {
        return new Moment(this)
      }
      function isAfter(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
          input = isMoment(input) ? input : local__createLocal(input);
          return +this > +input
        } else {
          inputMs = isMoment(input) ? +input : +local__createLocal(input);
          return inputMs < +this.clone().startOf(units)
        }
      }
      function isBefore(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
          input = isMoment(input) ? input : local__createLocal(input);
          return +this < +input
        } else {
          inputMs = isMoment(input) ? +input : +local__createLocal(input);
          return +this.clone().endOf(units) < inputMs
        }
      }
      function isBetween(from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units)
      }
      function isSame(input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
          input = isMoment(input) ? input : local__createLocal(input);
          return +this === +input
        } else {
          inputMs = +local__createLocal(input);
          return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units)
        }
      }
      function diff(input, units, asFloat) {
        var that = cloneWithOffset(input, this), zoneDelta = (that.utcOffset() - this.utcOffset()) * 60000, delta, output;
        units = normalizeUnits(units);
        if (units === 'year' || units === 'month' || units === 'quarter') {
          output = monthDiff(this, that);
          if (units === 'quarter') {
            output = output / 3
          } else if (units === 'year') {
            output = output / 12
          }
        } else {
          delta = this - that;
          output = units === 'second' ? delta / 1000 : // 1000
          units === 'minute' ? delta / 60000 : // 1000 * 60
          units === 'hour' ? delta / 3600000 : // 1000 * 60 * 60
          units === 'day' ? (delta - zoneDelta) / 86400000 : // 1000 * 60 * 60 * 24, negate dst
          units === 'week' ? (delta - zoneDelta) / 604800000 : // 1000 * 60 * 60 * 24 * 7, negate dst
          delta
        }
        return asFloat ? output : absFloor(output)
      }
      function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
          anchor = a.clone().add(wholeMonthDiff, 'months'), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor - anchor2)
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor2 - anchor)
        }
        return -(wholeMonthDiff + adjust)
      }
      utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ')
      }
      function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
          if ('function' === typeof Date.prototype.toISOString) {
            // native implementation is ~50x faster, use it when we can
            return this.toDate().toISOString()
          } else {
            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]')
          }
        } else {
          return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]')
        }
      }
      function format(inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output)
      }
      function from(time, withoutSuffix) {
        if (!this.isValid()) {
          return this.localeData().invalidDate()
        }
        return create__createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix)
      }
      function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix)
      }
      function to(time, withoutSuffix) {
        if (!this.isValid()) {
          return this.localeData().invalidDate()
        }
        return create__createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix)
      }
      function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix)
      }
      function locale(key) {
        var newLocaleData;
        if (key === undefined) {
          return this._locale._abbr
        } else {
          newLocaleData = locale_locales__getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData
          }
          return this
        }
      }
      var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
        if (key === undefined) {
          return this.localeData()
        } else {
          return this.locale(key)
        }
      });
      function localeData() {
        return this._locale
      }
      function startOf(units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
          this.month(0);
        /* falls through */
        case 'quarter':
        case 'month':
          this.date(1);
        /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
          this.hours(0);
        /* falls through */
        case 'hour':
          this.minutes(0);
        /* falls through */
        case 'minute':
          this.seconds(0);
        /* falls through */
        case 'second':
          this.milliseconds(0)
        }
        // weeks are a special case
        if (units === 'week') {
          this.weekday(0)
        }
        if (units === 'isoWeek') {
          this.isoWeekday(1)
        }
        // quarters are also special
        if (units === 'quarter') {
          this.month(Math.floor(this.month() / 3) * 3)
        }
        return this
      }
      function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
          return this
        }
        return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms')
      }
      function to_type__valueOf() {
        return +this._d - (this._offset || 0) * 60000
      }
      function unix() {
        return Math.floor(+this / 1000)
      }
      function toDate() {
        return this._offset ? new Date(+this) : this._d
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ]
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        }
      }
      function moment_valid__isValid() {
        return valid__isValid(this)
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this))
      }
      function invalidAt() {
        return getParsingFlags(this).overflow
      }
      addFormatToken(0, [
        'gg',
        2
      ], 0, function () {
        return this.weekYear() % 100
      });
      addFormatToken(0, [
        'GG',
        2
      ], 0, function () {
        return this.isoWeekYear() % 100
      });
      function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [
          token,
          token.length
        ], 0, getter)
      }
      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');
      // ALIASES
      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');
      // PARSING
      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);
      addWeekParseToken([
        'gggg',
        'ggggg',
        'GGGG',
        'GGGGG'
      ], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input)
      });
      addWeekParseToken([
        'gg',
        'GG'
      ], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input)
      });
      // HELPERS
      function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([
          year,
          11,
          31 + dow - doy
        ]), dow, doy).week
      }
      // MOMENTS
      function getSetWeekYear(input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add(input - year, 'y')
      }
      function getSetISOWeekYear(input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add(input - year, 'y')
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4)
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy)
      }
      addFormatToken('Q', 0, 0, 'quarter');
      // ALIASES
      addUnitAlias('quarter', 'Q');
      // PARSING
      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3
      });
      // MOMENTS
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3)
      }
      addFormatToken('D', [
        'DD',
        2
      ], 'Do', 'date');
      // ALIASES
      addUnitAlias('date', 'D');
      // PARSING
      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient
      });
      addParseToken([
        'D',
        'DD'
      ], DATE);
      addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10)
      });
      // MOMENTS
      var getSetDayOfMonth = makeGetSet('Date', true);
      addFormatToken('d', 0, 'do', 'day');
      addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format)
      });
      addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format)
      });
      addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format)
      });
      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');
      // ALIASES
      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');
      // PARSING
      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', matchWord);
      addRegexToken('ddd', matchWord);
      addRegexToken('dddd', matchWord);
      addWeekParseToken([
        'dd',
        'ddd',
        'dddd'
      ], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
          week.d = weekday
        } else {
          getParsingFlags(config).invalidWeekday = input
        }
      });
      addWeekParseToken([
        'd',
        'e',
        'E'
      ], function (input, week, config, token) {
        week[token] = toInt(input)
      });
      // HELPERS
      function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
          return input
        }
        if (!isNaN(input)) {
          return parseInt(input, 10)
        }
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
          return input
        }
        return null
      }
      // LOCALES
      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays(m) {
        return this._weekdays[m.day()]
      }
      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort(m) {
        return this._weekdaysShort[m.day()]
      }
      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin(m) {
        return this._weekdaysMin[m.day()]
      }
      function localeWeekdaysParse(weekdayName) {
        var i, mom, regex;
        this._weekdaysParse = this._weekdaysParse || [];
        for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already
          if (!this._weekdaysParse[i]) {
            mom = local__createLocal([
              2000,
              1
            ]).day(i);
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i')
          }
          // test the regex
          if (this._weekdaysParse[i].test(weekdayName)) {
            return i
          }
        }
      }
      // MOMENTS
      function getSetDayOfWeek(input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, 'd')
        } else {
          return day
        }
      }
      function getSetLocaleDayOfWeek(input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd')
      }
      function getSetISODayOfWeek(input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7)
      }
      addFormatToken('H', [
        'HH',
        2
      ], 0, 'hour');
      addFormatToken('h', [
        'hh',
        2
      ], 0, function () {
        return this.hours() % 12 || 12
      });
      function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase)
        })
      }
      meridiem('a', true);
      meridiem('A', false);
      // ALIASES
      addUnitAlias('hour', 'h');
      // PARSING
      function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse
      }
      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addParseToken([
        'H',
        'HH'
      ], HOUR);
      addParseToken([
        'a',
        'A'
      ], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input
      });
      addParseToken([
        'h',
        'hh'
      ], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true
      });
      // LOCALES
      function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p'
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
          return isLower ? 'pm' : 'PM'
        } else {
          return isLower ? 'am' : 'AM'
        }
      }
      // MOMENTS
      // Setting the hour should keep the time, because the user explicitly
      // specified which hour he wants. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.
      var getSetHour = makeGetSet('Hours', true);
      addFormatToken('m', [
        'mm',
        2
      ], 0, 'minute');
      // ALIASES
      addUnitAlias('minute', 'm');
      // PARSING
      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken([
        'm',
        'mm'
      ], MINUTE);
      // MOMENTS
      var getSetMinute = makeGetSet('Minutes', false);
      addFormatToken('s', [
        'ss',
        2
      ], 0, 'second');
      // ALIASES
      addUnitAlias('second', 's');
      // PARSING
      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken([
        's',
        'ss'
      ], SECOND);
      // MOMENTS
      var getSetSecond = makeGetSet('Seconds', false);
      addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100)
      });
      addFormatToken(0, [
        'SS',
        2
      ], 0, function () {
        return ~~(this.millisecond() / 10)
      });
      addFormatToken(0, [
        'SSS',
        3
      ], 0, 'millisecond');
      addFormatToken(0, [
        'SSSS',
        4
      ], 0, function () {
        return this.millisecond() * 10
      });
      addFormatToken(0, [
        'SSSSS',
        5
      ], 0, function () {
        return this.millisecond() * 100
      });
      addFormatToken(0, [
        'SSSSSS',
        6
      ], 0, function () {
        return this.millisecond() * 1000
      });
      addFormatToken(0, [
        'SSSSSSS',
        7
      ], 0, function () {
        return this.millisecond() * 10000
      });
      addFormatToken(0, [
        'SSSSSSSS',
        8
      ], 0, function () {
        return this.millisecond() * 100000
      });
      addFormatToken(0, [
        'SSSSSSSSS',
        9
      ], 0, function () {
        return this.millisecond() * 1000000
      });
      // ALIASES
      addUnitAlias('millisecond', 'ms');
      // PARSING
      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);
      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned)
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000)
      }
      for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs)
      }
      // MOMENTS
      var getSetMillisecond = makeGetSet('Milliseconds', false);
      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');
      // MOMENTS
      function getZoneAbbr() {
        return this._isUTC ? 'UTC' : ''
      }
      function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : ''
      }
      var momentPrototype__proto = Moment.prototype;
      momentPrototype__proto.add = add_subtract__add;
      momentPrototype__proto.calendar = moment_calendar__calendar;
      momentPrototype__proto.clone = clone;
      momentPrototype__proto.diff = diff;
      momentPrototype__proto.endOf = endOf;
      momentPrototype__proto.format = format;
      momentPrototype__proto.from = from;
      momentPrototype__proto.fromNow = fromNow;
      momentPrototype__proto.to = to;
      momentPrototype__proto.toNow = toNow;
      momentPrototype__proto.get = getSet;
      momentPrototype__proto.invalidAt = invalidAt;
      momentPrototype__proto.isAfter = isAfter;
      momentPrototype__proto.isBefore = isBefore;
      momentPrototype__proto.isBetween = isBetween;
      momentPrototype__proto.isSame = isSame;
      momentPrototype__proto.isValid = moment_valid__isValid;
      momentPrototype__proto.lang = lang;
      momentPrototype__proto.locale = locale;
      momentPrototype__proto.localeData = localeData;
      momentPrototype__proto.max = prototypeMax;
      momentPrototype__proto.min = prototypeMin;
      momentPrototype__proto.parsingFlags = parsingFlags;
      momentPrototype__proto.set = getSet;
      momentPrototype__proto.startOf = startOf;
      momentPrototype__proto.subtract = add_subtract__subtract;
      momentPrototype__proto.toArray = toArray;
      momentPrototype__proto.toObject = toObject;
      momentPrototype__proto.toDate = toDate;
      momentPrototype__proto.toISOString = moment_format__toISOString;
      momentPrototype__proto.toJSON = moment_format__toISOString;
      momentPrototype__proto.toString = toString;
      momentPrototype__proto.unix = unix;
      momentPrototype__proto.valueOf = to_type__valueOf;
      // Year
      momentPrototype__proto.year = getSetYear;
      momentPrototype__proto.isLeapYear = getIsLeapYear;
      // Week Year
      momentPrototype__proto.weekYear = getSetWeekYear;
      momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
      // Quarter
      momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
      // Month
      momentPrototype__proto.month = getSetMonth;
      momentPrototype__proto.daysInMonth = getDaysInMonth;
      // Week
      momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
      momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
      momentPrototype__proto.weeksInYear = getWeeksInYear;
      momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
      // Day
      momentPrototype__proto.date = getSetDayOfMonth;
      momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
      momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
      momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
      momentPrototype__proto.dayOfYear = getSetDayOfYear;
      // Hour
      momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
      // Minute
      momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
      // Second
      momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
      // Millisecond
      momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
      // Offset
      momentPrototype__proto.utcOffset = getSetOffset;
      momentPrototype__proto.utc = setOffsetToUTC;
      momentPrototype__proto.local = setOffsetToLocal;
      momentPrototype__proto.parseZone = setOffsetToParsedOffset;
      momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
      momentPrototype__proto.isDST = isDaylightSavingTime;
      momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
      momentPrototype__proto.isLocal = isLocal;
      momentPrototype__proto.isUtcOffset = isUtcOffset;
      momentPrototype__proto.isUtc = isUtc;
      momentPrototype__proto.isUTC = isUtc;
      // Timezone
      momentPrototype__proto.zoneAbbr = getZoneAbbr;
      momentPrototype__proto.zoneName = getZoneName;
      // Deprecations
      momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
      var momentPrototype = momentPrototype__proto;
      function moment__createUnix(input) {
        return local__createLocal(input * 1000)
      }
      function moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone()
      }
      var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
      };
      function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output
      }
      var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
      };
      function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
          return format
        }
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
          return val.slice(1)
        });
        return this._longDateFormat[key]
      }
      var defaultInvalidDate = 'Invalid date';
      function invalidDate() {
        return this._invalidDate
      }
      var defaultOrdinal = '%d';
      var defaultOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace('%d', number)
      }
      function preParsePostFormat(string) {
        return string
      }
      var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
      };
      function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return typeof output === 'function' ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
      }
      function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output)
      }
      function locale_set__set(config) {
        var prop, i;
        for (i in config) {
          prop = config[i];
          if (typeof prop === 'function') {
            this[i] = prop
          } else {
            this['_' + i] = prop
          }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source)
      }
      var prototype__proto = Locale.prototype;
      prototype__proto._calendar = defaultCalendar;
      prototype__proto.calendar = locale_calendar__calendar;
      prototype__proto._longDateFormat = defaultLongDateFormat;
      prototype__proto.longDateFormat = longDateFormat;
      prototype__proto._invalidDate = defaultInvalidDate;
      prototype__proto.invalidDate = invalidDate;
      prototype__proto._ordinal = defaultOrdinal;
      prototype__proto.ordinal = ordinal;
      prototype__proto._ordinalParse = defaultOrdinalParse;
      prototype__proto.preparse = preParsePostFormat;
      prototype__proto.postformat = preParsePostFormat;
      prototype__proto._relativeTime = defaultRelativeTime;
      prototype__proto.relativeTime = relative__relativeTime;
      prototype__proto.pastFuture = pastFuture;
      prototype__proto.set = locale_set__set;
      // Month
      prototype__proto.months = localeMonths;
      prototype__proto._months = defaultLocaleMonths;
      prototype__proto.monthsShort = localeMonthsShort;
      prototype__proto._monthsShort = defaultLocaleMonthsShort;
      prototype__proto.monthsParse = localeMonthsParse;
      // Week
      prototype__proto.week = localeWeek;
      prototype__proto._week = defaultLocaleWeek;
      prototype__proto.firstDayOfYear = localeFirstDayOfYear;
      prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
      // Day of Week
      prototype__proto.weekdays = localeWeekdays;
      prototype__proto._weekdays = defaultLocaleWeekdays;
      prototype__proto.weekdaysMin = localeWeekdaysMin;
      prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
      prototype__proto.weekdaysShort = localeWeekdaysShort;
      prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
      prototype__proto.weekdaysParse = localeWeekdaysParse;
      // Hours
      prototype__proto.isPM = localeIsPM;
      prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
      prototype__proto.meridiem = localeMeridiem;
      function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format)
      }
      function list(format, index, field, count, setter) {
        if (typeof format === 'number') {
          index = format;
          format = undefined
        }
        format = format || '';
        if (index != null) {
          return lists__get(format, index, field, setter)
        }
        var i;
        var out = [];
        for (i = 0; i < count; i++) {
          out[i] = lists__get(format, i, field, setter)
        }
        return out
      }
      function lists__listMonths(format, index) {
        return list(format, index, 'months', 12, 'month')
      }
      function lists__listMonthsShort(format, index) {
        return list(format, index, 'monthsShort', 12, 'month')
      }
      function lists__listWeekdays(format, index) {
        return list(format, index, 'weekdays', 7, 'day')
      }
      function lists__listWeekdaysShort(format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day')
      }
      function lists__listWeekdaysMin(format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day')
      }
      locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output
        }
      });
      // Side effect imports
      utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
      utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
      var mathAbs = Math.abs;
      function duration_abs__abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this
      }
      function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble()
      }
      // supports only 2.0-style add(1, 's') or add(duration)
      function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1)
      }
      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1)
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number)
        } else {
          return Math.ceil(number)
        }
      }
      function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;
        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
          milliseconds += absCeil(monthsToDays(months) + days) * 86400000;
          days = 0;
          months = 0
        }
        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;
        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this
      }
      function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097
      }
      function monthsToDays(months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800
      }
      function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === 'month' || units === 'year') {
          days = this._days + milliseconds / 86400000;
          months = this._months + daysToMonths(days);
          return units === 'month' ? months : months / 12
        } else {
          // handle milliseconds separately because of floating point math errors (issue #1867)
          days = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
          case 'week':
            return days / 7 + milliseconds / 604800000;
          case 'day':
            return days + milliseconds / 86400000;
          case 'hour':
            return days * 24 + milliseconds / 3600000;
          case 'minute':
            return days * 1440 + milliseconds / 60000;
          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here
          case 'millisecond':
            return Math.floor(days * 86400000) + milliseconds;
          default:
            throw new Error('Unknown unit ' + units)
          }
        }
      }
      // TODO: Use this.as('ms')?
      function duration_as__valueOf() {
        return this._milliseconds + this._days * 86400000 + this._months % 12 * 2592000000 + toInt(this._months / 12) * 31536000000
      }
      function makeAs(alias) {
        return function () {
          return this.as(alias)
        }
      }
      var asMilliseconds = makeAs('ms');
      var asSeconds = makeAs('s');
      var asMinutes = makeAs('m');
      var asHours = makeAs('h');
      var asDays = makeAs('d');
      var asWeeks = makeAs('w');
      var asMonths = makeAs('M');
      var asYears = makeAs('y');
      function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + 's']()
      }
      function makeGetter(name) {
        return function () {
          return this._data[name]
        }
      }
      var milliseconds = makeGetter('milliseconds');
      var seconds = makeGetter('seconds');
      var minutes = makeGetter('minutes');
      var hours = makeGetter('hours');
      var days = makeGetter('days');
      var months = makeGetter('months');
      var years = makeGetter('years');
      function weeks() {
        return absFloor(this.days() / 7)
      }
      var round = Math.round;
      var thresholds = {
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month
        M: 11  // months to year
      };
      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
      }
      function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));
        var a = seconds < thresholds.s && [
          's',
          seconds
        ] || minutes === 1 && ['m'] || minutes < thresholds.m && [
          'mm',
          minutes
        ] || hours === 1 && ['h'] || hours < thresholds.h && [
          'hh',
          hours
        ] || days === 1 && ['d'] || days < thresholds.d && [
          'dd',
          days
        ] || months === 1 && ['M'] || months < thresholds.M && [
          'MM',
          months
        ] || years === 1 && ['y'] || [
          'yy',
          years
        ];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a)
      }
      // This function allows you to set a threshold for relative time strings
      function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
          return false
        }
        if (limit === undefined) {
          return thresholds[threshold]
        }
        thresholds[threshold] = limit;
        return true
      }
      function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
        if (withSuffix) {
          output = locale.pastFuture(+this, output)
        }
        return locale.postformat(output)
      }
      var iso_string__abs = Math.abs;
      function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days = iso_string__abs(this._days);
        var months = iso_string__abs(this._months);
        var minutes, hours, years;
        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;
        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();
        if (!total) {
          // this is the same as C#'s (Noda) and python (isodate)...
          // but not other JS (goog.date)
          return 'P0D'
        }
        return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '')
      }
      var duration_prototype__proto = Duration.prototype;
      duration_prototype__proto.abs = duration_abs__abs;
      duration_prototype__proto.add = duration_add_subtract__add;
      duration_prototype__proto.subtract = duration_add_subtract__subtract;
      duration_prototype__proto.as = as;
      duration_prototype__proto.asMilliseconds = asMilliseconds;
      duration_prototype__proto.asSeconds = asSeconds;
      duration_prototype__proto.asMinutes = asMinutes;
      duration_prototype__proto.asHours = asHours;
      duration_prototype__proto.asDays = asDays;
      duration_prototype__proto.asWeeks = asWeeks;
      duration_prototype__proto.asMonths = asMonths;
      duration_prototype__proto.asYears = asYears;
      duration_prototype__proto.valueOf = duration_as__valueOf;
      duration_prototype__proto._bubble = bubble;
      duration_prototype__proto.get = duration_get__get;
      duration_prototype__proto.milliseconds = milliseconds;
      duration_prototype__proto.seconds = seconds;
      duration_prototype__proto.minutes = minutes;
      duration_prototype__proto.hours = hours;
      duration_prototype__proto.days = days;
      duration_prototype__proto.weeks = weeks;
      duration_prototype__proto.months = months;
      duration_prototype__proto.years = years;
      duration_prototype__proto.humanize = humanize;
      duration_prototype__proto.toISOString = iso_string__toISOString;
      duration_prototype__proto.toString = iso_string__toISOString;
      duration_prototype__proto.toJSON = iso_string__toISOString;
      duration_prototype__proto.locale = locale;
      duration_prototype__proto.localeData = localeData;
      // Deprecations
      duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
      duration_prototype__proto.lang = lang;
      // Side effect imports
      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');
      // PARSING
      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000)
      });
      addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input))
      });
      // Side effect imports
      utils_hooks__hooks.version = '2.10.6';
      setHookCallback(local__createLocal);
      utils_hooks__hooks.fn = momentPrototype;
      utils_hooks__hooks.min = min;
      utils_hooks__hooks.max = max;
      utils_hooks__hooks.utc = create_utc__createUTC;
      utils_hooks__hooks.unix = moment__createUnix;
      utils_hooks__hooks.months = lists__listMonths;
      utils_hooks__hooks.isDate = isDate;
      utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
      utils_hooks__hooks.invalid = valid__createInvalid;
      utils_hooks__hooks.duration = create__createDuration;
      utils_hooks__hooks.isMoment = isMoment;
      utils_hooks__hooks.weekdays = lists__listWeekdays;
      utils_hooks__hooks.parseZone = moment__createInZone;
      utils_hooks__hooks.localeData = locale_locales__getLocale;
      utils_hooks__hooks.isDuration = isDuration;
      utils_hooks__hooks.monthsShort = lists__listMonthsShort;
      utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
      utils_hooks__hooks.defineLocale = defineLocale;
      utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
      utils_hooks__hooks.normalizeUnits = normalizeUnits;
      utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
      var _moment = utils_hooks__hooks;
      return _moment
    }))
  });
  // source: assets/js/dash/site/index.coffee
  rqzt.define('./site', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      crumbs: rqzt('./site/crumbs'),
      menu: rqzt('./site/menu'),
      Router: rqzt('./site/router'),
      pages: rqzt('./site/pages')
    }
  });
  // source: assets/js/dash/site/crumbs.coffee
  rqzt.define('./site/crumbs', function (module, exports, __dirname, __filename, process) {
    var Crumbs, Router, View, _id, activePage, crowdcontrol, pages, riot, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    riot = rqzt('riot/riot');
    crowdcontrol = rqzt('crowdcontrol/lib');
    pages = rqzt('./site/pages');
    Router = rqzt('./site/router');
    View = crowdcontrol.view.View;
    activePage = pages.Dashboard;
    _id = '';
    Crumbs = function (superClass) {
      extend(Crumbs, superClass);
      function Crumbs() {
        return Crumbs.__super__.constructor.apply(this, arguments)
      }
      Crumbs.prototype.tag = 'crumbs';
      Crumbs.prototype.html = rqzt('./templates/dash/site/crumbs');
      Crumbs.prototype.js = function () {
        Crumbs.__super__.js.apply(this, arguments);
        return requestAnimationFrame(function () {
          var e, ref;
          try {
            return typeof window !== 'undefined' && window !== null ? (ref = window.Core) != null ? ref.init() : void 0 : void 0
          } catch (error) {
            e = error;
            return e
          }
        })
      };
      Crumbs.prototype.setActiveId = function (id) {
        return _id = id
      };
      Crumbs.prototype.getActiveId = function () {
        return _id
      };
      Crumbs.setActiveId = function (id) {
        return _id = id
      };
      Crumbs.getActiveId = function () {
        return _id
      };
      Crumbs.prototype.setActive = function (p) {
        activePage = p;
        return this.update()
      };
      Crumbs.prototype.getActive = function () {
        return activePage
      };
      Crumbs.setActive = function (p) {
        activePage = p;
        return riot.update()
      };
      Crumbs.getActive = function () {
        return activePage
      };
      return Crumbs
    }(View);
    Crumbs.register();
    module.exports = Router.Crumbs = Crumbs
  });
  // source: assets/js/dash/site/pages/index.coffee
  rqzt.define('./site/pages', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      Dashboard: rqzt('./site/pages/dashboard'),
      User: rqzt('./site/pages/user'),
      Users: rqzt('./site/pages/users'),
      Order: rqzt('./site/pages/order'),
      Orders: rqzt('./site/pages/orders'),
      Payment: rqzt('./site/pages/payment'),
      Payments: rqzt('./site/pages/payments'),
      Product: rqzt('./site/pages/product'),
      Products: rqzt('./site/pages/products'),
      Coupon: rqzt('./site/pages/coupon'),
      Coupons: rqzt('./site/pages/coupons'),
      Store: rqzt('./site/pages/store'),
      Stores: rqzt('./site/pages/stores'),
      MailingList: rqzt('./site/pages/mailinglist'),
      MailingLists: rqzt('./site/pages/mailinglists'),
      Subscriber: rqzt('./site/pages/subscriber'),
      Subscribers: rqzt('./site/pages/subscribers'),
      Profile: rqzt('./site/pages/profile'),
      Api: rqzt('./site/pages/api'),
      Organization: rqzt('./site/pages/organization'),
      Integrations: rqzt('./site/pages/integrations'),
      Search: rqzt('./site/pages/search')
    }
  });
  // source: assets/js/dash/site/pages/dashboard.coffee
  rqzt.define('./site/pages/dashboard', function (module, exports, __dirname, __filename, process) {
    var Api, Dashboard, Events, Page, capitalize, crowdcontrol, currencyModel, lastDayInMonth, promise, riot, store, util, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    promise = rqzt('bluebird/js/browser/bluebird');
    riot = rqzt('riot/riot');
    util = rqzt('./util');
    store = rqzt('store/store');
    Page = rqzt('./site/pages/page');
    capitalize = function (str) {
      return str.charAt(0).toUpperCase() + str.slice(1)
    };
    lastDayInMonth = function () {
      var date;
      date = new Date;
      return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
    };
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    Api = crowdcontrol.data.Api;
    currencyModel = {
      name: 'currency',
      value: ''
    };
    Dashboard = function (superClass) {
      var obj;
      extend(Dashboard, superClass);
      function Dashboard() {
        return Dashboard.__super__.constructor.apply(this, arguments)
      }
      Dashboard.prototype.tag = 'page-dashboard';
      Dashboard.prototype.icon = 'glyphicon glyphicon-home';
      Dashboard.prototype.name = 'Dashboard';
      Dashboard.prototype.html = rqzt('./templates/dash/site/pages/dashboard');
      Dashboard.prototype.collection = '';
      Dashboard.prototype.percent = 0;
      Dashboard.prototype.events = (obj = {}, obj['' + Events.Input.Change] = function (name, value) {
        switch (name) {
        case 'period':
          this.periodModel.value = value;
          store.set('periodModelValue', value);
          break;
        case 'date':
          this.periodDateModel.value = value
        }
        return this.refresh()
      }, obj);
      Dashboard.prototype.chartModel = {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Sales',
              data: [],
              pointBorderColor: '#1BE7FF',
              pointBackgroundColor: 'C0F8FF',
              borderColor: '#1BE7FF',
              yAxisID: 'Currency'
            },
            {
              label: 'Orders',
              data: [],
              pointBorderColor: '#6EEB83',
              pointBackgroundColor: '#D7F9DD',
              borderColor: '#6EEB83',
              yAxisID: 'Count'
            },
            {
              label: 'Users',
              data: [],
              pointBorderColor: '#FF5714',
              pointBackgroundColor: '#FFD1BE',
              borderColor: '#FF5714',
              yAxisID: 'Count'
            }
          ]
        },
        options: {
          scales: {
            xAxes: [{
                type: 'category',
                position: 'bottom'
              }],
            yAxes: [
              {
                id: 'Currency',
                type: 'linear',
                position: 'left',
                ticks: {
                  beginAtZero: true,
                  callback: function (value) {
                    var ret, v;
                    v = parseInt(value * 100, 10) / 100;
                    ret = '' + util.currency.getSymbol(currencyModel.value) + v;
                    if (currencyModel.value) {
                      ret += ' (' + currencyModel.value.toUpperCase() + ')'
                    }
                    return ret
                  }
                },
                scaleLabel: {
                  display: true,
                  labelString: 'Revenue'
                }
              },
              {
                id: 'Count',
                type: 'linear',
                position: 'right',
                ticks: { beginAtZero: true },
                scaleLabel: {
                  display: true,
                  labelString: 'Amount'
                }
              }
            ]
          },
          responsive: false
        }
      };
      Dashboard.prototype.currencyModel = {
        name: 'currency',
        value: null
      };
      Dashboard.prototype.periodModel = {
        name: 'period',
        value: 'week'
      };
      Dashboard.prototype.periodDateModel = {
        name: 'date',
        value: ''
      };
      Dashboard.prototype.currencyOptions = {};
      Dashboard.prototype.periodOptions = {
        week: 'Week',
        month: 'Month',
        dai: 'Day'
      };
      Dashboard.prototype.periodDescription = function () {
        return capitalize(this.periodModel.value) + 'ly'
      };
      Dashboard.prototype.periodLabel = function () {
        return 'THIS ' + (this.periodModel.value === 'dai' ? 'DAY' : this.periodModel.value.toUpperCase())
      };
      Dashboard.prototype.js = function (opts) {
        var api, date, day, month, period, year;
        this.chartObs = {};
        riot.observable(this.chartObs);
        this.totalOrdersObs = {};
        this.totalSalesObs = {};
        this.totalUsersObs = {};
        this.totalSubsObs = {};
        riot.observable(this.totalOrdersObs);
        riot.observable(this.totalSalesObs);
        riot.observable(this.totalUsersObs);
        riot.observable(this.totalSubsObs);
        this.dailyOrdersObs = {};
        this.dailySalesObs = {};
        this.dailyUsersObs = {};
        this.dailySubsObs = {};
        riot.observable(this.dailyOrdersObs);
        riot.observable(this.dailySalesObs);
        riot.observable(this.dailyUsersObs);
        riot.observable(this.dailySubsObs);
        date = new Date;
        year = date.getFullYear();
        month = date.getMonth() + 1;
        day = date.getDate();
        period = store.get('periodModelValue');
        if (period) {
          this.periodModel.value = period
        }
        this.periodDateModel.value = month + '/' + day + '/' + year;
        this.api = api = Api.get('crowdstart');
        this.on('update', function (_this) {
          return function () {
            return _this.updateCurrency()
          }
        }(this));
        return this.refresh()
      };
      Dashboard.prototype.refresh = function () {
        var categories, compareDay, compareMonth, compareYear, d, d1, d2, date, day, daysInMonth, j, month, period, ref, tz, year;
        period = this.periodModel.value;
        date = new Date(this.periodDateModel.value);
        compareYear = year = date.getFullYear();
        compareMonth = month = date.getMonth() + 1;
        compareDay = day = date.getDate();
        this.percent = 1;
        switch (period) {
        case 'dai':
          compareDay -= 1;
          d1 = new Date;
          if (d1.getFullYear() === date.getFullYear() && d1.getMonth() === date.getMonth() && d1.getDate() === date.getDate()) {
            d2 = new Date(d1.getFullYear(), d1.getMonth(), d1.getDate(), 0, 0, 0);
            this.percent = (d1.getTime() - d2.getTime()) / 86400000
          }
          this.chartModel.data.labels = [
            '00:00',
            '01:00',
            '02:00',
            '03:00',
            '04:00',
            '05:00',
            '06:00',
            '07:00',
            '08:00',
            '09:00',
            '10:00',
            '11:00',
            '12:00',
            '13:00',
            '14:00',
            '15:00',
            '16:00',
            '17:00',
            '18:00',
            '19:00',
            '20:00',
            '21:00',
            '22:00',
            '23:00'
          ];
          break;
        case 'week':
          d1 = new Date;
          if (d1.getFullYear() === date.getFullYear() && d1.getMonth() === date.getMonth() && d1.getDate() === date.getDate()) {
            this.percent = (date.getDay() + 1) / 7
          }
          compareDay -= 7;
          this.chartModel.data.labels = [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
          ];
          break;
        case 'month':
          daysInMonth = lastDayInMonth();
          categories = [];
          for (d = j = 1, ref = daysInMonth; 1 <= ref ? j <= ref : j >= ref; d = 1 <= ref ? ++j : --j) {
            categories.push(month + '/' + d)
          }
          this.chartModel.data.labels = categories;
          d1 = new Date;
          if (d1.getFullYear() === date.getFullYear() && d1.getMonth() === date.getMonth()) {
            this.percent = day / daysInMonth
          }
          compareMonth -= 1
        }
        tz = -date.getTimezoneOffset() / 60;
        return promise.settle([
          this.api.get('c/data/dashboard/' + period + 'ly/' + compareYear + '/' + compareMonth + '/' + compareDay + '/' + tz).then(function (_this) {
            return function (res) {
              _this.compareModel = res.responseText;
              if (res.status !== 200 && res.status !== 201 && res.status !== 204) {
                throw new Error('Form failed to load: ')
              }
            }
          }(this)),
          this.api.get('c/data/dashboard/' + period + 'ly/' + year + '/' + month + '/' + day + '/' + tz).then(function (_this) {
            return function (res) {
              _this.model = res.responseText;
              if (res.status !== 200 && res.status !== 201 && res.status !== 204) {
                throw new Error('Form failed to load: ')
              }
            }
          }(this))
        ]).then(function (_this) {
          return function (rets) {
            var cents, currency, i, l, largestCents, len, len1, len2, m, n, orders, ref1, ref2, ref3, ref4, ref5, subs, totalCompareOrders, totalCompareSubs, totalCompareUsers, totalOrders, totalSubs, totalUsers, users;
            currencyModel = _this.currencyModel;
            _this.currencyCount = 0;
            ref1 = _this.model.TotalSales;
            for (currency in ref1) {
              cents = ref1[currency];
              _this.currencyOptions[currency.toLowerCase()] = currency.toUpperCase();
              _this.currencyCount += 1
            }
            largestCents = 0;
            if (_this.currencyModel.value == null) {
              ref2 = _this.model.TotalSales;
              for (currency in ref2) {
                cents = ref2[currency];
                if (cents > largestCents && currency !== '') {
                  _this.currencyModel.value = currency;
                  largestCents = cents
                }
              }
              if (_this.currencyModel.value === '') {
                Dashboard.__super__.refresh.call(_this, 0, 0, _this.currencyModel.value);
                return
              }
            }
            totalOrders = 0;
            totalCompareOrders = 0;
            ref3 = _this.model.DailyOrders;
            for (i = l = 0, len = ref3.length; l < len; i = ++l) {
              orders = ref3[i];
              totalOrders += orders;
              totalCompareOrders += _this.compareModel.DailyOrders[i]
            }
            totalUsers = 0;
            totalCompareUsers = 0;
            ref4 = _this.model.DailyUsers;
            for (i = m = 0, len1 = ref4.length; m < len1; i = ++m) {
              users = ref4[i];
              totalUsers += users;
              totalCompareUsers += _this.compareModel.DailyUsers[i]
            }
            totalSubs = 0;
            totalCompareSubs = 0;
            ref5 = _this.model.DailySubscribers;
            for (i = n = 0, len2 = ref5.length; n < len2; i = ++n) {
              subs = ref5[i];
              totalSubs += subs;
              totalCompareSubs += _this.compareModel.DailySubscribers[i]
            }
            _this.totalOrdersObs.trigger(Events.Visual.NewData, _this.model.TotalOrders, 0 / 0);
            _this.dailyOrdersObs.trigger(Events.Visual.NewData, totalOrders, totalCompareOrders * _this.percent);
            _this.dailyUsersObs.trigger(Events.Visual.NewData, totalUsers, totalCompareUsers * _this.percent);
            _this.dailySubsObs.trigger(Events.Visual.NewData, totalSubs, totalCompareSubs * _this.percent);
            _this.dailyOrdersObs.trigger(Events.Visual.NewDescription, _this.periodDescription() + ' Orders');
            _this.dailySalesObs.trigger(Events.Visual.NewDescription, _this.periodDescription() + ' Sales');
            _this.dailyUsersObs.trigger(Events.Visual.NewDescription, _this.periodDescription() + ' Sign-ups');
            _this.dailySubsObs.trigger(Events.Visual.NewDescription, _this.periodDescription() + ' Subscribers');
            _this.dailyOrdersObs.trigger(Events.Visual.NewLabel, _this.periodLabel());
            _this.dailySalesObs.trigger(Events.Visual.NewLabel, _this.periodLabel());
            _this.dailyUsersObs.trigger(Events.Visual.NewLabel, _this.periodLabel());
            _this.dailySubsObs.trigger(Events.Visual.NewLabel, _this.periodLabel());
            return _this.update()
          }
        }(this))['catch'](function (_this) {
          return function (e) {
            console.log(e.stack);
            return _this.error = e
          }
        }(this))
      };
      Dashboard.prototype.updateCurrency = function () {
        var cents, currency, i, j, k, len, ordersXY, ref, ref1, ref2, ref3, sales, salesXY, totalCents, totalCompareCents, usersXY, v, values;
        if (this.model.DailySales != null) {
          totalCents = {};
          totalCompareCents = {};
          ref = this.model.DailySales;
          for (currency in ref) {
            values = ref[currency];
            totalCents[currency] = 0;
            totalCompareCents[currency] = 0;
            for (i = j = 0, len = values.length; j < len; i = ++j) {
              cents = values[i];
              totalCents[currency] += cents;
              if (this.compareModel.DailySales[currency] != null) {
                totalCompareCents[currency] += this.compareModel.DailySales[currency][i]
              }
            }
          }
          this.dailySalesObs.trigger(Events.Visual.NewData, totalCents[this.currencyModel.value], totalCompareCents[this.currencyModel.value] * this.percent, this.currencyModel.value)
        }
        if (((ref1 = this.model.TotalSales) != null ? ref1[this.currencyModel.value] : void 0) != null) {
          this.totalSalesObs.trigger(Events.Visual.NewData, this.model.TotalSales[this.currencyModel.value], 0 / 0, this.currencyModel.value)
        }
        if (this.model.TotalUsers != null) {
          this.totalUsersObs.trigger(Events.Visual.NewData, this.model.TotalUsers, 0 / 0)
        }
        if (this.model.TotalSubs != null) {
          this.totalSubsObs.trigger(Events.Visual.NewData, this.model.TotalSubs, 0 / 0)
        }
        if (this.model.DailySales != null && this.model.DailyOrders != null) {
          sales = this.model.DailySales[this.currencyModel.value];
          if (sales != null) {
            sales = this.model.DailySales[this.currencyModel.value].map(function (val) {
              return val / 100
            })
          } else {
            sales = this.model.DailyOrders.map(function (val) {
              return 0
            })
          }
          salesXY = [];
          for (k in sales) {
            v = sales[k];
            i = parseInt(k, 10);
            salesXY[i] = {
              x: i,
              y: v
            }
          }
          ordersXY = [];
          ref2 = this.model.DailyOrders;
          for (k in ref2) {
            v = ref2[k];
            i = parseInt(k, 10);
            ordersXY[i] = {
              x: i,
              y: v
            }
          }
          usersXY = [];
          ref3 = this.model.DailyUsers;
          for (k in ref3) {
            v = ref3[k];
            i = parseInt(k, 10);
            usersXY[i] = {
              x: i,
              y: v
            }
          }
          this.chartModel.data.datasets[0].data = salesXY;
          this.chartModel.data.datasets[1].data = ordersXY;
          this.chartModel.data.datasets[2].data = usersXY;
          return this.chartObs.trigger(Events.Visual.NewData, this.chartModel)
        }
      };
      return Dashboard
    }(Page);
    Dashboard.register();
    module.exports = Dashboard
  });
  // source: assets/js/dash/util/index.coffee
  rqzt.define('./util', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      currency: rqzt('./util/currency'),
      country: rqzt('./util/country')
    }
  });
  // source: assets/js/dash/util/currency.coffee
  rqzt.define('./util/currency', function (module, exports, __dirname, __filename, process) {
    var Util, _, currencySeparator, currencySigns, digitsOnlyRe, humanize, isZeroDecimal;
    _ = rqzt('underscore/underscore');
    humanize = rqzt('humanize/humanize');
    currencySigns = rqzt('./util/data/currencies');
    currencySeparator = '.';
    digitsOnlyRe = new RegExp('[^\\d.-]', 'g');
    isZeroDecimal = function (code) {
      if (code === 'bif' || code === 'clp' || code === 'djf' || code === 'gnf' || code === 'jpy' || code === 'kmf' || code === 'krw' || code === 'mga' || code === 'pyg' || code === 'rwf' || code === 'vnd' || code === 'vuv' || code === 'xaf' || code === 'xof' || code === 'xpf') {
        return true
      }
      return false
    };
    module.exports = Util = {
      getSymbol: function (code) {
        return currencySigns[code] || ''
      },
      renderUpdatedUICurrency: function (code, uiCurrency) {
        return Util.renderUICurrencyFromJSON(code, Util.renderJSONCurrencyFromUI(code, uiCurrency))
      },
      renderUICurrencyFromJSON: function (code, jsonCurrency) {
        var currentCurrencySign;
        if (isNaN(jsonCurrency)) {
          jsonCurrency = 0
        }
        currentCurrencySign = currencySigns[code] || '';
        jsonCurrency = '' + jsonCurrency;
        if (isZeroDecimal(code)) {
          return currentCurrencySign + jsonCurrency
        }
        while (jsonCurrency.length < 3) {
          jsonCurrency = '0' + jsonCurrency
        }
        return currentCurrencySign + humanize.numberFormat(jsonCurrency.substr(0, jsonCurrency.length - 2), 0) + '.' + jsonCurrency.substr(-2)
      },
      renderJSONCurrencyFromUI: function (code, uiCurrency) {
        var parts;
        if (_.isNumber(uiCurrency)) {
          return uiCurrency
        }
        if (isZeroDecimal(code)) {
          return parseInt(('' + uiCurrency).replace(digitsOnlyRe, '').replace(currencySeparator, ''), 10)
        }
        parts = uiCurrency.split(currencySeparator);
        if (parts.length > 1) {
          parts[1] = parts[1].substr(0, 2);
          while (parts[1].length < 2) {
            parts[1] += '0'
          }
        } else {
          parts[1] = '00'
        }
        return parseInt(parseFloat(parts[0].replace(digitsOnlyRe, '')) * 100 + parseFloat(parts[1].replace(digitsOnlyRe, '')), 10)
      }
    }
  });
  // source: node_modules/humanize/humanize.js
  rqzt.define('humanize/humanize', function (module, exports, __dirname, __filename, process) {
    (function () {
      // Baseline setup
      // --------------
      // Establish the root object, `window` in the browser, or `global` on the server.
      var root = this;
      // Save the previous value of the `humanize` variable.
      var previousHumanize = root.humanize;
      var humanize = {};
      if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = humanize
        }
        exports.humanize = humanize
      } else {
        if (typeof define === 'function' && define.amd) {
          define('humanize', function () {
            return humanize
          })
        }
        root.humanize = humanize
      }
      humanize.noConflict = function () {
        root.humanize = previousHumanize;
        return this
      };
      humanize.pad = function (str, count, padChar, type) {
        str += '';
        if (!padChar) {
          padChar = ' '
        } else if (padChar.length > 1) {
          padChar = padChar.charAt(0)
        }
        type = type === undefined ? 'left' : 'right';
        if (type === 'right') {
          while (str.length < count) {
            str = str + padChar
          }
        } else {
          // default to left
          while (str.length < count) {
            str = padChar + str
          }
        }
        return str
      };
      // gets current unix time
      humanize.time = function () {
        return new Date().getTime() / 1000
      };
      /**
   * PHP-inspired date
   */
      /*  jan  feb  mar  apr  may  jun  jul  aug  sep  oct  nov  dec */
      var dayTableCommon = [
        0,
        0,
        31,
        59,
        90,
        120,
        151,
        181,
        212,
        243,
        273,
        304,
        334
      ];
      var dayTableLeap = [
        0,
        0,
        31,
        60,
        91,
        121,
        152,
        182,
        213,
        244,
        274,
        305,
        335
      ];
      // var mtable_common[13] = {  0,  31,  28,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31 };
      // static int ml_table_leap[13]   = {  0,  31,  29,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31 };
      humanize.date = function (format, timestamp) {
        var jsdate = timestamp === undefined ? new Date : // Not provided
        timestamp instanceof Date ? new Date(timestamp) : // JS Date()
        new Date(timestamp * 1000)  // UNIX timestamp (auto-convert to int)
;
        var formatChr = /\\?([a-z])/gi;
        var formatChrCb = function (t, s) {
          return f[t] ? f[t]() : s
        };
        var shortDayTxt = [
          'Sunday',
          'Monday',
          'Tuesday',
          'Wednesday',
          'Thursday',
          'Friday',
          'Saturday'
        ];
        var monthTxt = [
          'January',
          'February',
          'March',
          'April',
          'May',
          'June',
          'July',
          'August',
          'September',
          'October',
          'November',
          'December'
        ];
        var f = {
          /* Day */
          // Day of month w/leading 0; 01..31
          d: function () {
            return humanize.pad(f.j(), 2, '0')
          },
          // Shorthand day name; Mon..Sun
          D: function () {
            return f.l().slice(0, 3)
          },
          // Day of month; 1..31
          j: function () {
            return jsdate.getDate()
          },
          // Full day name; Monday..Sunday
          l: function () {
            return shortDayTxt[f.w()]
          },
          // ISO-8601 day of week; 1[Mon]..7[Sun]
          N: function () {
            return f.w() || 7
          },
          // Ordinal suffix for day of month; st, nd, rd, th
          S: function () {
            var j = f.j();
            return j > 4 && j < 21 ? 'th' : {
              1: 'st',
              2: 'nd',
              3: 'rd'
            }[j % 10] || 'th'
          },
          // Day of week; 0[Sun]..6[Sat]
          w: function () {
            return jsdate.getDay()
          },
          // Day of year; 0..365
          z: function () {
            return (f.L() ? dayTableLeap[f.n()] : dayTableCommon[f.n()]) + f.j() - 1
          },
          /* Week */
          // ISO-8601 week number
          W: function () {
            // days between midweek of this week and jan 4
            // (f.z() - f.N() + 1 + 3.5) - 3
            var midWeekDaysFromJan4 = f.z() - f.N() + 1.5;
            // 1 + number of weeks + rounded week
            return humanize.pad(1 + Math.floor(Math.abs(midWeekDaysFromJan4) / 7) + (midWeekDaysFromJan4 % 7 > 3.5 ? 1 : 0), 2, '0')
          },
          /* Month */
          // Full month name; January..December
          F: function () {
            return monthTxt[jsdate.getMonth()]
          },
          // Month w/leading 0; 01..12
          m: function () {
            return humanize.pad(f.n(), 2, '0')
          },
          // Shorthand month name; Jan..Dec
          M: function () {
            return f.F().slice(0, 3)
          },
          // Month; 1..12
          n: function () {
            return jsdate.getMonth() + 1
          },
          // Days in month; 28..31
          t: function () {
            return new Date(f.Y(), f.n(), 0).getDate()
          },
          /* Year */
          // Is leap year?; 0 or 1
          L: function () {
            return new Date(f.Y(), 1, 29).getMonth() === 1 ? 1 : 0
          },
          // ISO-8601 year
          o: function () {
            var n = f.n();
            var W = f.W();
            return f.Y() + (n === 12 && W < 9 ? -1 : n === 1 && W > 9)
          },
          // Full year; e.g. 1980..2010
          Y: function () {
            return jsdate.getFullYear()
          },
          // Last two digits of year; 00..99
          y: function () {
            return String(f.Y()).slice(-2)
          },
          /* Time */
          // am or pm
          a: function () {
            return jsdate.getHours() > 11 ? 'pm' : 'am'
          },
          // AM or PM
          A: function () {
            return f.a().toUpperCase()
          },
          // Swatch Internet time; 000..999
          B: function () {
            var unixTime = jsdate.getTime() / 1000;
            var secondsPassedToday = unixTime % 86400 + 3600;
            // since it's based off of UTC+1
            if (secondsPassedToday < 0) {
              secondsPassedToday += 86400
            }
            var beats = secondsPassedToday / 86.4 % 1000;
            if (unixTime < 0) {
              return Math.ceil(beats)
            }
            return Math.floor(beats)
          },
          // 12-Hours; 1..12
          g: function () {
            return f.G() % 12 || 12
          },
          // 24-Hours; 0..23
          G: function () {
            return jsdate.getHours()
          },
          // 12-Hours w/leading 0; 01..12
          h: function () {
            return humanize.pad(f.g(), 2, '0')
          },
          // 24-Hours w/leading 0; 00..23
          H: function () {
            return humanize.pad(f.G(), 2, '0')
          },
          // Minutes w/leading 0; 00..59
          i: function () {
            return humanize.pad(jsdate.getMinutes(), 2, '0')
          },
          // Seconds w/leading 0; 00..59
          s: function () {
            return humanize.pad(jsdate.getSeconds(), 2, '0')
          },
          // Microseconds; 000000-999000
          u: function () {
            return humanize.pad(jsdate.getMilliseconds() * 1000, 6, '0')
          },
          // Whether or not the date is in daylight savings time
          /*
      I: function () {
        // Compares Jan 1 minus Jan 1 UTC to Jul 1 minus Jul 1 UTC.
        // If they are not equal, then DST is observed.
        var Y = f.Y();
        return 0 + ((new Date(Y, 0) - Date.UTC(Y, 0)) !== (new Date(Y, 6) - Date.UTC(Y, 6)));
      },
      */
          // Difference to GMT in hour format; e.g. +0200
          O: function () {
            var tzo = jsdate.getTimezoneOffset();
            var tzoNum = Math.abs(tzo);
            return (tzo > 0 ? '-' : '+') + humanize.pad(Math.floor(tzoNum / 60) * 100 + tzoNum % 60, 4, '0')
          },
          // Difference to GMT w/colon; e.g. +02:00
          P: function () {
            var O = f.O();
            return O.substr(0, 3) + ':' + O.substr(3, 2)
          },
          // Timezone offset in seconds (-43200..50400)
          Z: function () {
            return -jsdate.getTimezoneOffset() * 60
          },
          // Full Date/Time, ISO-8601 date
          c: function () {
            return 'Y-m-d\\TH:i:sP'.replace(formatChr, formatChrCb)
          },
          // RFC 2822
          r: function () {
            return 'D, d M Y H:i:s O'.replace(formatChr, formatChrCb)
          },
          // Seconds since UNIX epoch
          U: function () {
            return jsdate.getTime() / 1000 || 0
          }
        };
        return format.replace(formatChr, formatChrCb)
      };
      /**
   * format number by adding thousands separaters and significant digits while rounding
   */
      humanize.numberFormat = function (number, decimals, decPoint, thousandsSep) {
        decimals = isNaN(decimals) ? 2 : Math.abs(decimals);
        decPoint = decPoint === undefined ? '.' : decPoint;
        thousandsSep = thousandsSep === undefined ? ',' : thousandsSep;
        var sign = number < 0 ? '-' : '';
        number = Math.abs(+number || 0);
        var intPart = parseInt(number.toFixed(decimals), 10) + '';
        var j = intPart.length > 3 ? intPart.length % 3 : 0;
        return sign + (j ? intPart.substr(0, j) + thousandsSep : '') + intPart.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep) + (decimals ? decPoint + Math.abs(number - intPart).toFixed(decimals).slice(2) : '')
      };
      /**
   * For dates that are the current day or within one day, return 'today', 'tomorrow' or 'yesterday', as appropriate.
   * Otherwise, format the date using the passed in format string.
   *
   * Examples (when 'today' is 17 Feb 2007):
   * 16 Feb 2007 becomes yesterday.
   * 17 Feb 2007 becomes today.
   * 18 Feb 2007 becomes tomorrow.
   * Any other day is formatted according to given argument or the DATE_FORMAT setting if no argument is given.
   */
      humanize.naturalDay = function (timestamp, format) {
        timestamp = timestamp === undefined ? humanize.time() : timestamp;
        format = format === undefined ? 'Y-m-d' : format;
        var oneDay = 86400;
        var d = new Date;
        var today = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime() / 1000;
        if (timestamp < today && timestamp >= today - oneDay) {
          return 'yesterday'
        } else if (timestamp >= today && timestamp < today + oneDay) {
          return 'today'
        } else if (timestamp >= today + oneDay && timestamp < today + 2 * oneDay) {
          return 'tomorrow'
        }
        return humanize.date(format, timestamp)
      };
      /**
   * returns a string representing how many seconds, minutes or hours ago it was or will be in the future
   * Will always return a relative time, most granular of seconds to least granular of years. See unit tests for more details
   */
      humanize.relativeTime = function (timestamp) {
        timestamp = timestamp === undefined ? humanize.time() : timestamp;
        var currTime = humanize.time();
        var timeDiff = currTime - timestamp;
        // within 2 seconds
        if (timeDiff < 2 && timeDiff > -2) {
          return (timeDiff >= 0 ? 'just ' : '') + 'now'
        }
        // within a minute
        if (timeDiff < 60 && timeDiff > -60) {
          return timeDiff >= 0 ? Math.floor(timeDiff) + ' seconds ago' : 'in ' + Math.floor(-timeDiff) + ' seconds'
        }
        // within 2 minutes
        if (timeDiff < 120 && timeDiff > -120) {
          return timeDiff >= 0 ? 'about a minute ago' : 'in about a minute'
        }
        // within an hour
        if (timeDiff < 3600 && timeDiff > -3600) {
          return timeDiff >= 0 ? Math.floor(timeDiff / 60) + ' minutes ago' : 'in ' + Math.floor(-timeDiff / 60) + ' minutes'
        }
        // within 2 hours
        if (timeDiff < 7200 && timeDiff > -7200) {
          return timeDiff >= 0 ? 'about an hour ago' : 'in about an hour'
        }
        // within 24 hours
        if (timeDiff < 86400 && timeDiff > -86400) {
          return timeDiff >= 0 ? Math.floor(timeDiff / 3600) + ' hours ago' : 'in ' + Math.floor(-timeDiff / 3600) + ' hours'
        }
        // within 2 days
        var days2 = 2 * 86400;
        if (timeDiff < days2 && timeDiff > -days2) {
          return timeDiff >= 0 ? '1 day ago' : 'in 1 day'
        }
        // within 29 days
        var days29 = 29 * 86400;
        if (timeDiff < days29 && timeDiff > -days29) {
          return timeDiff >= 0 ? Math.floor(timeDiff / 86400) + ' days ago' : 'in ' + Math.floor(-timeDiff / 86400) + ' days'
        }
        // within 60 days
        var days60 = 60 * 86400;
        if (timeDiff < days60 && timeDiff > -days60) {
          return timeDiff >= 0 ? 'about a month ago' : 'in about a month'
        }
        var currTimeYears = parseInt(humanize.date('Y', currTime), 10);
        var timestampYears = parseInt(humanize.date('Y', timestamp), 10);
        var currTimeMonths = currTimeYears * 12 + parseInt(humanize.date('n', currTime), 10);
        var timestampMonths = timestampYears * 12 + parseInt(humanize.date('n', timestamp), 10);
        // within a year
        var monthDiff = currTimeMonths - timestampMonths;
        if (monthDiff < 12 && monthDiff > -12) {
          return monthDiff >= 0 ? monthDiff + ' months ago' : 'in ' + -monthDiff + ' months'
        }
        var yearDiff = currTimeYears - timestampYears;
        if (yearDiff < 2 && yearDiff > -2) {
          return yearDiff >= 0 ? 'a year ago' : 'in a year'
        }
        return yearDiff >= 0 ? yearDiff + ' years ago' : 'in ' + -yearDiff + ' years'
      };
      /**
   * Converts an integer to its ordinal as a string.
   *
   * 1 becomes 1st
   * 2 becomes 2nd
   * 3 becomes 3rd etc
   */
      humanize.ordinal = function (number) {
        number = parseInt(number, 10);
        number = isNaN(number) ? 0 : number;
        var sign = number < 0 ? '-' : '';
        number = Math.abs(number);
        var tens = number % 100;
        return sign + number + (tens > 4 && tens < 21 ? 'th' : {
          1: 'st',
          2: 'nd',
          3: 'rd'
        }[number % 10] || 'th')
      };
      /**
   * Formats the value like a 'human-readable' file size (i.e. '13 KB', '4.1 MB', '102 bytes', etc).
   *
   * For example:
   * If value is 123456789, the output would be 117.7 MB.
   */
      humanize.filesize = function (filesize, kilo, decimals, decPoint, thousandsSep, suffixSep) {
        kilo = kilo === undefined ? 1024 : kilo;
        if (filesize <= 0) {
          return '0 bytes'
        }
        if (filesize < kilo && decimals === undefined) {
          decimals = 0
        }
        if (suffixSep === undefined) {
          suffixSep = ' '
        }
        return humanize.intword(filesize, [
          'bytes',
          'KB',
          'MB',
          'GB',
          'TB',
          'PB'
        ], kilo, decimals, decPoint, thousandsSep, suffixSep)
      };
      /**
   * Formats the value like a 'human-readable' number (i.e. '13 K', '4.1 M', '102', etc).
   *
   * For example:
   * If value is 123456789, the output would be 117.7 M.
   */
      humanize.intword = function (number, units, kilo, decimals, decPoint, thousandsSep, suffixSep) {
        var humanized, unit;
        units = units || [
          '',
          'K',
          'M',
          'B',
          'T'
        ], unit = units.length - 1, kilo = kilo || 1000, decimals = isNaN(decimals) ? 2 : Math.abs(decimals), decPoint = decPoint || '.', thousandsSep = thousandsSep || ',', suffixSep = suffixSep || '';
        for (var i = 0; i < units.length; i++) {
          if (number < Math.pow(kilo, i + 1)) {
            unit = i;
            break
          }
        }
        humanized = number / Math.pow(kilo, unit);
        var suffix = units[unit] ? suffixSep + units[unit] : '';
        return humanize.numberFormat(humanized, decimals, decPoint, thousandsSep) + suffix
      };
      /**
   * Replaces line breaks in plain text with appropriate HTML
   * A single newline becomes an HTML line break (<br />) and a new line followed by a blank line becomes a paragraph break (</p>).
   * 
   * For example:
   * If value is Joel\nis a\n\nslug, the output will be <p>Joel<br />is a</p><p>slug</p>
   */
      humanize.linebreaks = function (str) {
        // remove beginning and ending newlines
        str = str.replace(/^([\n|\r]*)/, '');
        str = str.replace(/([\n|\r]*)$/, '');
        // normalize all to \n
        str = str.replace(/(\r\n|\n|\r)/g, '\n');
        // any consecutive new lines more than 2 gets turned into p tags
        str = str.replace(/(\n{2,})/g, '</p><p>');
        // any that are singletons get turned into br
        str = str.replace(/\n/g, '<br />');
        return '<p>' + str + '</p>'
      };
      /**
   * Converts all newlines in a piece of plain text to HTML line breaks (<br />).
   */
      humanize.nl2br = function (str) {
        return str.replace(/(\r\n|\n|\r)/g, '<br />')
      };
      /**
   * Truncates a string if it is longer than the specified number of characters.
   * Truncated strings will end with a translatable ellipsis sequence ('…').
   */
      humanize.truncatechars = function (string, length) {
        if (string.length <= length) {
          return string
        }
        return string.substr(0, length) + '…'
      };
      /**
   * Truncates a string after a certain number of words.
   * Newlines within the string will be removed.
   */
      humanize.truncatewords = function (string, numWords) {
        var words = string.split(' ');
        if (words.length < numWords) {
          return string
        }
        return words.slice(0, numWords).join(' ') + '…'
      }
    }.call(this))
  });
  // source: assets/js/dash/util/data/currencies.coffee
  rqzt.define('./util/data/currencies', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      'aud': '$',
      'cad': '$',
      'eur': '€',
      'gbp': '£',
      'hkd': '$',
      'jpy': '¥',
      'nzd': '$',
      'sgd': '$',
      'usd': '$',
      'ghc': '¢',
      'ars': '$',
      'bsd': '$',
      'bbd': '$',
      'bmd': '$',
      'bnd': '$',
      'kyd': '$',
      'clp': '$',
      'cop': '$',
      'xcd': '$',
      'svc': '$',
      'fjd': '$',
      'gyd': '$',
      'lrd': '$',
      'mxn': '$',
      'nad': '$',
      'sbd': '$',
      'srd': '$',
      'tvd': '$',
      'bob': '$b',
      'uyu': '$u',
      'egp': '£',
      'fkp': '£',
      'gip': '£',
      'ggp': '£',
      'imp': '£',
      'jep': '£',
      'lbp': '£',
      'shp': '£',
      'syp': '£',
      'cny': '¥',
      'afn': '؋',
      'thb': '฿',
      'khr': '៛',
      'crc': '₡',
      'trl': '₤',
      'ngn': '₦',
      'kpw': '₩',
      'krw': '₩',
      'ils': '₪',
      'vnd': '₫',
      'lak': '₭',
      'mnt': '₮',
      'cup': '₱',
      'php': '₱',
      'uah': '₴',
      'mur': '₨',
      'npr': '₨',
      'pkr': '₨',
      'scr': '₨',
      'lkr': '₨',
      'irr': '﷼',
      'omr': '﷼',
      'qar': '﷼',
      'sar': '﷼',
      'yer': '﷼',
      'pab': 'b/.',
      'vef': 'bs',
      'bzd': 'bz$',
      'nio': 'c$',
      'chf': 'chf',
      'huf': 'ft',
      'awg': 'ƒ',
      'ang': 'ƒ',
      'pyg': 'gs',
      'jmd': 'j$',
      'czk': 'kč',
      'bam': 'km',
      'hrk': 'kn',
      'dkk': 'kr',
      'eek': 'kr',
      'isk': 'kr',
      'nok': 'kr',
      'sek': 'kr',
      'hnl': 'l',
      'ron': 'lei',
      'all': 'lek',
      'lvl': 'ls',
      'ltl': 'lt',
      'mzn': 'mt',
      'twd': 'nt$',
      'bwp': 'p',
      'byr': 'p.',
      'gtq': 'q',
      'zar': 'r',
      'brl': 'r$',
      'dop': 'rd$',
      'myr': 'rm',
      'idr': 'rp',
      'sos': 's',
      'pen': 's/.',
      'ttd': 'tt$',
      'zwd': 'z$',
      'pln': 'zł',
      'mkd': 'ден',
      'rsd': 'Дин.',
      'bgn': 'лв',
      'kzt': 'лв',
      'kgs': 'лв',
      'uzs': 'лв',
      'azn': 'ман',
      'rub': 'руб',
      'inr': '',
      'try': '',
      'points': '',
      '': ''
    }
  });
  // source: assets/js/dash/util/country.coffee
  rqzt.define('./util/country', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      requiresPostalCode: function (code) {
        code = code.toLowerCase();
        return code === 'dz' || code === 'ar' || code === 'am' || code === 'au' || code === 'at' || code === 'az' || code === 'a2' || code === 'bd' || code === 'by' || code === 'be' || code === 'ba' || code === 'br' || code === 'bn' || code === 'bg' || code === 'ca' || code === 'ic' || code === 'cn' || code === 'hr' || code === 'cy' || code === 'cz' || code === 'dk' || code === 'en' || code === 'ee' || code === 'fo' || code === 'fi' || code === 'fr' || code === 'ge' || code === 'de' || code === 'gr' || code === 'gl' || code === 'gu' || code === 'gg' || code === 'ho' || code === 'hu' || code === 'in' || code === 'id' || code === 'il' || code === 'it' || code === 'jp' || code === 'je' || code === 'kz' || code === 'kr' || code === 'ko' || code === 'kg' || code === 'lv' || code === 'li' || code === 'lt' || code === 'lu' || code === 'mk' || code === 'mg' || code === 'm3' || code === 'my' || code === 'mh' || code === 'mq' || code === 'yt' || code === 'mx' || code === 'mn' || code === 'me' || code === 'nl' || code === 'nz' || code === 'nb' || code === 'no' || code === 'pk' || code === 'ph' || code === 'pl' || code === 'po' || code === 'pt' || code === 'pr' || code === 're' || code === 'ru' || code === 'sa' || code === 'sf' || code === 'cs' || code === 'sg' || code === 'sk' || code === 'si' || code === 'za' || code === 'es' || code === 'lk' || code === 'nt' || code === 'sx' || code === 'uv' || code === 'vl' || code === 'se' || code === 'ch' || code === 'tw' || code === 'tj' || code === 'th' || code === 'tu' || code === 'tn' || code === 'tr' || code === 'tm' || code === 'vi' || code === 'ua' || code === 'gb' || code === 'us' || code === 'uy' || code === 'uz' || code === 'va' || code === 'vn' || code === 'wl' || code === 'ya'
      }
    }
  });
  // source: node_modules/store/store.js
  rqzt.define('store/store', function (module, exports, __dirname, __filename, process) {
    ;
    (function (win) {
      var store = {}, doc = win.document, localStorageName = 'localStorage', scriptTag = 'script', storage;
      store.disabled = false;
      store.version = '1.3.17';
      store.set = function (key, value) {
      };
      store.get = function (key, defaultVal) {
      };
      store.has = function (key) {
        return store.get(key) !== undefined
      };
      store.remove = function (key) {
      };
      store.clear = function () {
      };
      store.transact = function (key, defaultVal, transactionFn) {
        if (transactionFn == null) {
          transactionFn = defaultVal;
          defaultVal = null
        }
        if (defaultVal == null) {
          defaultVal = {}
        }
        var val = store.get(key, defaultVal);
        transactionFn(val);
        store.set(key, val)
      };
      store.getAll = function () {
      };
      store.forEach = function () {
      };
      store.serialize = function (value) {
        return JSON.stringify(value)
      };
      store.deserialize = function (value) {
        if (typeof value != 'string') {
          return undefined
        }
        try {
          return JSON.parse(value)
        } catch (e) {
          return value || undefined
        }
      };
      // Functions to encapsulate questionable FireFox 3.6.13 behavior
      // when about.config::dom.storage.enabled === false
      // See https://github.com/marcuswestin/store.js/issues#issue/13
      function isLocalStorageNameSupported() {
        try {
          return localStorageName in win && win[localStorageName]
        } catch (err) {
          return false
        }
      }
      if (isLocalStorageNameSupported()) {
        storage = win[localStorageName];
        store.set = function (key, val) {
          if (val === undefined) {
            return store.remove(key)
          }
          storage.setItem(key, store.serialize(val));
          return val
        };
        store.get = function (key, defaultVal) {
          var val = store.deserialize(storage.getItem(key));
          return val === undefined ? defaultVal : val
        };
        store.remove = function (key) {
          storage.removeItem(key)
        };
        store.clear = function () {
          storage.clear()
        };
        store.getAll = function () {
          var ret = {};
          store.forEach(function (key, val) {
            ret[key] = val
          });
          return ret
        };
        store.forEach = function (callback) {
          for (var i = 0; i < storage.length; i++) {
            var key = storage.key(i);
            callback(key, store.get(key))
          }
        }
      } else if (doc.documentElement.addBehavior) {
        var storageOwner, storageContainer;
        // Since #userData storage applies only to specific paths, we need to
        // somehow link our data to a specific path.  We choose /favicon.ico
        // as a pretty safe option, since all browsers already make a request to
        // this URL anyway and being a 404 will not hurt us here.  We wrap an
        // iframe pointing to the favicon in an ActiveXObject(htmlfile) object
        // (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
        // since the iframe access rules appear to allow direct access and
        // manipulation of the document element, even for a 404 page.  This
        // document can be used instead of the current document (which would
        // have been limited to the current path) to perform #userData storage.
        try {
          storageContainer = new ActiveXObject('htmlfile');
          storageContainer.open();
          storageContainer.write('<' + scriptTag + '>document.w=window</' + scriptTag + '><iframe src="/favicon.ico"></iframe>');
          storageContainer.close();
          storageOwner = storageContainer.w.frames[0].document;
          storage = storageOwner.createElement('div')
        } catch (e) {
          // somehow ActiveXObject instantiation failed (perhaps some special
          // security settings or otherwse), fall back to per-path storage
          storage = doc.createElement('div');
          storageOwner = doc.body
        }
        var withIEStorage = function (storeFunction) {
          return function () {
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift(storage);
            // See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
            // and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
            storageOwner.appendChild(storage);
            storage.addBehavior('#default#userData');
            storage.load(localStorageName);
            var result = storeFunction.apply(store, args);
            storageOwner.removeChild(storage);
            return result
          }
        };
        // In IE7, keys cannot start with a digit or contain certain chars.
        // See https://github.com/marcuswestin/store.js/issues/40
        // See https://github.com/marcuswestin/store.js/issues/83
        var forbiddenCharsRegex = new RegExp('[!"#$%&\'()*+,/\\\\:;<=>?@[\\]^`{|}~]', 'g');
        function ieKeyFix(key) {
          return key.replace(/^d/, '___$&').replace(forbiddenCharsRegex, '___')
        }
        store.set = withIEStorage(function (storage, key, val) {
          key = ieKeyFix(key);
          if (val === undefined) {
            return store.remove(key)
          }
          storage.setAttribute(key, store.serialize(val));
          storage.save(localStorageName);
          return val
        });
        store.get = withIEStorage(function (storage, key, defaultVal) {
          key = ieKeyFix(key);
          var val = store.deserialize(storage.getAttribute(key));
          return val === undefined ? defaultVal : val
        });
        store.remove = withIEStorage(function (storage, key) {
          key = ieKeyFix(key);
          storage.removeAttribute(key);
          storage.save(localStorageName)
        });
        store.clear = withIEStorage(function (storage) {
          var attributes = storage.XMLDocument.documentElement.attributes;
          storage.load(localStorageName);
          for (var i = 0, attr; attr = attributes[i]; i++) {
            storage.removeAttribute(attr.name)
          }
          storage.save(localStorageName)
        });
        store.getAll = function (storage) {
          var ret = {};
          store.forEach(function (key, val) {
            ret[key] = val
          });
          return ret
        };
        store.forEach = withIEStorage(function (storage, callback) {
          var attributes = storage.XMLDocument.documentElement.attributes;
          for (var i = 0, attr; attr = attributes[i]; ++i) {
            callback(attr.name, store.deserialize(storage.getAttribute(attr.name)))
          }
        })
      }
      try {
        var testKey = '__storejs__';
        store.set(testKey, testKey);
        if (store.get(testKey) != testKey) {
          store.disabled = true
        }
        store.remove(testKey)
      } catch (e) {
        store.disabled = true
      }
      store.enabled = !store.disabled;
      if (typeof module != 'undefined' && module.exports && this.module !== module) {
        module.exports = store
      } else if (typeof define === 'function' && define.amd) {
        define(store)
      } else {
        win.store = store
      }
    }(Function('return this')()))
  });
  // source: assets/js/dash/site/pages/page.coffee
  rqzt.define('./site/pages/page', function (module, exports, __dirname, __filename, process) {
    var Page, Router, View, _, crowdcontrol, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    View = crowdcontrol.view.View;
    Router = rqzt('./site/router');
    Page = function (superClass) {
      extend(Page, superClass);
      function Page() {
        return Page.__super__.constructor.apply(this, arguments)
      }
      Page.prototype.tag = 'page';
      Page.prototype.icon = 'fa fa-circle-thin';
      Page.prototype.name = 'Page';
      Page.prototype.crumbs = [];
      Page.prototype.collection = '';
      Page.prototype._id = '';
      Page.prototype.action = '';
      Page.prototype.render = function () {
      };
      Page.prototype.js = function (opts) {
        Page.__super__.js.apply(this, arguments);
        $(this.root).attr('id', 'current-page').addClass('animated').addClass('fadeIn');
        return this.render()
      };
      Page.register = function () {
        Router.add(this.prototype.collection, this.prototype.action, this);
        return Page.__super__.constructor.register.apply(this, arguments)
      };
      return Page
    }(View);
    module.exports = Page
  });
  // source: assets/js/dash/site/router.coffee
  rqzt.define('./site/router', function (module, exports, __dirname, __filename, process) {
    var Router, changePage, lastPages, riot, routes;
    riot = rqzt('riot/riot');
    routes = {};
    module.exports = Router = {
      add: function (collection, action, clas) {
        if (action == null) {
          action = ''
        }
        return routes[collection + '_' + action] = clas
      },
      Menu: void 0,
      Crumbs: void 0
    };
    lastPages = null;
    changePage = function (collection, id, action) {
      var e, i, lastPage, len, page, proto;
      if (collection == null) {
        collection = ''
      }
      if (id == null) {
        id = ''
      }
      if (action == null) {
        action = ''
      }
      page = routes[collection + '_' + action];
      if (page != null) {
        if (lastPages != null) {
          for (i = 0, len = lastPages.length; i < len; i++) {
            lastPage = lastPages[i];
            try {
              lastPage.unmount()
            } catch (error) {
              e = error
            }
          }
        }
        Router.Menu.setActive(page);
        Router.Crumbs.setActive(page);
        Router.Crumbs.setActiveId(id);
        proto = page.prototype;
        $('#content').html('<div id="replaceme"/>');
        lastPages = riot.mount('#replaceme', proto.tag, { _id: id });
        return $(window).scrollTop(0)
      }
    };
    riot.route(changePage);
    $(function () {
      var hash;
      hash = window.location.hash.replace('#', '');
      if (hash === '') {
        return changePage()
      } else {
        return riot.route(hash)
      }
    })
  });
  // source: assets/js/dash/templates/dash/site/pages/dashboard.html
  rqzt.define('./templates/dash/site/pages/dashboard', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="tray tray-center" style="padding-top:0px;overflow:visible">\n  <div>\n    <div class="period-configure row mb20" if="{window.User.owner}">\n      <div class="col-sm-12">\n        <div class="currency-picker" if="{currencyCount > 1}">\n          <basic-select options="{ currencyOptions }" model="{ currencyModel }" obs="{obs}"></basic-select>\n        </div>\n        <h5 class="text-center" if="{currencyCount > 1}">\n          For\n        </h5>\n        <div class="period-picker">\n          <basic-select options="{ periodOptions }" model="{ periodModel }" obs="{obs}"></basic-select>\n        </div>\n        <h5 class="text-center">\n          Of\n        </h5>\n        <div class="period-datepicker">\n          <date-picker model="{ periodDateModel }" obs="{obs}"></date-picker>\n        </div>\n      </div>\n    </div>\n    <div class="row" if="{window.User.owner}">\n      <div class="col-sm-3">\n        <number-panel obs="{ totalOrdersObs }" description="{ \'Total Orders\'}" label="{ \'ALL TIME\' }"></number-panel>\n      </div>\n      <div class="col-sm-3">\n        <money-panel obs="{ totalSalesObs }" description="{ \'Total Sales\' }" label="{ \'ALL TIME\' }"></money-panel>\n      </div>\n      <div class="col-sm-3">\n        <number-panel obs="{ totalUsersObs }" description="{ \'Total Users\'}" label="{ \'ALL TIME\' }"></number-panel>\n      </div>\n      <div class="col-sm-3">\n        <number-panel obs="{ totalSubsObs }" description="{ \'Total Subscribers\' }" label="{ \'ALL TIME\' }"></number-panel>\n      </div>\n    </div>\n    <div class="row" if="{window.User.owner}">\n      <div class="col-sm-3">\n        <number-panel obs="{ dailyOrdersObs }" description="{ periodDescription() + \' Orders\' }" label="{ periodLabel()  }"></number-panel>\n      </div>\n      <div class="col-sm-3">\n        <money-panel obs="{ dailySalesObs }" description="{ periodDescription() + \' Sales\' }" label="{ periodLabel() }"></money-panel>\n      </div>\n      <div class="col-sm-3">\n        <number-panel obs="{ dailyUsersObs }" description="{ periodDescription() + \' Sign-Ups\' }" label="{ periodLabel()  }"></number-panel>\n      </div>\n      <div class="col-sm-3">\n        <number-panel obs="{ dailySubsObs }" description="{ periodDescription() + \' Subscribers\' }" label="{ periodLabel() }"></number-panel>\n      </div>\n    </div>\n\n    <!-- <h1 class="text-center">Welcome to the Hanzo Beta</h1> -->\n    <!-- <p class="text-center">Feedback about our beta is welcome! Contact <a href="mailto:support@hanzo.io">support@hanzo.io</a> and let us know what you think and what you\'d like to see here :)</p> -->\n\n    <!-- Admin-panels -->\n    <div class="admin-panels animated fadeIn" if="{window.User.owner}">\n\n      <div class="row">\n        <div class="col-md-12 admin-grid">\n          <chart title="{ \'Sales for Current Period\' }" model="{ chartModel }" obs="{ chartObs }">\n          </chart>\n        </div>\n      </div>\n    </div>\n\n    <div class="admin-panels animated fadeIn" if="{!window.User.owner}">\n      <div class="row">\n        <div class="col-md-12 admin-grid">\n          <h1 class="text-center">Welcome to the Hanzo Beta</h1>\n        </div>\n      </div>\n    </div>\n\n    <!-- <div class="admin-panels animated fadeIn"> -->\n\n    <!--   <div class="row"> -->\n\n    <!--     <1!-- Three Pane Widget --1> -->\n    <!--     <div class="col-md-12 admin-grid"> -->\n\n    <!--       <1!-- dashboard activity --1> -->\n    <!--       <div class="panel sort-disable" id="p01" data-panel-title="false"> -->\n    <!--         <div class="panel-heading"> -->\n    <!--           <b>Views</b> by <b>Product</b> for Last <b>12 Months</b> -->\n    <!--         </div> -->\n    <!--         <div class="panel-body pn"> -->\n\n    <!--           <div class="tab-content"> -->\n    <!--             <div class="tab-pane active p15" id="tab1_1" role="tabpanel" > -->\n    <!--               <div class="row"> -->\n    <!--                   <1!-- Chart Column --1> -->\n    <!--                   <div class="col-md-12 pln mvn15"> -->\n    <!--                     <h5 class="ml5 mt20 ph10 pb5 br-b fw600 hidden">Visitors -->\n    <!--                       <small class="pull-right fw600">13,253 -->\n    <!--                         <span class="text-primary">(8,251 unique)</span> -->\n    <!--                       </small> -->\n    <!--                     </h5> -->\n    <!--                     <div id="ecommerce_chart1" style="height: 300px;"></div> -->\n    <!--                   </div> -->\n\n    <!--                 </div> -->\n    <!--               </div> -->\n    <!--             <div role="tabpanel" class="tab-pane " id="tab1_3"> -->\n    <!--             </div> -->\n    <!--           </div> -->\n\n    <!--         </div> -->\n    <!--       </div> -->\n\n    <!--     </div> -->\n    <!--     <1!-- end: .col-md-12.admin-grid --1> -->\n\n    <!--   </div> -->\n    <!--   <div class="row"> -->\n    <!--     <div class="col-md-6 admin-grid"> -->\n\n    <!--       <1!-- Geo Map + Table Stats --1> -->\n    <!--       <div class="panel" id="p9"> -->\n    <!--         <div class="panel-heading"> -->\n    <!--           <span class="panel-title">Visitor Geography</span> -->\n    <!--         </div> -->\n    <!--         <div class="panel-body"> -->\n    <!--           <div id="WidgetMap" class="jvector-colors hide-jzoom" style="width: 100%; height: 250px;"></div> -->\n    <!--         </div> -->\n    <!--         <div class="panel-menu admin-form pn"> -->\n    <!--           <1!-- Panel Break Smart Widget --1> -->\n    <!--           <div class="smart-widget sm-right smr-50"> -->\n    <!--             <label class="field"> -->\n    <!--               <input type="text" name="sub" id="sub" class="gui-input br-n" placeholder="United States of America" disabled> -->\n    <!--             </label> -->\n    <!--             <button type="submit" class="button br-n br-l"> -->\n    <!--               <i class="fa fa-caret-down"></i> -->\n    <!--             </button> -->\n    <!--           </div> -->\n    <!--         </div> -->\n    <!--         <div class="panel-body pn"> -->\n    <!--           <table class="table mbn"> -->\n    <!--             <thead> -->\n    <!--               <tr class="hidden"> -->\n    <!--                 <th>#</th> -->\n    <!--                 <th>First Name</th> -->\n    <!--               </tr> -->\n    <!--             </thead> -->\n    <!--             <tbody> -->\n    <!--               <tr> -->\n    <!--                 <td class="va-m fw600 text-muted"> -->\n    <!--                   <span class="fa fa-circle text-info fs14 mr10"></span>California</td> -->\n    <!--                 <td class="fs15 fw600 text-right">24%</td> -->\n    <!--               </tr> -->\n    <!--               <tr> -->\n    <!--                 <td class="va-m fw600 text-muted"> -->\n    <!--                   <span class="fa fa-circle text-primary fs14 mr10"></span>Texas</td> -->\n    <!--                 <td class="fs15 fw600 text-right">7%</td> -->\n    <!--               </tr> -->\n    <!--               <tr> -->\n    <!--                 <td class="va-m fw600 text-muted"> -->\n    <!--                   <span class="fa fa-circle text-success fs14 mr10"></span>Missouri</td> -->\n    <!--                 <td class="fs15 fw600 text-right">14%</td> -->\n    <!--               </tr> -->\n    <!--               <tr> -->\n    <!--                 <td class="va-m fw600 text-muted"> -->\n    <!--                   <span class="fa fa-circle text-warning fs14 mr10"></span>New York</td> -->\n    <!--                 <td class="fs15 fw600 text-right">7%</td> -->\n    <!--               </tr> -->\n    <!--             </tbody> -->\n    <!--           </table> -->\n    <!--         </div> -->\n    <!--       </div> -->\n    <!--     </div> -->\n    <!--     <1!-- end: .row --1> -->\n    <!--     <div class="col-md-6 admin-grid" id="grid-1"> -->\n\n    <!--   <1!-- Browser List --1> -->\n\n    <!--   <div class="panel" id="p17"> -->\n    <!--     <div class="panel-heading ui-sortable-handle"> -->\n    <!--       <span class="panel-title">Crawler List</span> -->\n    <!--     <span class="panel-controls"><a href="#" class="panel-control-loader"></a><a href="#" class="panel-control-remove"></a><a href="#" class="panel-control-title"></a><a href="#" class="panel-control-color"></a><a href="#" class="panel-control-collapse"></a><a href="#" class="panel-control-fullscreen"></a></span></div> -->\n    <!--     <div class="panel-body pn"> -->\n    <!--       <table class="table mbn tc-med-1 tc-bold-last"> -->\n    <!--         <thead> -->\n    <!--           <tr class="hidden"> -->\n    <!--             <th>#</th> -->\n    <!--             <th>First Name</th> -->\n    <!--           </tr> -->\n    <!--         </thead> -->\n    <!--         <tbody> -->\n    <!--           <tr> -->\n    <!--             <td> -->\n    <!--               <span class="favicons google va-t mr10"></span>pages.com/img/15</td> -->\n    <!--             <td>7%</td> -->\n    <!--           </tr> -->\n    <!--           <tr> -->\n    <!--             <td> -->\n    <!--               <span class="favicons yahoo va-t mr10"></span>pages.com/popular</td> -->\n    <!--             <td>14%</td> -->\n    <!--           </tr> -->\n    <!--           <tr> -->\n    <!--             <td> -->\n    <!--               <span class="favicons google va-t mr10"></span>pages.com/news/3</td> -->\n    <!--             <td>31%</td> -->\n    <!--           </tr> -->\n    <!--           <tr> -->\n    <!--             <td> -->\n    <!--               <span class="favicons bing va-t mr10"></span>pages.com/featured/16</td> -->\n    <!--             <td>22%</td> -->\n    <!--           </tr> -->\n    <!--         </tbody> -->\n    <!--       </table> -->\n    <!--     </div> -->\n    <!--   </div><div class="panel" id="p18"> -->\n    <!--     <div class="panel-heading ui-sortable-handle"> -->\n    <!--       <span class="panel-title">Browser List</span> -->\n    <!--     <span class="panel-controls"><a href="#" class="panel-control-loader"></a><a href="#" class="panel-control-remove"></a><a href="#" class="panel-control-title"></a><a href="#" class="panel-control-color"></a><a href="#" class="panel-control-collapse"></a><a href="#" class="panel-control-fullscreen"></a></span></div> -->\n    <!--     <div class="panel-body pn"> -->\n    <!--       <table class="table mbn tc-med-1 tc-bold-2"> -->\n    <!--         <thead> -->\n    <!--           <tr class="hidden"> -->\n    <!--             <th>#</th> -->\n    <!--             <th>First Name</th> -->\n    <!--           </tr> -->\n    <!--         </thead> -->\n    <!--         <tbody> -->\n    <!--           <tr> -->\n    <!--             <td> -->\n    <!--               <span class="favicons chrome va-t mr10"></span>United States</td> -->\n    <!--             <td>39%</td> -->\n    <!--           </tr> -->\n    <!--           <tr> -->\n    <!--             <td> -->\n    <!--               <span class="favicons firefox va-t mr10"></span>Germany</td> -->\n    <!--             <td>43%</td> -->\n    <!--           </tr> -->\n    <!--           <tr> -->\n    <!--             <td> -->\n    <!--               <span class="favicons ie va-t mr10"></span>France</td> -->\n    <!--             <td>14%</td> -->\n    <!--           </tr> -->\n    <!--           <tr> -->\n    <!--             <td> -->\n    <!--               <span class="favicons safari va-t mr10"></span>Spain</td> -->\n    <!--             <td>3%</td> -->\n    <!--           </tr> -->\n    <!--         </tbody> -->\n    <!--       </table> -->\n    <!--     </div> -->\n    <!--   </div><div class="panel preserve-grid"></div></div> -->\n    <!-- </div> -->\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/site/pages/user.coffee
  rqzt.define('./site/pages/user', function (module, exports, __dirname, __filename, process) {
    var Page, User, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    User = function (superClass) {
      extend(User, superClass);
      function User() {
        return User.__super__.constructor.apply(this, arguments)
      }
      User.prototype.tag = 'page-user';
      User.prototype.icon = 'fa fa-users';
      User.prototype.name = 'User';
      User.prototype.html = rqzt('./templates/dash/site/pages/user');
      User.prototype.collection = 'user';
      return User
    }(Page);
    User.register();
    module.exports = User
  });
  // source: assets/js/dash/templates/dash/site/pages/user.html
  rqzt.define('./templates/dash/site/pages/user', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- User information Form Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <!-- User information Form Content -->\n    <user-form id="{opts._id}">\n      <div class="col-md-8">\n        <div id="user-info" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Contact\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20" style="padding:0">\n              <control class="col-sm-12" label="Email" input="{ inputs.email }"></control>\n              <control class="col-sm-6" label="First Name" input="{ inputs.firstName }"></control>\n              <control class="col-sm-6" label="Last Name" input="{ inputs.lastName }"></control>\n              <control class="col-sm-9" label="Phone" input="{ inputs.phone }"></control>\n              <control class="col-sm-3" label="Account Enabled" input="{ inputs.enabled }"></control>\n            </div>\n\n            <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n              <span class="error-container help-block animated fadeInUp">{error.message}</span>\n            </div>\n\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-xs-6">\n                <button type="submit" class="btn btn-block btn-dark">Save</button>\n              </div>\n              <div class="col-xs-3">\n                <button type="reset" class="btn btn-block btn-default">Reset</button>\n              </div>\n              <div class="col-xs-3">\n                <button type="button" class="btn btn-block btn-default" onclick="{ deleteModal }">Delete</button>\n              </div>\n\n            </div>\n          </div>\n        </div>\n\n        <div id="affiliate-info" class="panel animated fadeIn">\n          <affiliate-form userobs="{ obs }" assignToUserFn="{ assignToUser }">\n            <div class="panel-heading">\n              Affiliate Marketing\n            </div>\n            <div class="panel-body">\n              <div class="section col-xs-12" style="padding:0">\n                <control class="col-sm-6" label="Flat Fee" input="{ inputs[\'commission.flat\'] }"></control>\n                <control class="col-sm-6" label="Percent Fee" input="{ inputs[\'commission.percent\'] }"></control>\n              </div>\n\n              <div class="section col-xs-12 mb20" style="padding:0">\n                <control class="col-sm-6" label="Affiliate Coupon" input="{ inputs.couponId }"></control>\n                <control class="col-sm-6" label="Affiliate Enabled" input="{ inputs.enabled }"></control>\n              </div>\n\n              <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n                <span class="error-container help-block animated fadeInUp">{error.message}</span>\n              </div>\n\n              <div class="form-actions section col-xs-12" style="padding:0">\n                <div class="col-xs-6">\n                  <button type="submit" class="btn btn-block btn-dark">Save</button>\n                </div>\n\n              </div>\n            </div>\n          </affiliate-form>\n        </div>\n\n        <!-- <div id="user-shipping-address" class="panel"> -->\n        <!--   <div class="panel-heading"> -->\n        <!--     <ul class="nav panel-tabs-border panel-tabs panel-tabs-left"> -->\n        <!--       <li class="active"> -->\n        <!--         <a href="#address1" data-toggle="tab" aria-expanded="true">Shipping Address</a> -->\n        <!--       </li> -->\n        <!--       <li class=""> -->\n        <!--         <a href="#address2" data-toggle="tab" aria-expanded="false">Billing Address</a> -->\n        <!--       </li> -->\n        <!--     </ul> -->\n        <!--   </div> -->\n        <!--   <div class="panel-body"> -->\n        <!--     <div class="tab-content pn br-n"> -->\n        <!--       <div id="address1" class="tab-pane active animated fadeIn"> -->\n        <!--         <div class="section col-xs-12" style="padding:0"> -->\n        <!--           <div class="col-md-8"> -->\n        <!--             <control label="Street Address" input="{ inputs[\'shippingAddress.line1\'] }"></control> -->\n        <!--           </div> -->\n        <!--           <div class="col-md-4"> -->\n        <!--             <control label="Apt/Suite Number" input="{ inputs[\'shippingAddress.line2\'] }"></control> -->\n        <!--           </div> -->\n        <!--         </div> -->\n        <!--         <div class="section col-xs-12" style="padding:0"> -->\n        <!--           <div class="col-md-6"> -->\n        <!--             <control label="City" input="{ inputs[\'shippingAddress.city\'] }"></control> -->\n        <!--           </div> -->\n        <!--           <div class="col-md-3"> -->\n        <!--             <control label="State" input="{ inputs[\'shippingAddress.state\'] }"></control> -->\n        <!--           </div> -->\n        <!--           <div class="col-md-3"> -->\n        <!--             <control label="Postal/ZIP Code" input="{ inputs[\'shippingAddress.postalCode\'] }"></control> -->\n        <!--           </div> -->\n        <!--         </div> -->\n        <!--         <div class="section col-xs-12 mb20" style="padding:0"> -->\n        <!--           <div class="col-md-12"> -->\n        <!--             <control label="Country" input="{ inputs[\'shippingAddress.country\'] }"></control> -->\n        <!--           </div> -->\n        <!--         </div> -->\n        <!--       </div> -->\n        <!--       <div id="address2" class="tab-pane animated fadeIn"> -->\n        <!--         <div class="section col-xs-12" style="padding:0"> -->\n        <!--           <div class="col-md-8"> -->\n        <!--             <control label="Street Address" input="{ inputs[\'billingAddress.line1\'] }"></control> -->\n        <!--           </div> -->\n        <!--           <div class="col-md-4"> -->\n        <!--             <control label="Apt/Suite Number" input="{ inputs[\'billingAddress.line2\'] }"></control> -->\n        <!--           </div> -->\n        <!--         </div> -->\n        <!--         <div class="section col-xs-12" style="padding:0"> -->\n        <!--           <div class="col-md-6"> -->\n        <!--             <control label="City" input="{ inputs[\'billingAddress.city\'] }"></control> -->\n        <!--           </div> -->\n        <!--           <div class="col-md-3"> -->\n        <!--             <control label="State" input="{ inputs[\'billingAddress.state\'] }"></control> -->\n        <!--           </div> -->\n        <!--           <div class="col-md-3"> -->\n        <!--             <control label="Postal/ZIP Code" input="{ inputs[\'billingAddress.postalCode\'] }"></control> -->\n        <!--           </div> -->\n        <!--         </div> -->\n        <!--         <div class="section col-xs-12 mb20" style="padding:0"> -->\n        <!--           <div class="col-md-12"> -->\n        <!--             <control label="Country" input="{ inputs[\'billingAddress.country\'] }"></control> -->\n        <!--           </div> -->\n        <!--         </div> -->\n        <!--       </div> -->\n        <!--       <div class="form-actions section"> -->\n        <!--         <div class="col-xs-8 col-md-3 col-md-offset-3"> -->\n        <!--           <button type="submit" class="btn btn-block btn-dark">Save</button> -->\n        <!--         </div> -->\n        <!--         <div class="col-xs-4 col-md-3"> -->\n        <!--           <button type="reset" class="btn btn-block btn-default">Reset</button> -->\n        <!--         </div> -->\n        <!--       </div> -->\n        <!--     </div> -->\n        <!--   </div> -->\n        <!-- </div> -->\n\n        <div id="user-lists" class="panel">\n          <div class="panel-heading">\n            <ul class="nav panel-tabs-border panel-tabs panel-tabs-left">\n              <li class="active">\n                <a href="#list1" data-toggle="tab" aria-expanded="true">Orders</a>\n              </li>\n              <li class>\n                <a href="#list2" data-toggle="tab" aria-expanded="true">Referrer Tokens</a>\n              </li>\n              <li class>\n                <a href="#list3" data-toggle="tab" aria-expanded="true">Referral</a>\n              </li>\n            </ul>\n          </div>\n          <div class="panel-body panel-viewport">\n            <div class="tab-content pn br-n">\n              <div id="list1" class="tab-pane active animated fadeIn">\n                <order-list path="{ \'user/\'+opts.id+\'/orders\' }">\n                  No Orders Found\n                </order-list>\n              </div>\n              <div id="list2" class="tab-pane animated fadeIn">\n                <referrer-list path="{ \'user/\'+opts.id+\'/referrers\' }">\n                  No Referrer Tokens Found\n                </referrer-list>\n              </div>\n              <div id="list3" class="tab-pane animated fadeIn">\n                <referral-list path="{ \'user/\'+opts.id+\'/referrals\' }">\n                  No Referrals Found\n                </referral-list>\n              </div>\n            </div>\n          </div>\n        </div>\n\n      </div>\n\n      <div class="col-md-4">\n        <div id="user-info" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Statistics\n          </div>\n          <div class="panel-body">\n            <control label="ID" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n            <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n            <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n          </div>\n        </div>\n\n        <div id="user-reset-password" class="panel">\n          <div class="panel-heading">\n            Reset Password\n          </div>\n          <div class="panel-body">\n            <reset-password-form userId="{ opts.id }" url ="{ opts.url }" token="{ opts.token }">\n            </reset-password-form>\n          </div>\n        </div>\n\n        <div id="unique-coupon" class="panel">\n          <div class="panel-heading">\n            Unique Coupon\n          </div>\n          <div class="panel-body">\n            <unique-coupon-form userId="{ opts.id }" url ="{ opts.url }" token="{ opts.token }">\n            </unique-coupon-form>\n          </div>\n        </div>\n\n        <div id="balance" class="panel">\n          <div class="panel-heading">\n            Credit Balance\n          </div>\n          <div class="panel-body">\n            <balance-widget userId="{opts.id}">\n            </balance-widget>\n          </div>\n        </div>\n\n      </div>\n\n    </user-form>\n    <!-- END User information Form Content -->\n  </div>\n</div>\n<!-- END User information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/users.coffee
  rqzt.define('./site/pages/users', function (module, exports, __dirname, __filename, process) {
    var Page, Users, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Users = function (superClass) {
      extend(Users, superClass);
      function Users() {
        return Users.__super__.constructor.apply(this, arguments)
      }
      Users.prototype.tag = 'page-users';
      Users.prototype.icon = 'fa fa-users';
      Users.prototype.name = 'Users';
      Users.prototype.html = rqzt('./templates/dash/site/pages/users');
      Users.prototype.collection = 'users';
      return Users
    }(Page);
    Users.register();
    module.exports = Users
  });
  // source: assets/js/dash/templates/dash/site/pages/users.html
  rqzt.define('./templates/dash/site/pages/users', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Users View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <div class="panel animated fadeIn">\n      <div class="panel-heading">\n        Users\n      </div>\n      <div class="panel-body">\n          <!-- Users View Content -->\n        <user-paged-table obs="{ obs }">\n          <div>\n            <i class="fa fa-users" style="font-size:50px"></i>\n            <h2 class="text-center">No Users Found</h2>\n          </div>\n        </user-paged-table>\n        <!-- END Users View Content -->\n      </div>\n    </div>\n  </div>\n</div>\n<user-filter-pane tableobs="{ obs }">\n</user-filter-pane>\n<!-- END Users View Block -->\n'
  });
  // source: assets/js/dash/site/pages/order.coffee
  rqzt.define('./site/pages/order', function (module, exports, __dirname, __filename, process) {
    var Order, Page, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Order = function (superClass) {
      extend(Order, superClass);
      function Order() {
        return Order.__super__.constructor.apply(this, arguments)
      }
      Order.prototype.tag = 'page-order';
      Order.prototype.icon = 'glyphicon glyphicon-shopping-cart';
      Order.prototype.name = 'Order';
      Order.prototype.html = rqzt('./templates/dash/site/pages/order');
      Order.prototype.collection = 'order';
      return Order
    }(Page);
    Order.register();
    module.exports = Order
  });
  // source: assets/js/dash/templates/dash/site/pages/order.html
  rqzt.define('./templates/dash/site/pages/order', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Order information Form Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <!-- Order information Form Content -->\n    <order-form id="{opts._id}">\n      <div class="col-md-8">\n        <div id="user-shipping-address" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Shipping Address\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <div class="section col-lg-6 mb20">\n                <control label="Recipient Name" input="{ inputs[\'shippingAddress.name\'] }"></control>\n                <control label="Street Address" input="{ inputs[\'shippingAddress.line1\'] }"></control>\n                <control label="Apt/Suite Number" input="{ inputs[\'shippingAddress.line2\'] }"></control>\n                <control label="City" input="{ inputs[\'shippingAddress.city\'] }"></control>\n                <div class="col-xs-7" style="padding-left:0">\n                  <control label="State" input="{ inputs[\'shippingAddress.state\'] }"></control>\n                </div>\n                <div class="col-xs-5" style="padding-right:0">\n                  <control label="Postal/ZIP Code" input="{ inputs[\'shippingAddress.postalCode\'] }"></control>\n                </div>\n                <control label="Country" input="{ inputs[\'shippingAddress.country\'] }"></control>\n              </div>\n\n              <div class="section col-lg-6 mb20">\n                <gmap obs="{ obs }" addressField="shippingAddress" style="min-height:408px"></gmap>\n              </div>\n            </div>\n\n            <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n              <span class="error-container help-block animated fadeInUp">{error.message}</span>\n            </div>\n\n            <div class="form-actions section">\n              <div class="col-xs-6">\n                <button type="submit" class="btn btn-block btn-dark">Save</button>\n              </div>\n              <div class="col-xs-6">\n                <button type="reset" class="btn btn-block btn-default">Reset</button>\n              </div>\n            </div>\n\n          </div>\n        </div>\n\n        <div id="ship-order" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Shipping\n          </div>\n          <div class="panel-body" if="{ model.fulfillment.integration }">\n            <div class="section col-xs-12" style="padding:0">\n              <div class="section col-lg-6 mb20">\n                <control label="External ID" input="{ inputs[\'fulfillment.externalId\'] }"></control>\n              </div>\n              <div class="section col-lg-6 mb20">\n                <control label="Tracking Number" input="{ inputs[\'fulfillment.trackingNumber\'] }"></control>\n              </div>\n              <div class="section col-lg-6 mb20">\n                <control label="Carrier" input="{ inputs[\'fulfillment.carrier\'] }"></control>\n              </div>\n              <div class="section col-lg-6 mb20">\n                <control label="Service" input="{ inputs[\'fulfillment.service\'] }"></control>\n              </div>\n              <div class="section col-lg-6 mb20">\n                <control label="Shipping Cost" input="{ inputs[\'fulfillment.cost\'] }"></control>\n              </div>\n              <div class="section col-lg-6 mb20">\n                <control label="Created On" input="{ inputs[\'fulfillment.createdAt\'] }"></control>\n              </div>\n              <div class="section col-lg-6 mb20">\n                <control label="Shipped On" input="{ inputs[\'fulfillment.shippedAt\'] }"></control>\n              </div>\n              <div class="section col-lg-6 mb20">\n                <control label="Delivered On" input="{ inputs[\'fulfillment.deliveredAt\'] }"></control>\n              </div>\n              <!-- <div class="form-actions col-lg-6 section mt30"> -->\n              <!--   <button class="btn btn-block btn-default" onclick="{ shippingModal }">Ship via Shipwire</button> -->\n              <!-- </div> -->\n            </div>\n\n            <!-- <div class="section col-xs-12 mb10 has-error" if="{ error }" style="padding:0"> -->\n            <!--   <span class="error-container help-block animated fadeInUp">{ error.message }</span> -->\n            <!-- </div> -->\n\n          </div>\n          <div class="panel-body" if="{ !model.fulfillment.integration }">\n            <div class="section col-xs-12" style="padding:0">\n              <div class="section col-lg-6 mb20">\n                <control label="Shipping Service Level" input="{ inputs[\'shippingService\'] }"></control>\n              </div>\n              <div class="form-actions col-lg-6 section mt30">\n                <button class="btn btn-block btn-default" onclick="{ shippingModal }">Ship via Shipwire</button>\n              </div>\n            </div>\n\n            <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n              <span class="error-container help-block animated fadeInUp">{error.message}</span>\n            </div>\n\n          </div>\n        </div>\n\n        <div id="refund-order" class="panel animated fadeIn" if="{ model.paymentStatus != \'refunded\' }">\n          <div class="panel-heading">\n            Refund\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <div class="section col-lg-6 mb20">\n                <control label="Refund Amount" input="{ inputs[\'refundAmount\'] }"></control>\n              </div>\n              <div class="form-actions col-lg-6 section mt30">\n                <button class="btn btn-block btn-default" onclick="{ refundModal }">Refund</button>\n              </div>\n            </div>\n\n            <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n              <span class="error-container help-block animated fadeInUp">{error.message}</span>\n            </div>\n\n          </div>\n        </div>\n\n        <div id="order-items" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Receipt\n          </div>\n          <div class="panel-body">\n            <item-list obs="{ obs }">\n              No Items Found\n            </item-list>\n          </div>\n          <div class="panel-body">\n            <control label="Currency" input="{ inputs.currency }" labelClasses="col-xs-2 col-xs-offset-8 text-right" controlClasses="col-xs-2 text-right"></control>\n            <control label="Line Total" input="{ inputs.lineTotal }" labelClasses="col-xs-2 col-xs-offset-8 text-right" controlClasses="col-xs-2 text-right"></control>\n            <control label="Discount" input="{ inputs.discount }" labelClasses="col-xs-2 col-xs-offset-8 text-right" controlClasses="col-xs-2 text-right"></control>\n            <control label="Subtotal" input="{ inputs.subtotal }" labelClasses="col-xs-2 col-xs-offset-8 text-right" controlClasses="col-xs-2 text-right"></control>\n            <control label="Shipping" input="{ inputs.shipping }" labelClasses="col-xs-2 col-xs-offset-8 text-right" controlClasses="col-xs-2 text-right"></control>\n            <control label="Tax" input="{ inputs.tax }" labelClasses="col-xs-2 col-xs-offset-8 text-right" controlClasses="col-xs-2 text-right"></control>\n            <control label="Total" input="{ inputs.total }" labelClasses="col-xs-2 col-xs-offset-8 text-right" controlClasses="col-xs-2 text-right"></control>\n            <control label="Refunded" input="{ inputs.refunded }" labelClasses="col-xs-2 col-xs-offset-8 text-right" controlClasses="col-xs-2 text-right" if="{ model.refunded > 0 }"></control>\n          </div>\n        </div>\n\n        <div id="metadata" class="panel animated fadeIn" if="{ Object.keys(model.metadata).length > 0 }">\n          <div class="panel-heading">\n            Metadata\n          </div>\n          <div class="panel-body">\n            <pre class="form-control-static">{ JSON.stringify(model.metadata, null, 2) || \'&nbsp;\' }</pre>\n          </div>\n        </div>\n\n        <div id="free-order-items" class="panel animated fadeIn" if="{ model.couponItems }">\n          <div class="panel-heading">\n            Free Coupon Items\n          </div>\n          <div class="panel-body">\n            <item-list obs="{ obs }" itemsModel="{ \'couponItems\' }">\n            </item-list>\n          </div>\n        </div>\n\n        <div id="gift-info" class="panel animated fadeIn" if="{ model.gift }">\n          <div class="panel-heading">\n            Gift Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <control label="Email" input="{ inputs.giftEmail }" if="{ model.giftEmail }"></control>\n              <control label="Message" input="{ inputs.giftMessage }"></control>\n            </div>\n          </div>\n        </div>\n\n        <div id="affiliate" class="panel animated fadeIn" if="{ model.paymentStatus != \'refunded\' }">\n          <div class="panel-heading">\n            Refund\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <div class="section col-lg-6 mb20">\n                <control label="Refund Amount" input="{ inputs[\'refundAmount\'] }"></control>\n              </div>\n              <div class="form-actions col-lg-6 section mt30">\n                <button class="btn btn-block btn-default" onclick="{ refundModal }">Refund</button>\n              </div>\n            </div>\n\n            <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n              <span class="error-container help-block animated fadeInUp">{error.message}</span>\n            </div>\n\n          </div>\n        </div>\n\n        <div id="order-payments" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Payments\n          </div>\n          <div class="panel-body">\n            <payment-list path="{ \'order/\'+opts.id+\'/payments\' }">\n              No Payments Found\n            </payment-list>\n          </div>i\n        </div>\n\n      </div>\n\n      <div class="col-md-4">\n        <div id="order-info" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Statistics\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <control label="ID" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Number" input="{ inputs.number }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n            </div>\n          </div>\n        </div>\n\n        <div id="order-status" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Status\n          </div>\n          <div class="panel-body">\n            <control label="Status" input="{ inputs.status }" labelClasses="col-md-6" controlClasses="col-md-6"></control>\n            <control label="Payment Status" input="{ inputs.paymentStatus }" labelClasses="col-md-6" controlClasses="col-md-6"></control>\n            <control label="Fulfillment Status" input="{ inputs.fulfillmentStatus }" labelClasses="col-md-6" controlClasses="col-md-6"></control>\n          </div>\n        </div>\n\n        <div id="order-status" class="panel animated fadeIn" if="{ model.couponCodes }">\n          <div class="panel-heading">\n            Coupons\n          </div>\n          <div class="panel-body">\n            <control label="Coupon(s)" input="{ inputs.couponCodes }" labelClasses="col-md-4" controlClasses="col-md-8"></control>\n          </div>\n        </div>\n\n        <div id="user-info" class="panel animated fadeIn">\n          <div class="panel-heading">\n            Buyer Information\n          </div>\n          <div class="panel-body">\n            <order-user-static-form obs="{ obs }">\n              <div if="{ !error }">\n                <div class="section col-xs-12">\n                  <div class="section row">\n                    <control label="ID" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Email" input="{ inputs.email }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="First Name" input="{ inputs.firstName }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Last Name" input="{ inputs.lastName }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Phone" input="{ inputs.phone }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                 </div>\n                  <div class="section row mb20">\n                    <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="col-xs-12" style="padding:0">\n                    <button __disabled="{ sending }" onclick="{ resendOrderConfirmation }" type="button" class="btn btn-block btn-dark">Resend Confirmation</button>\n                  </div>\n                  <div class="col-xs-12" if="{ parent.model.fulfillmentStatus == \'shipped\' }" style="padding:0">\n                    <button __disabled="{ sending }" onclick="{ resendShippingConfirmation }" type="button" class="btn btn-block btn-dark">Resend Shipping</button>\n                  </div>\n                  <div class="col-xs-12 mt20" style="padding:0">\n                    <button if="{ parent.model.refunded }" __disabled="{ sending }" onclick="{ resendRefundConfirmation }" type="button" class="btn btn-block btn-dark">Resend Refund</button>\n                  </div>\n                </div>\n              </div>\n              <h4 if="{ error }" class="text-center mb20">\n                Buyer missing or deleted.\n              </h4>\n            </order-user-static-form>\n          </div>\n        </div>\n\n      </div>\n    </order-form>\n    <!-- END Order information Form Content -->\n  </div>\n</div>\n<!-- END Order information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/orders.coffee
  rqzt.define('./site/pages/orders', function (module, exports, __dirname, __filename, process) {
    var Orders, Page, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Orders = function (superClass) {
      extend(Orders, superClass);
      function Orders() {
        return Orders.__super__.constructor.apply(this, arguments)
      }
      Orders.prototype.tag = 'page-orders';
      Orders.prototype.icon = 'glyphicon glyphicon-shopping-cart';
      Orders.prototype.name = 'Orders';
      Orders.prototype.html = rqzt('./templates/dash/site/pages/orders');
      Orders.prototype.collection = 'orders';
      return Orders
    }(Page);
    Orders.register();
    module.exports = Orders
  });
  // source: assets/js/dash/templates/dash/site/pages/orders.html
  rqzt.define('./templates/dash/site/pages/orders', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Orders View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <div class="panel animated fadeIn">\n      <div class="panel-heading">\n        Orders\n      </div>\n      <div class="panel-body">\n          <!-- Orders View Content -->\n        <order-paged-table obs="{ obs }">\n          <div>\n            <i class="glyphicon glyphicon-shopping-cart" style="font-size:50px"></i>\n            <h2 class="text-center">No Orders Found</h2>\n          </div>\n        </order-paged-table>\n        <!-- END Orders View Content -->\n      </div>\n    </div>\n  </div>\n</div>\n<order-filter-pane tableobs="{ obs }">\n</order-filter-pane>\n<!-- END Orders View Block -->\n\n'
  });
  // source: assets/js/dash/site/pages/payment.coffee
  rqzt.define('./site/pages/payment', function (module, exports, __dirname, __filename, process) {
    var Page, Payment, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Payment = function (superClass) {
      extend(Payment, superClass);
      function Payment() {
        return Payment.__super__.constructor.apply(this, arguments)
      }
      Payment.prototype.tag = 'page-payment';
      Payment.prototype.icon = 'fa fa-money';
      Payment.prototype.name = 'Payments';
      Payment.prototype.html = rqzt('./templates/dash/site/pages/payment');
      Payment.prototype.collection = 'payment';
      return Payment
    }(Page);
    Payment.register();
    module.exports = Payment
  });
  // source: assets/js/dash/templates/dash/site/pages/payment.html
  rqzt.define('./templates/dash/site/pages/payment', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Payment information Form Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <!-- Payment information Form Content -->\n    <payment-form id="{opts._id}">\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb10">\n              <div class="section row">\n                <control label="Order ID" input="{ inputs.orderId }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Type" input="{ inputs.type }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Status" input="{ inputs.status }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Amount" input="{ inputs.amount }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Refunded" input="{ inputs.amountRefunded }" if="{model.status==\'refunded\'}" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Platform Fee" input="{ inputs.fee }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class="panel animated fadeIn" if="{model.type == \'stripe\'}">\n          <div class="panel-heading">\n            Stripe Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb10">\n              <div class="section row">\n                <control label="Customer ID" input="{ inputs[\'account.customerId\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Charge ID" input="{ inputs[\'account.chargeId\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                  <control label="Card ID" input="{ inputs[\'account.cardId\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Transaction ID" input="{ inputs[\'account.balanceTransactionId\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Fingerprint" input="{ inputs[\'account.fingerprint\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Funding" input="{ inputs[\'account.funding\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Last Four" input="{ inputs[\'account.lastFour\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Brand" input="{ inputs[\'account.brand\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Expiration Month" input="{ inputs[\'account.month\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Expiration Year" input="{ inputs[\'account.year\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Country" input="{ inputs[\'account.country\'] }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Metadata\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12">\n              <div class="section row">\n                <control label="IP" input="{ inputs[\'client.ip\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Referrer" input="{ inputs[\'client.referer\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="User Agent" input="{ inputs[\'client.userAgent\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Language" input="{ inputs[\'client.language\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="City" input="{ inputs[\'client.city\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Region" input="{ inputs[\'client.region\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Country" input="{ inputs[\'client.country\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="col-md-4">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Statistics\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <div class="section row">\n                <control label="ID" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Buyer Information\n          </div>\n          <div class="panel-body">\n            <payment-user-static-form obs="{ obs }">\n              <div if="{ !error }">\n                <div class="section col-xs-12" style="padding:0">\n                  <div class="section row">\n                    <control label="ID" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Email" input="{ inputs.email }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="First Name" input="{ inputs.firstName }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Last Name" input="{ inputs.lastName }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Phone" input="{ inputs.phone }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                 </div>\n                  <div class="section row mb20">\n                    <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                </div>\n              </div>\n              <h4 if="{ error }" class="text-center mb20">\n                Buyer missing or deleted.\n              </h4>\n            </payment-user-static-form>\n          </div>\n        </div>\n      </div>\n    </payment-form>\n    <!-- END Payment information Form Content -->\n  </div>\n</div>\n<!-- END Payment information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/payments.coffee
  rqzt.define('./site/pages/payments', function (module, exports, __dirname, __filename, process) {
    var Page, Payments, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Payments = function (superClass) {
      extend(Payments, superClass);
      function Payments() {
        return Payments.__super__.constructor.apply(this, arguments)
      }
      Payments.prototype.tag = 'page-payments';
      Payments.prototype.icon = 'fa fa-money';
      Payments.prototype.name = 'Payments';
      Payments.prototype.html = rqzt('./templates/dash/site/pages/payments');
      Payments.prototype.collection = 'payments';
      return Payments
    }(Page);
    Payments.register();
    module.exports = Payments
  });
  // source: assets/js/dash/templates/dash/site/pages/payments.html
  rqzt.define('./templates/dash/site/pages/payments', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Payments View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <div class="panel animated fadeIn">\n      <div class="panel-heading">\n        Payments\n      </div>\n      <div class="panel-body">\n          <!-- Payments View Content -->\n        <payment-paged-table>\n          <div>\n            <i class="fa fa-money" style="font-size:50px"></i>\n            <h2 class="text-center">No Payments Found</h2>\n          </div>\n        </payment-paged-table>\n        <!-- END Payments View Content -->\n      </div>\n    </div>\n  </div>\n</div>\n<!-- END Payments View Block -->\n\n'
  });
  // source: assets/js/dash/site/pages/product.coffee
  rqzt.define('./site/pages/product', function (module, exports, __dirname, __filename, process) {
    var Page, Product, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Product = function (superClass) {
      extend(Product, superClass);
      function Product() {
        return Product.__super__.constructor.apply(this, arguments)
      }
      Product.prototype.tag = 'page-product';
      Product.prototype.icon = 'glyphicon glyphicon-book';
      Product.prototype.name = 'Product';
      Product.prototype.html = rqzt('./templates/dash/site/pages/product');
      Product.prototype.collection = 'product';
      return Product
    }(Page);
    Product.register();
    module.exports = Product
  });
  // source: assets/js/dash/templates/dash/site/pages/product.html
  rqzt.define('./templates/dash/site/pages/product', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Product information Form Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <!-- Product information Form Content -->\n    <product-form id="{opts._id}">\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb10" style="padding:0">\n              <div class="col-md-5">\n                <control label="Name" input="{ inputs.name }"></control>\n                <control label="Slug" input="{ inputs.slug }"></control>\n              </div>\n              <div class="col-md-7">\n                <control label="Description" input="{ inputs.description }"></control>\n              </div>\n            </div>\n            <div class="col-xs-7">\n              <div class="panel animated fadeIn">\n                <div class="panel-heading">\n                  Pricing\n                </div>\n                <div class="panel-body">\n                  <control label="Currency" input="{ inputs.currency }"></control>\n                  <control label="List Price (How much this should be listed at)" input="{ inputs.listPrice }"></control>\n                  <control label="Price (How much this is being sold for)" input="{ inputs.price }"></control>\n                </div>\n              </div>\n            </div>\n            <div class="col-xs-5">\n              <div class="panel animated fadeIn">\n                <div class="panel-heading">\n                  Shipping/Availability\n                </div>\n                <div class="panel-body">\n                  <control label="Size (L x W x H)" input="{ inputs.size }"></control>\n                  <control label="Weight (grams)" input="{ inputs.weight }"></control>\n                  <control label="In Stock" input="{ inputs.available }"></control>\n                  <control label="Estimated Delivery" input="{ inputs.estimatedDelivery }"></control>\n                </div>\n              </div>\n            </div>\n            <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n              <span class="error-container help-block animated fadeInUp">{error.message}</span>\n            </div>\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-xs-6">\n                <button type="submit" class="btn btn-block btn-dark">Save</button>\n              </div>\n              <div class="col-xs-3">\n                <button type="reset" class="btn btn-block btn-default">Reset</button>\n              </div>\n              <div class="col-xs-3">\n                <button type="button" class="btn btn-block btn-default" onclick="{ deleteModal }">Delete</button>\n              </div>\n\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="col-md-4">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Statistics\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <control label="Id" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n            </div>\n          </div>\n        </div>\n      </div>\n    </product-form>\n    <!-- END Product information Form Content -->\n  </div>\n</div>\n<!-- END Product information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/products.coffee
  rqzt.define('./site/pages/products', function (module, exports, __dirname, __filename, process) {
    var Page, Products, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Products = function (superClass) {
      extend(Products, superClass);
      function Products() {
        return Products.__super__.constructor.apply(this, arguments)
      }
      Products.prototype.tag = 'page-products';
      Products.prototype.icon = 'glyphicon glyphicon-book';
      Products.prototype.name = 'Products';
      Products.prototype.html = rqzt('./templates/dash/site/pages/products');
      Products.prototype.collection = 'products';
      return Products
    }(Page);
    Products.register();
    module.exports = Products
  });
  // source: assets/js/dash/templates/dash/site/pages/products.html
  rqzt.define('./templates/dash/site/pages/products', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Products View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <product-form>\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Products\n        </div>\n        <div class="panel-body">\n          <!-- Products View Content -->\n          <product-paged-table obs="{obs}">\n            <div>\n              <i class="glyphicon glyphicon-book" style="font-size:50px"></i>\n              <h2 class="text-center">No Products Found</strong>.</h2>\n            </div>\n          </product-paged-table>\n          <!-- END Products View Content -->\n        </div>\n      </div>\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Add a Product\n        </div>\n        <div class="panel-body">\n          <div class="section col-xs-12 mb20" style="padding:0">\n            <div class="col-md-5">\n              <control label="Name" input="{ inputs.name }"></control>\n              <control label="Slug" input="{ inputs.slug }"></control>\n            </div>\n            <div class="col-md-7">\n              <control label="Description" input="{ inputs.description }"></control>\n            </div>\n          </div>\n          <div class="col-xs-6">\n            <div class="panel animated fadeIn">\n              <div class="panel-heading">\n                Pricing\n              </div>\n              <div class="panel-body">\n                <control label="Currency" input="{ inputs.currency }"></control>\n                <control label="List Price (How much this should be listed at)" input="{ inputs.listPrice }"></control>\n                <control label="Price (How much this is being sold for)" input="{ inputs.price }"></control>\n              </div>\n            </div>\n          </div>\n          <div class="col-xs-6">\n            <div class="panel animated fadeIn">\n              <div class="panel-heading">\n                Shipping/Availability\n              </div>\n              <div class="panel-body">\n                <control label="Size (L x W x H)" input="{ inputs.size }"></control>\n                <control label="Weight (grams)" input="{ inputs.weight }"></control>\n                <div class="col-md-6">\n                  <control label="In Stock" input="{ inputs.available }"></control>\n                </div>\n                <div class="col-md-6">\n                  <control label="Estimated Delivery" input="{ inputs.estimatedDelivery }"></control>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div class="form-actions section text-center">\n            <div class="col-xs-4 col-xs-offset-4">\n              <button type="submit" class="btn btn-block btn-dark">Add</button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </product-form>\n  </div>\n</div>\n<!-- END Products View Block -->\n\n'
  });
  // source: assets/js/dash/site/pages/coupon.coffee
  rqzt.define('./site/pages/coupon', function (module, exports, __dirname, __filename, process) {
    var Coupon, Page, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Coupon = function (superClass) {
      extend(Coupon, superClass);
      function Coupon() {
        return Coupon.__super__.constructor.apply(this, arguments)
      }
      Coupon.prototype.tag = 'page-coupon';
      Coupon.prototype.icon = 'glyphicon glyphicon-tag';
      Coupon.prototype.name = 'Coupon';
      Coupon.prototype.html = rqzt('./templates/dash/site/pages/coupon');
      Coupon.prototype.collection = 'coupon';
      return Coupon
    }(Page);
    Coupon.register();
    module.exports = Coupon
  });
  // source: assets/js/dash/templates/dash/site/pages/coupon.html
  rqzt.define('./templates/dash/site/pages/coupon', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Coupon information Form Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <!-- Coupon information Form Content -->\n    <coupon-form id="{opts._id}">\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20" style="padding:0">\n              <div class="col-md-5">\n                <control label="Name" input="{ inputs.name }"></control>\n                <control label="Code" input="{ inputs.code }"></control>\n                <div class="col-md-6" style="padding-left:0">\n                  <control label="Enabled" input="{ inputs.enabled }"></control>\n                </div>\n                <div class="col-md-6" style="padding-right:0">\n                  <control label="Dynamic" input="{ inputs.dynamic }"></control>\n                </div>\n              </div>\n              <div class="col-md-7">\n                <control label="Coupon Type" input="{ inputs.type }"></control>\n                <div class="col-md-6" style="padding-left:0">\n                  <control label="Amount" input="{ inputs.amount }"></control>\n                </div>\n                <div class="col-md-6" style="padding-right:0">\n                  <control label="Product" input="{ inputs.productId }"></control>\n                </div>\n                <div class="col-md-6" style="padding-left:0">\n                  <control label="Limit" input="{ inputs.limit }"></control>\n                </div>\n              </div>\n            </div>\n\n            <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n              <span class="error-container help-block animated fadeInUp">{error.message}</span>\n            </div>\n\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-xs-6">\n                <button type="submit" class="btn btn-block btn-dark">Save</button>\n              </div>\n              <div class="col-xs-3">\n                <button type="reset" class="btn btn-block btn-default">Reset</button>\n              </div>\n              <div class="col-xs-3">\n                <button type="button" class="btn btn-block btn-default" onclick="{ deleteModal }">Delete</button>\n              </div>\n\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="col-md-4">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Statistics\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <control label="Id" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n            </div>\n          </div>\n        </div>\n      </div>\n    </coupon-form>\n    <!-- END Coupon information Form Content -->\n  </div>\n<div>\n<!-- END Coupon information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/coupons.coffee
  rqzt.define('./site/pages/coupons', function (module, exports, __dirname, __filename, process) {
    var Coupons, Page, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Coupons = function (superClass) {
      extend(Coupons, superClass);
      function Coupons() {
        return Coupons.__super__.constructor.apply(this, arguments)
      }
      Coupons.prototype.tag = 'page-coupons';
      Coupons.prototype.icon = 'glyphicon glyphicon-tag';
      Coupons.prototype.name = 'Coupons';
      Coupons.prototype.html = rqzt('./templates/dash/site/pages/coupons');
      Coupons.prototype.collection = 'coupons';
      return Coupons
    }(Page);
    Coupons.register();
    module.exports = Coupons
  });
  // source: assets/js/dash/templates/dash/site/pages/coupons.html
  rqzt.define('./templates/dash/site/pages/coupons', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Coupons View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <coupon-form>\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Coupons\n        </div>\n        <div class="panel-body">\n          <!-- New Coupon Form-->\n          <!-- END New Coupon Form-->\n          <!-- Coupons View Content -->\n          <coupon-paged-table obs="{obs}">\n            <div>\n              <i class="glyphicon glyphicon-tag" style="font-size:50px"></i>\n              <h2 class="text-center">No Coupons Found</h2>\n            </div>\n          </coupon-paged-table>\n          <!-- END Coupons View Content -->\n        </div>\n      </div>\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Add a Coupon\n        </div>\n        <div class="panel-body">\n          <div class="section col-xs-12 mb20" style="padding:0">\n            <div class="col-md-6">\n              <control label="Name" input="{ inputs.name }"></control>\n              <control label="Code" input="{ inputs.code }"></control>\n              <div class="col-md-6" style="padding-left:0">\n                <control label="Enabled" input="{ inputs.enabled }"></control>\n              </div>\n              <div class="col-md-6" style="padding-right:0">\n                <control label="Dynamic" input="{ inputs.dynamic }"></control>\n              </div>\n            </div>\n            <div class="col-md-6">\n              <control label="Coupon Type" input="{ inputs.type }"></control>\n              <div class="col-md-6" style="padding-left:0">\n                <control label="Amount" input="{ inputs.amount }"></control>\n              </div>\n              <div class="col-md-6" style="padding-right:0">\n                <control label="Product" input="{ inputs.productId }"></control>\n              </div>\n              <div class="col-md-6" style="padding-left:0">\n                <control label="Limit" input="{ inputs.limit }"></control>\n              </div>\n            </div>\n          </div>\n          <div class="section col-xs-12" style="padding:0">\n            <div class="col-md-6">\n            </div>\n            <div class="col-md-6">\n            </div>\n          </div>\n          <div class="form-actions section text-center">\n            <div class="col-xs-4 col-xs-offset-4">\n              <button type="submit" class="btn btn-block btn-dark">Add</button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </coupon-form>\n  </div>\n</div>\n<!-- END Coupons View Block -->\n\n'
  });
  // source: assets/js/dash/site/pages/store.coffee
  rqzt.define('./site/pages/store', function (module, exports, __dirname, __filename, process) {
    var Page, Store, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Store = function (superClass) {
      extend(Store, superClass);
      function Store() {
        return Store.__super__.constructor.apply(this, arguments)
      }
      Store.prototype.tag = 'page-store';
      Store.prototype.icon = 'glyphicon glyphicon-home';
      Store.prototype.name = 'Store';
      Store.prototype.html = rqzt('./templates/dash/site/pages/store');
      Store.prototype.collection = 'store';
      return Store
    }(Page);
    Store.register();
    module.exports = Store
  });
  // source: assets/js/dash/templates/dash/site/pages/store.html
  rqzt.define('./templates/dash/site/pages/store', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Store information Form Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <!-- Store information Form Content -->\n    <store-form id="{opts._id}">\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20" style="padding:0">\n              <div class="col-md-4">\n                <control label="Name" input="{ inputs.name }"></control>\n              </div>\n              <div class="col-md-4">\n                <control label="Slug" input="{ inputs.slug }"></control>\n              </div>\n              <div class="col-md-4">\n                <control label="Currency" input="{ inputs.currency }"></control>\n              </div>\n            </div>\n            <div class="section col-xs-12 mb20">\n              <listing-widget obs="{obs}">\n              </listing-widget>\n            </div>\n\n            <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n              <span class="error-container help-block animated fadeInUp">{error.message}</span>\n            </div>\n\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-xs-6">\n                <button type="submit" class="btn btn-block btn-dark">Save</button>\n              </div>\n              <div class="col-xs-3">\n                <button type="reset" class="btn btn-block btn-default">Reset</button>\n              </div>\n              <div class="col-xs-3">\n                <button type="button" class="btn btn-block btn-default" onclick="{ deleteModal }">Delete</button>\n              </div>\n\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="col-md-4">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Statistics\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <control label="Id" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n            </div>\n          </div>\n        </div>\n      </div>\n    </store-form>\n    <!-- END Store information Form Content -->\n  </div>\n</div>\n<!-- END Store information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/stores.coffee
  rqzt.define('./site/pages/stores', function (module, exports, __dirname, __filename, process) {
    var Page, Stores, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Stores = function (superClass) {
      extend(Stores, superClass);
      function Stores() {
        return Stores.__super__.constructor.apply(this, arguments)
      }
      Stores.prototype.tag = 'page-stores';
      Stores.prototype.icon = 'glyphicon glyphicon-home';
      Stores.prototype.name = 'Stores';
      Stores.prototype.html = rqzt('./templates/dash/site/pages/stores');
      Stores.prototype.collection = 'stores';
      return Stores
    }(Page);
    Stores.register();
    module.exports = Stores
  });
  // source: assets/js/dash/templates/dash/site/pages/stores.html
  rqzt.define('./templates/dash/site/pages/stores', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Stores View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <store-form>\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Stores\n        </div>\n        <div class="panel-body">\n          <!-- Stores View Content -->\n          <store-paged-table obs="{obs}">\n            <div>\n              <i class="glyphicon glyphicon-home" style="font-size:50px"></i>\n              <h2 class="text-center">No Stores Found</strong>.</h2>\n            </div>\n          </store-paged-table>\n          <!-- END Stores View Content -->\n        </div>\n      </div>\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Add a Store\n        </div>\n        <div class="panel-body">\n          <div class="section col-xs-12 mb20" style="padding:0">\n            <div class="col-md-4">\n              <control label="Name" input="{ inputs.name }"></control>\n            </div>\n            <div class="col-md-4">\n              <control label="Slug" input="{ inputs.slug }"></control>\n            </div>\n            <div class="col-md-4">\n              <control label="Currency" input="{ inputs.currency }"></control>\n            </div>\n          </div>\n          <div class="section col-xs-12 mb20">\n            <listing-widget obs="{obs}">\n            </listing-widget>\n          </div>\n          <div class="form-actions section text-center">\n            <div class="col-xs-4 col-xs-offset-4">\n              <button type="submit" class="btn btn-block btn-dark">Add</button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </store-form>\n  </div>\n</div>\n<!-- END Stores View Block -->\n'
  });
  // source: assets/js/dash/site/pages/mailinglist.coffee
  rqzt.define('./site/pages/mailinglist', function (module, exports, __dirname, __filename, process) {
    var MailingList, Page, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    MailingList = function (superClass) {
      extend(MailingList, superClass);
      function MailingList() {
        return MailingList.__super__.constructor.apply(this, arguments)
      }
      MailingList.prototype.tag = 'page-mailinglist';
      MailingList.prototype.icon = 'fa fa-envelope';
      MailingList.prototype.name = 'Mailing List';
      MailingList.prototype.html = rqzt('./templates/dash/site/pages/mailinglist');
      MailingList.prototype.collection = 'mailinglist';
      MailingList.prototype.js = function () {
        MailingList.__super__.js.apply(this, arguments);
        return this.on('update', function () {
          return requestAnimationFrame(function () {
            var $code, e;
            try {
              $code = $('pre code');
              if ($code.html().indexOf('undefined') > -1) {
                return
              }
              return $code.each(function (i, block) {
                return hljs.highlightBlock(block)
              })
            } catch (error) {
              e = error;
              return e
            }
          })
        })
      };
      return MailingList
    }(Page);
    MailingList.register();
    module.exports = MailingList
  });
  // source: assets/js/dash/templates/dash/site/pages/mailinglist.html
  rqzt.define('./templates/dash/site/pages/mailinglist', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Mailing List View Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <mailinglist-form id="{opts._id}">\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20" style="padding:0">\n              <div class="col-md-5">\n                <control label="Name" input="{ inputs.name }"></control>\n                <control label="Choose what happens after form submit" input="{ inputs[\'thankyou.type\'] }"></control>\n              </div>\n              <div class="col-md-7">\n                <control label="HTML Template or URL (Ignore if using default form action)" input="{ inputs[\'thankyou.html\'] }"></control>\n              </div>\n            </div>\n            <div class="section col-xs-12" style="padding:0">\n              <div class="panel animated fadeIn">\n                <div class="panel-heading">\n                  MailChimp\n                </div>\n                <div class="panel-body">\n                  <div class="col-xs-6">\n                    <control label="MailChimp List ID"  input="{ inputs[\'mailchimp.id\'] }"></control>\n                    <control label="MailChimp API Key"  input="{ inputs[\'mailchimp.apiKey\'] }"></control>\n                  </div>\n                  <div class="col-xs-6">\n                    <div class="col-xs-6">\n                      <control label="Double Optin?"       input="{ inputs[\'mailchimp.doubleOptin\'] }"></control>\n                    </div>\n                    <div class="col-xs-6">\n                      <control label="Update Existing?"   input="{ inputs[\'mailchimp.updateExisting\'] }"></control>\n                    </div>\n                    <div class="col-xs-6">\n                      <control label="Replace Interests?" input="{ inputs[\'mailchimp.replaceInterests\'] }"></control>\n                    </div>\n                    <div class="col-xs-6">\n                      <control label="Send Welcome?"      input="{ inputs[\'mailchimp.sendWelcome\'] }"></control>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div class="col-md-6">\n                <div class="panel animated fadeIn">\n                  <div class="panel-heading">\n                    Google Analytics\n                  </div>\n                  <div class="panel-body">\n                    <control label="Google Analytics Event Name"    input="{ inputs[\'google.name\'] }"></control>\n                    <control label="Google Analytics Category"      input="{ inputs[\'google.category\'] }"></control>\n                  </div>\n                </div>\n              </div>\n              <div class="col-md-6">\n                <div class="panel animated fadeIn">\n                  <div class="panel-heading">\n                    Facebook Analytics\n                  </div>\n                  <div class="panel-body">\n                    <control label="Facebook Event Id"          input="{ inputs[\'facebook.id\'] }"></control>\n                    <control label="Facebook Event Value"       input="{ inputs[\'facebook.value\'] }"></control>\n                    <control label="Facebook Event Currency"    input="{ inputs[\'facebook.currency\'] }"></control>\n                  </div>\n                </div>\n              </div>\n\n              <div class="section col-xs-12 mb10 has-error" if="{error}" style="padding:0">\n                <span class="error-container help-block animated fadeInUp">{error.message}</span>\n              </div>\n\n              <div class="form-actions section col-xs-12" style="padding:0">\n                <div class="col-xs-6">\n                  <button type="submit" class="btn btn-block btn-dark">Save</button>\n                </div>\n                <div class="col-xs-3">\n                  <button type="reset" class="btn btn-block btn-default">Reset</button>\n                </div>\n                <div class="col-xs-3">\n                  <button type="button" class="btn btn-block btn-default" onclick="{ deleteModal }">Delete</button>\n                </div>\n\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Snippet\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <ol>\n                <li>Copy snippet below</li>\n                <li>Paste in your HTML Form</li>\n                <li>\n                  Your HTML code should look something like:\n                </li>\n              </ol>\n              <div class="section pl15 pr15">\n                <pre class="highlight br bw2 br-grey br-dashed br0 p10 mn hljs xml"><code>  &lt;form&gt;\n    &lt;script src="{ api.url + \'/mailinglist/\' + model.id }/js"&gt;&lt;/script&gt;\n    Email&lt;input name="email" value="your@email.com"&gt;\n    &lt;button type="submit"&gt;Sign me up!&lt;/button&gt;\n  &lt;/form&gt;</code></pre>\n              </div>\n              <div class="section p15">\n                <textarea style="width:100%"><script src="{ api.url + \'/mailinglist/\' + model.id }/js"></script></textarea>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="col-md-4">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Statistics\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <control label="Id" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n            </div>\n          </div>\n        </div>\n      </div>\n    </mailinglist-form>\n  </div>\n</div>\n<!-- END Mailing List View Block -->\n'
  });
  // source: assets/js/dash/site/pages/mailinglists.coffee
  rqzt.define('./site/pages/mailinglists', function (module, exports, __dirname, __filename, process) {
    var MailingLists, Page, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    MailingLists = function (superClass) {
      extend(MailingLists, superClass);
      function MailingLists() {
        return MailingLists.__super__.constructor.apply(this, arguments)
      }
      MailingLists.prototype.tag = 'page-mailinglists';
      MailingLists.prototype.icon = 'fa fa-envelope';
      MailingLists.prototype.name = 'Mailing Lists';
      MailingLists.prototype.html = rqzt('./templates/dash/site/pages/mailinglists');
      MailingLists.prototype.collection = 'mailinglists';
      return MailingLists
    }(Page);
    MailingLists.register();
    module.exports = MailingLists
  });
  // source: assets/js/dash/templates/dash/site/pages/mailinglists.html
  rqzt.define('./templates/dash/site/pages/mailinglists', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Mailing Lists View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <mailinglist-form>\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Mailing Lists\n        </div>\n        <div class="panel-body">\n            <!-- Mailing Lists View Content -->\n            <mailinglist-paged-table obs="{obs}">\n            <div>\n              <i class="fa fa-envelope" style="font-size:50px"></i>\n              <h2 class="text-center">No Mailing Lists Found</h2>\n            </div>\n          </mailinglist-paged-table>\n          <!-- END Mailing Lists View Content -->\n        </div>\n      </div>\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Add a Mailing List\n        </div>\n        <div class="panel-body">\n          <div class="section col-xs-12 mb20" style="padding:0">\n            <div class="col-md-5">\n              <control label="Name" input="{ inputs.name }"></control>\n              <control label="Choose what happens after form submit" input="{ inputs[\'thankyou.type\'] }"></control>\n            </div>\n            <div class="col-md-7">\n              <control label="HTML Template or URL (Ignore if using default form action)" input="{ inputs[\'thankyou.html\'] }"></control>\n            </div>\n          </div>\n          <div class="section col-xs-12" style="padding:0">\n            <div class="panel animated fadeIn">\n              <div class="panel-heading">\n                MailChimp\n              </div>\n              <div class="panel-body">\n                <div class="col-xs-6">\n                  <control label="MailChimp List ID"  input="{ inputs[\'mailchimp.id\'] }"></control>\n                  <control label="MailChimp API Key"  input="{ inputs[\'mailchimp.apiKey\'] }"></control>\n                </div>\n                <div class="col-xs-6">\n                  <div class="col-xs-6">\n                    <control label="Double Optin?"       input="{ inputs[\'mailchimp.doubleOptin\'] }"></control>\n                  </div>\n                  <div class="col-xs-6">\n                    <control label="Update Existing?"   input="{ inputs[\'mailchimp.updateExisting\'] }"></control>\n                  </div>\n                  <div class="col-xs-6">\n                    <control label="Replace Interests?" input="{ inputs[\'mailchimp.replaceInterests\'] }"></control>\n                  </div>\n                  <div class="col-xs-6">\n                    <control label="Send Welcome?"      input="{ inputs[\'mailchimp.sendWelcome\'] }"></control>\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div class="col-md-6">\n              <div class="panel animated fadeIn">\n                <div class="panel-heading">\n                  Google Analytics\n                </div>\n                <div class="panel-body">\n                  <control label="Google Analytics Event Name"    input="{ inputs[\'google.name\'] }"></control>\n                  <control label="Google Analytics Category"      input="{ inputs[\'google.category\'] }"></control>\n                </div>\n              </div>\n            </div>\n            <div class="col-md-6">\n              <div class="panel animated fadeIn">\n                <div class="panel-heading">\n                  Facebook Analytics\n                </div>\n                <div class="panel-body">\n                  <control label="Facebook Event Id"          input="{ inputs[\'facebook.id\'] }"></control>\n                  <control label="Facebook Event Value"       input="{ inputs[\'facebook.value\'] }"></control>\n                  <control label="Facebook Event Currency"    input="{ inputs[\'facebook.currency\'] }"></control>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div class="form-actions section text-center">\n            <div class="col-xs-4 col-xs-offset-4">\n              <button type="submit" class="btn btn-block btn-dark">Add</button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </mailinglist-form>\n  </div>\n</div>\n<!-- END Mailing Lists View Block -->\n'
  });
  // source: assets/js/dash/site/pages/subscriber.coffee
  rqzt.define('./site/pages/subscriber', function (module, exports, __dirname, __filename, process) {
    var Page, Subscriber, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Subscriber = function (superClass) {
      extend(Subscriber, superClass);
      function Subscriber() {
        return Subscriber.__super__.constructor.apply(this, arguments)
      }
      Subscriber.prototype.tag = 'page-subscriber';
      Subscriber.prototype.icon = 'fa fa-newspaper-o';
      Subscriber.prototype.name = 'Subscriber';
      Subscriber.prototype.html = rqzt('./templates/dash/site/pages/subscriber');
      Subscriber.prototype.collection = 'subscriber';
      return Subscriber
    }(Page);
    Subscriber.register();
    module.exports = Subscriber
  });
  // source: assets/js/dash/templates/dash/site/pages/subscriber.html
  rqzt.define('./templates/dash/site/pages/subscriber', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Subscriber information Form Block -->\n<div class="tray tray-center">\n  <div class="block col-xs-12">\n    <!-- Subscriber information Form Content -->\n    <subscriber-form id="{opts._id}">\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb10">\n              <control label="Email" input="{ inputs.email }"></control>\n              <control label="Unsubscribed?" input="{ inputs.unsubscribed }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              <control label="Additional JSON Data" input="{ inputs.metadata }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n            </div>\n          </div>\n        </div>\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Metadata\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12">\n              <div class="section row">\n                <control label="IP" input="{ inputs[\'client.ip\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Referrer" input="{ inputs[\'client.referer\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="User Agent" input="{ inputs[\'client.userAgent\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Language" input="{ inputs[\'client.language\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="City" input="{ inputs[\'client.city\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Region" input="{ inputs[\'client.region\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Country" input="{ inputs[\'client.country\'] }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="col-md-4">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Statistics\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12" style="padding:0">\n              <div class="section row">\n                <control label="ID" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Mailing List ID" input="{ inputs.mailingListId }" labelclasses="col-xs-3" controlclasses="col-xs-9"></control>\n              </div>\n              <div class="section row">\n                <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n              <div class="section row">\n                <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            User Information\n          </div>\n          <div class="panel-body">\n            <subscriber-user-static-form obs="{ obs }">\n              <div if="{ !error }">\n                <div class="section col-xs-12" style="padding:0">\n                  <div class="section row">\n                    <control label="ID" input="{ inputs.id }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Email" input="{ inputs.email }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="First Name" input="{ inputs.firstName }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Last Name" input="{ inputs.lastName }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Phone" input="{ inputs.phone }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                  <div class="section row">\n                    <control label="Created" input="{ inputs.createdAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                 </div>\n                  <div class="section row mb20">\n                    <control label="Last Updated" input="{ inputs.updatedAt }" labelclasses="col-xs-4" controlclasses="col-xs-8"></control>\n                  </div>\n                </div>\n              </div>\n              <h4 if="{ error }" class="text-center mb20">\n                User unlinked or deleted.\n              </h4>\n            </subscriber-user-static-form>\n          </div>\n        </div>\n      </div>\n    </subscriber-form>\n    <!-- END Subscriber information Form Content -->\n  </div>\n</div>\n<!-- END Subscriber information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/subscribers.coffee
  rqzt.define('./site/pages/subscribers', function (module, exports, __dirname, __filename, process) {
    var Page, Subscribers, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Subscribers = function (superClass) {
      extend(Subscribers, superClass);
      function Subscribers() {
        return Subscribers.__super__.constructor.apply(this, arguments)
      }
      Subscribers.prototype.tag = 'page-subscribers';
      Subscribers.prototype.icon = 'fa fa-newspaper-o';
      Subscribers.prototype.name = 'Subscribers';
      Subscribers.prototype.html = rqzt('./templates/dash/site/pages/subscribers');
      Subscribers.prototype.collection = 'subscribers';
      return Subscribers
    }(Page);
    Subscribers.register();
    module.exports = Subscribers
  });
  // source: assets/js/dash/templates/dash/site/pages/subscribers.html
  rqzt.define('./templates/dash/site/pages/subscribers', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Subscribers View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <div class="panel animated fadeIn">\n      <div class="panel-heading">\n        Subscribers\n      </div>\n      <div class="panel-body">\n          <!-- Subscribers View Content -->\n        <subscriber-paged-table>\n          <div>\n            <i class="fa fa-newspaper-o" style="font-size:50px"></i>\n            <h2 class="text-center">No Subscribers Found</h2>\n          </div>\n        </subscriber-paged-table>\n        <!-- END Subscribers View Content -->\n      </div>\n    </div>\n  </div>\n</div>\n<!-- END Subscribers View Block -->\n\n'
  });
  // source: assets/js/dash/site/pages/profile.coffee
  rqzt.define('./site/pages/profile', function (module, exports, __dirname, __filename, process) {
    var Page, Profile, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Profile = function (superClass) {
      extend(Profile, superClass);
      function Profile() {
        return Profile.__super__.constructor.apply(this, arguments)
      }
      Profile.prototype.tag = 'page-profile';
      Profile.prototype.icon = 'glyphicon glyphicon-user';
      Profile.prototype.name = 'Profile';
      Profile.prototype.html = rqzt('./templates/dash/site/pages/profile');
      Profile.prototype.apiName = 'dash';
      Profile.prototype.collection = 'profile';
      return Profile
    }(Page);
    Profile.register();
    module.exports = Profile
  });
  // source: assets/js/dash/templates/dash/site/pages/profile.html
  rqzt.define('./templates/dash/site/pages/profile', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Profile information Form Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <!-- Profile information Form Content -->\n    <profile-admin-form>\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Contact Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20">\n              <control label="First Name" input="{ inputs.firstName }"></control>\n              <control label="Last Name" input="{ inputs.lastName }"></control>\n              <control label="Email" input="{ inputs.email }"></control>\n              <control label="Phone Number" input="{ inputs.phone }"></control>\n              <div class="has-error" if="{error}">\n                <span class="error-container help-block animated fadeInUp">{error.message}</span>\n              </div>\n            </div>\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-xs-4 col-xs-offset-4">\n                <button type="submit" class="btn btn-block btn-dark">Save</button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </profile-admin-form>\n    <new-password-admin-form>\n      <div class="col-md-4">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Change Password\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20">\n              <control label="Old Password" input="{ inputs.oldPassword }"></control>\n              <control label="New Password" input="{ inputs.password }"></control>\n              <control label="Confirm Password" input="{ inputs.confirmPassword }"></control>\n              <div class="has-error" if="{error}">\n                <span class="error-container help-block animated fadeInUp">{error.message}</span>\n              </div>\n            </div>\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-md-12 col-md-offset-0 col-xs-4 col-xs-offset-4">\n                <button type="submit" class="btn btn-block btn-dark">Update Password</button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </new-password-admin-form>\n    <!-- END Profile information Form Content -->\n  </div>\n  <div class="block row">\n    <!-- Profile information Form Content -->\n    <profile-admin-form>\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Contact Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20">\n              <control label="First Name" input="{ inputs.firstName }"></control>\n              <control label="Last Name" input="{ inputs.lastName }"></control>\n              <control label="Email" input="{ inputs.email }"></control>\n              <control label="Phone Number" input="{ inputs.phone }"></control>\n              <div class="has-error" if="{error}">\n                <span class="error-container help-block animated fadeInUp">{error.message}</span>\n              </div>\n            </div>\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-xs-4 col-xs-offset-4">\n                <button type="submit" class="btn btn-block btn-dark">Save</button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </profile-admin-form>\n    <new-password-admin-form>\n      <div class="col-md-4">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Change Password\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20">\n              <control label="Old Password" input="{ inputs.oldPassword }"></control>\n              <control label="New Password" input="{ inputs.password }"></control>\n              <control label="Confirm Password" input="{ inputs.confirmPassword }"></control>\n              <div class="has-error" if="{error}">\n                <span class="error-container help-block animated fadeInUp">{error.message}</span>\n              </div>\n            </div>\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-md-12 col-md-offset-0 col-xs-4 col-xs-offset-4">\n                <button type="submit" class="btn btn-block btn-dark">Update Password</button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </new-password-admin-form>\n    <!-- END Profile information Form Content -->\n  </div>\n</div>\n<!-- END Profile information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/api.coffee
  rqzt.define('./site/pages/api', function (module, exports, __dirname, __filename, process) {
    var Api, Page, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Api = function (superClass) {
      extend(Api, superClass);
      function Api() {
        return Api.__super__.constructor.apply(this, arguments)
      }
      Api.prototype.tag = 'page-api';
      Api.prototype.icon = 'fa fa-key';
      Api.prototype.name = 'API';
      Api.prototype.html = rqzt('./templates/dash/site/pages/api');
      Api.prototype.collection = 'api';
      return Api
    }(Page);
    Api.register();
    module.exports = Api
  });
  // source: assets/js/dash/templates/dash/site/pages/api.html
  rqzt.define('./templates/dash/site/pages/api', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Api Keys View Block -->\n<div class="tray tray-center">\n  <div class="block">\n    <!-- Api Keys information Form Content -->\n    <api-keys-admin-form>\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            API Keys\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20">\n              <control label="Live Secret Key"    input="{ inputs[\'live-secret-key\'] }"></control>\n              <control label="Live Published Key" input="{ inputs[\'live-published-key\'] }"></control>\n              <control label="Test Secret Key"    input="{ inputs[\'test-secret-key\'] }"></control>\n              <control label="Test Published Key" input="{ inputs[\'test-published-key\'] }"></control>\n              <div class="has-error" if="{error}">\n                <span class="error-container help-block animated fadeInUp">{error.message}</span>\n              </div>\n            </div>\n            <div class="form-actions section text-center">\n              <div class="col-xs-4 col-xs-offset-4">\n                <button type="button" class="btn btn-block btn-dark" onclick="{ generateModal }">\n                  Generate New Keys\n                </button>\n              </div>\n\n            </div>\n          </div>\n        </div>\n      </div>\n    </api-keys-admin-form>\n  </div>\n</div>\n<!-- END Api Keys View Block -->\n\n'
  });
  // source: assets/js/dash/site/pages/organization.coffee
  rqzt.define('./site/pages/organization', function (module, exports, __dirname, __filename, process) {
    var Organization, Page, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Organization = function (superClass) {
      extend(Organization, superClass);
      function Organization() {
        return Organization.__super__.constructor.apply(this, arguments)
      }
      Organization.prototype.tag = 'page-organization';
      Organization.prototype.icon = 'fa fa-sitemap';
      Organization.prototype.name = 'Organization';
      Organization.prototype.html = rqzt('./templates/dash/site/pages/organization');
      Organization.prototype.collection = 'organization';
      return Organization
    }(Page);
    Organization.register();
    module.exports = Organization
  });
  // source: assets/js/dash/templates/dash/site/pages/organization.html
  rqzt.define('./templates/dash/site/pages/organization', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Organization information Form Block -->\n<div class="tray tray-center">\n  <div class="block row">\n    <!-- Organization information Form Content -->\n    <organization-admin-form>\n      <div class="col-md-8">\n        <div class="panel animated fadeIn">\n          <div class="panel-heading">\n            Information\n          </div>\n          <div class="panel-body">\n            <div class="section col-xs-12 mb20">\n              <control label="Unique Identifer" input="{ inputs.name }" labelclasses="pln"></control>\n              <div class="section row">\n                <div class="col-xs-6">\n                  <control label="Organization Name" input="{ inputs.fullName }"></control>\n                </div>\n                <div class="col-xs-6">\n                  <control label="Website Url" input="{ inputs.website }"></control>\n                </div>\n              </div>\n              <h4 class="mt20">Email Patterns for Testing</h4>\n              <p>Users with emails matching these patterns will be changed 50 cents. </p>\n              <control label="Use command separated globs (ex. *@{model.name}.com,*@gmail.com)" input="{ inputs.emailWhitelist }"></control>\n              <div class="has-error" if="{error}">\n                <span class="error-container help-block animated fadeInUp">{error.message}</span>\n              </div>\n            </div>\n            <div class="form-actions section col-xs-12" style="padding:0">\n              <div class="col-xs-4 col-xs-offset-4">\n                <button type="submit" class="btn btn-block btn-dark">Save</button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </organization-admin-form>\n    <!-- END Organization information Form Content -->\n  </div>\n</div>\n<!-- END Organization information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/integrations.coffee
  rqzt.define('./site/pages/integrations', function (module, exports, __dirname, __filename, process) {
    var Api, Events, Integrations, Page, analyticsSnippet, crowdcontrol, integrations, riot, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    riot = rqzt('riot/riot');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    Api = crowdcontrol.data.Api;
    Page = rqzt('./site/pages/page');
    integrations = rqzt('./widget/integrations');
    analyticsSnippet = '<!-- Crowdstart analytics tag -->\n<script>\n  !function(t,e,a){var r,n,c,i,o,s,l,u;if(null==t.analytics){for(r=[],r.methods=["ab","alias","group","identify","off","on","once","page","pageview","ready","track","trackClick","trackForm","trackLink","trackSubmit"],l=r.methods,c=function(t){r[t]=function(){var e;return e=Array.prototype.slice.call(arguments),e.unshift(t),r.push(e),r}},i=0,o=l.length;o>i;i++)s=l[i],c(s);return u=e.createElement("script"),u.async=!0,u.type="text/javascript",u.src=a,n=e.getElementsByTagName("script")[0],n.parentNode.insertBefore(u,n),t.analytics=r}}(window,document,"//cdn.hanzo.io/a/{orgId}.js");\n</script>';
    Integrations = function (superClass) {
      extend(Integrations, superClass);
      function Integrations() {
        return Integrations.__super__.constructor.apply(this, arguments)
      }
      Integrations.prototype.tag = 'page-integrations';
      Integrations.prototype.icon = 'fa fa-credit-card';
      Integrations.prototype.name = 'Integrations';
      Integrations.prototype.html = rqzt('./templates/dash/site/pages/integrations');
      Integrations.prototype.tab = 'paymentprocessors';
      Integrations.prototype.dragging = false;
      Integrations.prototype.draggingIntegration = null;
      Integrations.prototype.showSave = false;
      Integrations.prototype.saving = false;
      Integrations.prototype.events = {
        dragstart: function (e, model) {
          if ((model != null ? model.integration : void 0) != null) {
            this.dragging = true;
            this.draggingIntegration = model.integration;
            return this.update()
          }
        },
        dragend: function (e, model) {
          if ((model != null ? model.integration : void 0) != null) {
            if ((model != null ? model.integration : void 0) !== this.draggingIntegration) {
              return
            }
            this.dragging = false;
            this.draggingIntegration = null;
            return this.update()
          }
        },
        drop: function (e) {
          if (this.draggingIntegration != null) {
            return this.addIntegration(this.draggingIntegration, this.tab)
          }
        }
      };
      Integrations.prototype.addIntegration = function (integration, tab, model) {
        var i, obs;
        if (model == null) {
          model = {}
        }
        i = this.integrations[tab].length;
        this.integrations[tab].push(integration);
        this.models[tab].push(model);
        obs = {};
        riot.observable(obs);
        this.obses[tab].push(obs);
        obs.on(Events.Integration.Remove, function (_this) {
          return function () {
            obs.off(Events.Integration.Remove);
            console.log('remove', i);
            delete _this.integrations[tab][i];
            delete _this.models[tab][i];
            delete _this.obses[tab][i];
            return riot.update()
          }
        }(this));
        obs.on(Events.Integration.Update, function (_this) {
          return function () {
            console.log('update', i);
            _this.showSave = true;
            return riot.update()
          }
        }(this));
        return riot.update()
      };
      Integrations.prototype.save = function (event) {
        var j, len, m, model, ref;
        model = { integrations: [] };
        ref = this.models['analytics'];
        for (j = 0, len = ref.length; j < len; j++) {
          m = ref[j];
          if (m != null && m._validated) {
            model.integrations.push(m)
          }
        }
        this.saving = true;
        return this.api.post('c/organization/' + window.Organization + '/analytics', model).then(function (_this) {
          return function (res) {
            _this.saving = false;
            _this.showSave = false;
            _this.model = model;
            if (res.status !== 200 && res.status !== 201 && res.status !== 204) {
              throw new Error('Form failed to load: ')
            }
            return riot.update()
          }
        }(this))['catch'](function (_this) {
          return function (e) {
            console.log(e.stack);
            return _this.error = e
          }
        }(this))
      };
      Integrations.prototype.setType = function (t) {
        return function (_this) {
          return function (e) {
            _this.tab = t;
            e.preventDefault();
            return riot.update()
          }
        }(this)
      };
      Integrations.prototype.collection = 'integrations';
      Integrations.prototype.isTabEmpty = function (tab) {
        var integration, j, len, ref;
        ref = this.integrations[tab];
        for (j = 0, len = ref.length; j < len; j++) {
          integration = ref[j];
          if (integration) {
            return false
          }
        }
        return true
      };
      Integrations.prototype.js = function () {
        var api;
        Integrations.__super__.js.apply(this, arguments);
        this.analyticsSnippet = analyticsSnippet.replace('{orgId}', window.Organization);
        this.models = { analytics: [] };
        this.integrationClasses = {
          analytics: [
            integrations.Analytics.GoogleAnalytics,
            integrations.Analytics.GoogleAdwords,
            integrations.Analytics.FacebookConversions,
            integrations.Analytics.FacebookPixel,
            integrations.Analytics.Custom,
            integrations.Analytics.HeapAnalytics
          ]
        };
        this.integrations = { analytics: [] };
        this.obses = { analytics: [] };
        requestAnimationFrame(function () {
          var e, ref, ref1;
          try {
            if (typeof window !== 'undefined' && window !== null) {
              if ((ref = window.Core) != null) {
                ref.init()
              }
            }
            return typeof window !== 'undefined' && window !== null ? (ref1 = window.Core) != null ? ref1.init() : void 0 : void 0
          } catch (error) {
            e = error;
            return e
          }
        });
        this.on('update', function () {
          return $('.tray-right').outerHeight($('#content').outerHeight())
        });
        this.api = api = Api.get('crowdstart');
        return api.get('c/organization/' + window.Organization + '/analytics').then(function (_this) {
          return function (res) {
            var analyticsClass, j, k, len, len1, model, ref, ref1;
            if (res.status !== 200 && res.status !== 204) {
              throw new Error('Form failed to load: ')
            }
            _this.model = res.responseText;
            ref = _this.model.integrations;
            for (j = 0, len = ref.length; j < len; j++) {
              model = ref[j];
              ref1 = _this.integrationClasses.analytics;
              for (k = 0, len1 = ref1.length; k < len1; k++) {
                analyticsClass = ref1[k];
                if (model.type === analyticsClass.prototype.type) {
                  _this.addIntegration(analyticsClass, 'analytics', model);
                  break
                }
              }
            }
            return riot.update()
          }
        }(this))['catch'](function (_this) {
          return function (e) {
            console.log(e.stack);
            return _this.error = e
          }
        }(this))
      };
      return Integrations
    }(Page);
    Integrations.register();
    riot.tag('integration', '', function (opts) {
      var type;
      type = opts.type;
      if (type == null) {
        return
      }
      return riot.mount(this.root, type.prototype.tag, opts)
    });
    module.exports = Integrations
  });
  // source: assets/js/dash/widget/integrations/index.coffee
  rqzt.define('./widget/integrations', function (module, exports, __dirname, __filename, process) {
    module.exports = { Analytics: rqzt('./widget/integrations/analytics') }
  });
  // source: assets/js/dash/widget/integrations/analytics/index.coffee
  rqzt.define('./widget/integrations/analytics', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      Custom: rqzt('./widget/integrations/analytics/custom'),
      GoogleAdwords: rqzt('./widget/integrations/analytics/google-adwords'),
      GoogleAnalytics: rqzt('./widget/integrations/analytics/google-analytics'),
      FacebookPixel: rqzt('./widget/integrations/analytics/facebook-pixel'),
      HeapAnalytics: rqzt('./widget/integrations/analytics/heap'),
      FacebookConversions: rqzt('./widget/integrations/analytics/facebook-conversions')
    }
  });
  // source: assets/js/dash/widget/integrations/analytics/custom.coffee
  rqzt.define('./widget/integrations/analytics/custom', function (module, exports, __dirname, __filename, process) {
    var CustomAnalytics, Integration, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Integration = rqzt('./widget/integrations/integration');
    input = rqzt('./form/input');
    CustomAnalytics = function (superClass) {
      extend(CustomAnalytics, superClass);
      function CustomAnalytics() {
        return CustomAnalytics.__super__.constructor.apply(this, arguments)
      }
      CustomAnalytics.prototype.tag = 'custom-integration';
      CustomAnalytics.prototype.type = 'custom';
      CustomAnalytics.prototype.html = rqzt('./templates/dash/widget/integrations/analytics/custom');
      CustomAnalytics.prototype.img = '/img/integrations/custom.png';
      CustomAnalytics.prototype.text = 'Custom Analytics';
      CustomAnalytics.prototype.alt = 'Custom Analytics';
      CustomAnalytics.prototype.model = { code: '//Do Something in JS' };
      CustomAnalytics.prototype.inputConfigs = [
        input('event', 'Choose an event', 'analytics-events-select required'),
        input('code', '//Do Something in JS', 'js required'),
        input('sampling', '', 'numeric')
      ];
      return CustomAnalytics
    }(Integration);
    CustomAnalytics.register();
    module.exports = CustomAnalytics
  });
  // source: assets/js/dash/widget/integrations/integration.coffee
  rqzt.define('./widget/integrations/integration', function (module, exports, __dirname, __filename, process) {
    var Events, FormView, Integration, IntegrationHeader, View, crowdcontrol, instanceId, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    View = crowdcontrol.view.View;
    Events = crowdcontrol.Events;
    FormView = crowdcontrol.view.form.FormView;
    instanceId = 0;
    Events.Integration = {
      Update: 'integration-updated',
      Remove: 'integration-close'
    };
    Integration = function (superClass) {
      var obj;
      extend(Integration, superClass);
      function Integration() {
        return Integration.__super__.constructor.apply(this, arguments)
      }
      Integration.prototype.tag = 'basic-integration';
      Integration.prototype.type = 'basic-integration';
      Integration.prototype.html = '';
      Integration.prototype.instructions = 'Information on what to expect from the integration';
      Integration.prototype.img = '/img/integrations/basic.png';
      Integration.prototype.src = '';
      Integration.prototype.text = '';
      Integration.prototype.alt = 'Basic';
      Integration.prototype.name = 'Basic Integration';
      Integration.prototype.instanceId = -1;
      Integration.prototype.error = false;
      Integration.prototype.fakeSubmit = true;
      Integration.prototype.events = (obj = {}, obj['' + Events.Form.SubmitFailed] = function () {
        this.error = true;
        this.fakeSubmit = false;
        this.model._validated = false;
        return this.update()
      }, obj['' + Events.Form.SubmitSuccess] = function () {
        this.error = false;
        this.model._validated = true;
        return this.update()
      }, obj['' + Events.Input.Error] = function () {
        this.error = true;
        return this.update()
      }, obj['' + Events.Input.Set] = function () {
        this.submit();
        return this.update()
      }, obj);
      Integration.prototype._submit = function () {
        if (this.fakeSubmit) {
          this.fakeSubmit = false;
          return
        }
        return this.obs.trigger(Events.Integration.Update)
      };
      Integration.prototype.js = function (opts) {
        Integration.__super__.js.apply(this, arguments);
        this.on('update', function () {
          return $('[data-toggle="tooltip"]').tooltip()
        });
        if (this.model.disabled == null) {
          this.model.disabled = false
        }
        this.model.type = this.type;
        $(this.root).attr('id', 'current-integration').addClass('animated').addClass('fadeIn');
        this.src = this.img ? window.staticUrl + this.img : '';
        this.instanceId = instanceId++;
        requestAnimationFrame(function (_this) {
          return function () {
            _this.fakeSubmit = true;
            return _this.submit()
          }
        }(this));
        return this.update()
      };
      Integration.prototype.removeModal = function () {
        return bootbox.dialog({
          title: 'Are You Sure?',
          message: 'Removing this integration will delete its settings.',
          buttons: {
            Yes: {
              className: 'btn btn-danger',
              callback: function (_this) {
                return function () {
                  return _this.remove()
                }
              }(this)
            },
            No: {
              className: 'btn btn-primary',
              callback: function () {
              }
            }
          }
        })
      };
      Integration.prototype.remove = function (event) {
        return this.obs.trigger(Events.Integration.Remove, event)
      };
      Integration.prototype.toggle = function (event) {
        this.model.disabled = !this.model.disabled;
        this.submit();
        return this.update()
      };
      Integration.src = function () {
        if (this.prototype.img) {
          return window.staticUrl + this.prototype.img
        } else {
          return ''
        }
      };
      Integration.data = function () {
        return {
          integration: this,
          src: this.src(),
          text: this.prototype.text,
          alt: this.prototype.alt
        }
      };
      return Integration
    }(FormView);
    IntegrationHeader = function (superClass) {
      extend(IntegrationHeader, superClass);
      function IntegrationHeader() {
        return IntegrationHeader.__super__.constructor.apply(this, arguments)
      }
      IntegrationHeader.prototype.tag = 'integration-header';
      IntegrationHeader.prototype.html = rqzt('./templates/dash/widget/integrations/header');
      return IntegrationHeader
    }(View);
    IntegrationHeader.register();
    module.exports = Integration
  });
  // source: assets/js/dash/templates/dash/widget/integrations/header.html
  rqzt.define('./templates/dash/widget/integrations/header', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel-heading">\n  <img if="{ model.src }" src="{ model.src }" alt="{ model.alt }">\n  <span if="{ model.text }">{ model.text }</span>\n  <i if="{ model.error && !model.model.disabled }" class="fa fa-exclamation-triangle warning animated fadeIn" data-toggle="tooltip" data-placement="right" title="Please correct the errors to enable this plugin"></i>\n  <span class="admin-form integration-toggle">\n    <label class="switch switch-primary">\n      <input id="integration-toggle-{ model.instanceId }" type="checkbox" __checked="{ !model.model.disabled }" onchange="{ model.toggle }"></input>\n      <label for="integration-toggle-{ model.instanceId }" data-on="ON" data-off="OFF"></label>\n    </label>\n    <i class="fa fa-times integration-remove" onclick="{ model.removeModal }"></i>\n  </span>\n</div>\n'
  });
  // source: assets/js/dash/form/input.coffee
  rqzt.define('./form/input', function (module, exports, __dirname, __filename, process) {
    var InputConfig, crowdcontrol;
    crowdcontrol = rqzt('crowdcontrol/lib');
    InputConfig = crowdcontrol.view.form.InputConfig;
    module.exports = function (name, placeholder, hints, value) {
      if (value == null) {
        value = ''
      }
      return new InputConfig(name, value, placeholder, hints)
    }
  });
  // source: assets/js/dash/templates/dash/widget/integrations/analytics/custom.html
  rqzt.define('./templates/dash/widget/integrations/analytics/custom', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel form-horizontal animated fadeIn">\n  <integration-header model="{this}">\n  </integration-header>\n  <div class="{panel-body: true, collapsed: model.disabled}">\n    <div class="section mb20">\n      <control label="Tracking Event" input="{ inputs.event }"></control>\n    </div>\n    <div class="section mb20">\n      <control label="Sampling Percent" input="{ inputs.sampling }"></control>\n    </div>\n    <div class="section">\n      <control label="Custom Javascript" input="{ inputs.code }"></control>\n    </div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/widget/integrations/analytics/google-adwords.coffee
  rqzt.define('./widget/integrations/analytics/google-adwords', function (module, exports, __dirname, __filename, process) {
    var GoogleAdwords, Integration, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Integration = rqzt('./widget/integrations/integration');
    input = rqzt('./form/input');
    GoogleAdwords = function (superClass) {
      extend(GoogleAdwords, superClass);
      function GoogleAdwords() {
        return GoogleAdwords.__super__.constructor.apply(this, arguments)
      }
      GoogleAdwords.prototype.tag = 'gadwords-integration';
      GoogleAdwords.prototype.type = 'google-adwords';
      GoogleAdwords.prototype.html = rqzt('./templates/dash/widget/integrations/analytics/gadwords');
      GoogleAdwords.prototype.img = '/img/integrations/adwrds.png';
      GoogleAdwords.prototype.alt = 'Google Adwords';
      GoogleAdwords.prototype.text = 'Google Adwords';
      GoogleAdwords.prototype.inputConfigs = [
        input('id', '123456789', 'required'),
        input('event', 'Choose an event', 'analytics-events-select required'),
        input('sampling', '', 'numeric')
      ];
      return GoogleAdwords
    }(Integration);
    GoogleAdwords.register();
    module.exports = GoogleAdwords
  });
  // source: assets/js/dash/templates/dash/widget/integrations/analytics/gadwords.html
  rqzt.define('./templates/dash/widget/integrations/analytics/gadwords', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel form-horizontal animated fadeIn">\n  <integration-header model="{this}">\n  </integration-header>\n  <div class="{panel-body: true, collapsed: model.disabled}">\n    <div class="section row">\n      <div class="col-xs-6">\n        <control label="ID" input="{ inputs.id}"></control>\n      </div>\n      <div class="col-xs-6">\n        <control label="Tracking Event" input="{ inputs.event}"></control>\n      </div>\n    </div>\n    <div class="section row">\n      <div class="col-xs-12">\n        <control label="Sampling Percent" input="{ inputs.sampling }"></control>\n      </div>\n    </div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/widget/integrations/analytics/google-analytics.coffee
  rqzt.define('./widget/integrations/analytics/google-analytics', function (module, exports, __dirname, __filename, process) {
    var GoogleAnalytics, Integration, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Integration = rqzt('./widget/integrations/integration');
    input = rqzt('./form/input');
    GoogleAnalytics = function (superClass) {
      extend(GoogleAnalytics, superClass);
      function GoogleAnalytics() {
        return GoogleAnalytics.__super__.constructor.apply(this, arguments)
      }
      GoogleAnalytics.prototype.tag = 'ga-integration';
      GoogleAnalytics.prototype.type = 'google-analytics';
      GoogleAnalytics.prototype.html = rqzt('./templates/dash/widget/integrations/analytics/ga');
      GoogleAnalytics.prototype.img = '/img/integrations/ga.png';
      GoogleAnalytics.prototype.alt = 'Google Analytics';
      GoogleAnalytics.prototype.text = 'Google Analytics';
      GoogleAnalytics.prototype.inputConfigs = [
        input('id', 'UA-XXXXXXXX-1', 'required'),
        input('sampling', '', 'numeric')
      ];
      return GoogleAnalytics
    }(Integration);
    GoogleAnalytics.register();
    module.exports = GoogleAnalytics
  });
  // source: assets/js/dash/templates/dash/widget/integrations/analytics/ga.html
  rqzt.define('./templates/dash/widget/integrations/analytics/ga', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel form-horizontal animated fadeIn">\n  <integration-header model="{this}">\n  </integration-header>\n  <div class="{ panel-body: true, collapsed: model.disabled }">\n    <div class="section">\n      <control label="ID" input="{ inputs.id}"></control>\n    </div>\n    <div class="section">\n      <control label="Sampling Percent" input="{ inputs.sampling }"></control>\n    </div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/widget/integrations/analytics/facebook-pixel.coffee
  rqzt.define('./widget/integrations/analytics/facebook-pixel', function (module, exports, __dirname, __filename, process) {
    var FacebookPixel, Integration, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Integration = rqzt('./widget/integrations/integration');
    input = rqzt('./form/input');
    FacebookPixel = function (superClass) {
      extend(FacebookPixel, superClass);
      function FacebookPixel() {
        return FacebookPixel.__super__.constructor.apply(this, arguments)
      }
      FacebookPixel.prototype.tag = 'fb-pixel-integration';
      FacebookPixel.prototype.type = 'facebook-pixel';
      FacebookPixel.prototype.html = rqzt('./templates/dash/widget/integrations/analytics/fbpixel');
      FacebookPixel.prototype.img = '/img/integrations/fb.png';
      FacebookPixel.prototype.text = 'Facebook Pixel';
      FacebookPixel.prototype.alt = 'Facebook Pixel';
      FacebookPixel.prototype.inputConfigs = [
        input('id', 'ex. 1234567890123', 'required'),
        input('values.currency', '', 'currency-type-select'),
        input('values.viewedProduct.percent', '', 'numeric'),
        input('values.viewedProduct.value', '', 'money'),
        input('values.addedProduct.percent', '', 'numeric'),
        input('values.addedProduct.value', '', 'money'),
        input('values.initiateCheckout.percent', '', 'numeric'),
        input('values.initiateCheckout.value', '', 'money'),
        input('values.addPaymentInfo.percent', '', 'numeric'),
        input('values.addPaymentInfo.value', '', 'money'),
        input('sampling', '', 'numeric')
      ];
      return FacebookPixel
    }(Integration);
    FacebookPixel.register();
    module.exports = FacebookPixel
  });
  // source: assets/js/dash/templates/dash/widget/integrations/analytics/fbpixel.html
  rqzt.define('./templates/dash/widget/integrations/analytics/fbpixel', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel form-horizontal animated fadeIn">\n  <integration-header model="{this}">\n  </integration-header>\n  <div class="{panel-body: true, collapsed: model.disabled }">\n    <div class="section row">\n      <div class="col-xs-6">\n        <control label="Pixel ID" input="{ inputs.id}"></control>\n      </div>\n      <div class="col-xs-6">\n        <control label="Currency" input="{ inputs[\'values.currency\']}"></control>\n      </div>\n    </div>\n    <div class="section row">\n      <div class="col-xs-6">\n        <control label="ViewedProduct Percent" input="{ inputs[\'values.viewedProduct.percent\']}"></control>\n      </div>\n      <div class="col-xs-6">\n        <control label="ViewedProduct Value" input="{ inputs[\'values.viewedProduct.value\']}"></control>\n      </div>\n    </div>\n    <div class="section row">\n      <div class="col-xs-6">\n        <control label="AddedProduct Percent" input="{ inputs[\'values.addedProduct.percent\']}"></control>\n      </div>\n      <div class="col-xs-6">\n        <control label="AddedProduct Value" input="{ inputs[\'values.addedProduct.value\']}"></control>\n      </div>\n    </div>\n    <div class="section row">\n      <div class="col-xs-6">\n        <control label="InitiateCheckout Percent" input="{ inputs[\'values.initiateCheckout.percent\']}"></control>\n      </div>\n      <div class="col-xs-6">\n        <control label="InitiateCheckout Value" input="{ inputs[\'values.initiateCheckout.value\']}"></control>\n      </div>\n    </div>\n    <div class="section row">\n      <div class="col-xs-6">\n        <control label="AddPaymentInfo Percent" input="{ inputs[\'values.addPaymentInfo.percent\']}"></control>\n      </div>\n      <div class="col-xs-6">\n        <control label="AddPaymentInfo Value" input="{ inputs[\'values.addPaymentInfo.value\']}"></control>\n      </div>\n    </div>\n    <div class="section row">\n      <div class="col-xs-12">\n        <control label="Sampling Percent" input="{ inputs.sampling }"></control>\n      </div>\n    </div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/widget/integrations/analytics/heap.coffee
  rqzt.define('./widget/integrations/analytics/heap', function (module, exports, __dirname, __filename, process) {
    var HeapAnalytics, Integration, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Integration = rqzt('./widget/integrations/integration');
    input = rqzt('./form/input');
    HeapAnalytics = function (superClass) {
      extend(HeapAnalytics, superClass);
      function HeapAnalytics() {
        return HeapAnalytics.__super__.constructor.apply(this, arguments)
      }
      HeapAnalytics.prototype.tag = 'heap-integration';
      HeapAnalytics.prototype.type = 'heap-analytics';
      HeapAnalytics.prototype.html = rqzt('./templates/dash/widget/integrations/analytics/heap');
      HeapAnalytics.prototype.img = '/img/integrations/heap.png';
      HeapAnalytics.prototype.alt = 'Heap Analytics';
      HeapAnalytics.prototype.text = 'Heap Analytics';
      HeapAnalytics.prototype.inputConfigs = [
        input('id', '123456789', 'required'),
        input('sampling', '', 'numeric')
      ];
      return HeapAnalytics
    }(Integration);
    HeapAnalytics.register();
    module.exports = HeapAnalytics
  });
  // source: assets/js/dash/templates/dash/widget/integrations/analytics/heap.html
  rqzt.define('./templates/dash/widget/integrations/analytics/heap', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel form-horizontal animated fadeIn">\n  <integration-header model="{this}">\n  </integration-header>\n  <div class="{ panel-body: true, collapsed: model.disabled }">\n    <div class="section">\n      <control label="ID" input="{ inputs.id}"></control>\n    </div>\n    <div class="section">\n      <control label="Sampling Percent" input="{ inputs.sampling }"></control>\n    </div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/widget/integrations/analytics/facebook-conversions.coffee
  rqzt.define('./widget/integrations/analytics/facebook-conversions', function (module, exports, __dirname, __filename, process) {
    var FacebookConversions, Integration, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Integration = rqzt('./widget/integrations/integration');
    input = rqzt('./form/input');
    FacebookConversions = function (superClass) {
      extend(FacebookConversions, superClass);
      function FacebookConversions() {
        return FacebookConversions.__super__.constructor.apply(this, arguments)
      }
      FacebookConversions.prototype.tag = 'fb-conversions-integration';
      FacebookConversions.prototype.type = 'facebook-conversions';
      FacebookConversions.prototype.html = rqzt('./templates/dash/widget/integrations/analytics/fbconversions');
      FacebookConversions.prototype.img = '/img/integrations/fb.png';
      FacebookConversions.prototype.text = 'Facebook Conversions';
      FacebookConversions.prototype.alt = 'Facebook Analytics';
      FacebookConversions.prototype.inputConfigs = [
        input('id', 'ex. 1234567890123', 'required'),
        input('event', 'Choose an event', 'analytics-events-select required'),
        input('sampling', '', 'numeric')
      ];
      return FacebookConversions
    }(Integration);
    FacebookConversions.register();
    module.exports = FacebookConversions
  });
  // source: assets/js/dash/templates/dash/widget/integrations/analytics/fbconversions.html
  rqzt.define('./templates/dash/widget/integrations/analytics/fbconversions', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel form-horizontal animated fadeIn">\n  <integration-header model="{this}">\n  </integration-header>\n  <div class="{panel-body: true, collapsed: model.disabled}">\n    <div class="section row">\n      <div class="col-xs-6">\n        <control label="Pixel ID" input="{ inputs.id}"></control>\n      </div>\n      <div class="col-xs-6">\n        <control label="Tracking Event" input="{ inputs.event}"></control>\n      </div>\n    </div>\n    <div class="section row">\n      <div class="col-xs-12">\n        <control label="Sampling Percent" input="{ inputs.sampling }"></control>\n      </div>\n    </div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/site/pages/integrations.html
  rqzt.define('./templates/dash/site/pages/integrations', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Integration information Form Block -->\n<div class ="block cs-nav-tabs nav-tabs">\n  <div class="btn-group">\n    <a href="#" class="{ btn: true, btn-default: true, cs-selected: tab == \'paymentprocessors\' }" onclick="{ setType(\'paymentprocessors\') }">Payment Processors</a>\n    <a href="#" class="{ btn: true, btn-default: true, cs-selected: tab == \'analytics\' }" onclick="{ setType(\'analytics\') }">Analytics</a>\n  </div>\n</div>\n\n<div class="tray tray-center">\n\n  <div class="block row">\n    <div id="paymentprocessors" if="{ tab == \'paymentprocessors\' }">\n\n      <!-- Stripe Integration information Form Content -->\n      <st-ripe-integration-form>\n        <div class="col-md-6">\n          <div class="panel animated fadeIn">\n            <div class="panel-heading">\n              Stripe\n            </div>\n            <div class="panel-body">\n              <div class="section col-xs-12" style="padding:0">\n                <div class="well">\n                  <h4 if="{ model.state == \'error\' }" class="text-danger text-center">Your Stripe account was not successfully be connected.  Please try again.</h4>\n                  <h4 if="{ model.state == \'connected\' }" class="text-center">Your Stripe account is connected.</h4>\n                  <h4 if="{ model.state == \'new\' }" class="text-center">Connect a Stripe account to start selling products.</h4>\n                </div>\n              </div>\n              <div class="form-actions section row">\n                <div class="col-md-8">\n                  <button onclick="{ stripeOAuth }" __disabled="{ !model.clientId }" if="{ model.state == \'connected\' }" class="btn btn-block btn-effect-ripple btn-success" class="stripe-connect" type="button"><i class="fa fa-check"></i>Update Stripe Connect</button>\n                  <button onclick="{ stripeOAuth }" __disabled="{ !model.clientId }" if="{ model.state != \'connected\' }" class="btn btn-block btn-effect-ripple btn-dark" class="stripe-connect" type="button">Connect with Stripe</button>\n                </div>\n                <div class="col-md-4">\n                  <button onclick="{ stripeSync }" __disabled="{ !model.clientId || syncing }" class="btn btn-block btn-default" type="button">Sync orders</button>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </st-ripe-integration-form>\n      <!-- END Stripe Integration information Form Content -->\n\n    </div>\n  </div>\n\n  <div id="analytics" if="{ tab == \'analytics\' }">\n    <div class="{cs-droparea: true, active: dragging}">\n      <div if="{ isTabEmpty(\'analytics\') }" class="text-center mt30">\n        Drag plugins over here to enable them.\n      </div>\n      <integration if="{ integration }" type="{ integration }" model="{ this.parent.models.analytics[i] }" obs="{ this.parent.obses.analytics[i] }" each="{ integration, i in integrations.analytics }">\n      </integration>\n      <drop obs="{ obs }">\n        <div class="{cs-droparea-overlay: true}">\n          Drop Plugins Here\n        </div>\n      </drop>\n    </div>\n  </div>\n\n</div>\n\n<aside class="{ tray-hidden: tab != \'analytics\', tray: true, tray-right: true, tray320: true, p20: true, cs-integration: true }">\n  <div if="{ tab == \'analytics\'}">\n    <h4>Snippet</h4>\n    <hr class="alt short">\n    <textarea class="form-control mb20">{analyticsSnippet}</textarea>\n    <h4>Plugins</h4>\n    <hr class="alt short">\n    <drag each="{ integrationClass, i in integrationClasses.analytics }" model="{ integrationClass.data() }" obs="{ this.parent.obs }">\n      <div class="btn btn-lg btn-block btn-rounded mb10">\n        <img if="{model.src}" src="{model.src}" alt="{model.alt}">\n        <span if="{model.text}">{model.text}</span>\n      </div>\n    </drag>\n  </div>\n</aside>\n\n<!-- Begin: Page Footer -->\n<footer id="content-footer" class="{ affix: true, footer-hidden: !showSave }">\n  <div class="row">\n    <i class="fa fa-info-circle"></i>\n    <h5>Save your changes?</h5>\n    <button type="button" class="btn btn-default btn-sm" onclick="{ save }" __disabled="{ saving }">{ saving ? \'Saving...\' : \'Save\' }</button>\n  </div>\n</footer>\n<!-- End: Page Footer -->\n\n<!-- END Integration information Form Block -->\n'
  });
  // source: assets/js/dash/site/pages/search.coffee
  rqzt.define('./site/pages/search', function (module, exports, __dirname, __filename, process) {
    var Page, Search, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    Page = rqzt('./site/pages/page');
    Search = function (superClass) {
      extend(Search, superClass);
      function Search() {
        return Search.__super__.constructor.apply(this, arguments)
      }
      Search.prototype.tag = 'page-search';
      Search.prototype.icon = 'fa fa-search';
      Search.prototype.name = 'Search';
      Search.prototype.html = rqzt('./templates/dash/site/pages/search');
      Search.prototype.collection = 'search';
      return Search
    }(Page);
    Search.register();
    module.exports = Search
  });
  // source: assets/js/dash/templates/dash/site/pages/search.html
  rqzt.define('./templates/dash/site/pages/search', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Orders View Block -->\n<div class="tray tray-center">\n  <search-widget>\n    <div class="block">\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Users\n        </div>\n        <div class="panel-body">\n          <user-list obs="{userObs}">\n            <div>\n              <i class="fa fa-users" style="font-size:50px"></i>\n              <h2 class="text-center">No Users Found</h2>\n            </div>\n          <user-list>\n        </div>\n      </div>\n    </div>\n    <div class="block">\n      <div class="panel animated fadeIn">\n        <div class="panel-heading">\n          Orders\n        </div>\n        <div class="panel-body">\n          <order-list obs="{orderObs}">\n            <div>\n              <i class="glyphicon glyphicon-shopping-cart" style="font-size:50px"></i>\n              <h2 class="text-center">No Orders Found</h2>\n            </div>\n          <order-list>\n        </div>\n      </div>\n    </div>\n  </search-widget>\n</div>\n<!-- END Orders View Block -->\n\n'
  });
  // source: assets/js/dash/templates/dash/site/crumbs.html
  rqzt.define('./templates/dash/site/crumbs', function (module, exports, __dirname, __filename, process) {
    module.exports = '<header id="topbar" class="alt">\n  <div class="topbar-left">\n    <ol class="breadcrumb">\n      <li class="crumb-icon">\n        <a href="dashboard">\n          <span class="glyphicon glyphicon-home"></span>\n        </a>\n      </li>\n      <li class="crumb-trail">\n        { getActive().name }\n      </li>\n      <li class="crumb-trail" if="{ getActiveId() }">\n        { getActiveId() }\n      </li>\n    </ol>\n  </div>\n</header>\n'
  });
  // source: assets/js/dash/site/menu.coffee
  rqzt.define('./site/menu', function (module, exports, __dirname, __filename, process) {
    var Menu, Router, View, activePage, crowdcontrol, menu, pages, riot, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    riot = rqzt('riot/riot');
    crowdcontrol = rqzt('crowdcontrol/lib');
    pages = rqzt('./site/pages');
    Router = rqzt('./site/router');
    View = crowdcontrol.view.View;
    menu = window.User.owner ? [
      {
        name: 'Menu',
        data: [
          pages.Dashboard,
          pages.Users,
          pages.Orders,
          pages.Payments,
          pages.Products,
          pages.Coupons,
          pages.Stores,
          pages.MailingLists,
          pages.Subscribers
        ]
      },
      {
        name: 'System',
        data: [
          pages.Profile,
          pages.Api,
          pages.Organization,
          pages.Integrations
        ]
      }
    ] : [{
        name: 'Menu',
        data: [
          pages.Users,
          pages.Orders
        ]
      }];
    activePage = pages.Dashboard;
    Menu = function (superClass) {
      extend(Menu, superClass);
      function Menu() {
        return Menu.__super__.constructor.apply(this, arguments)
      }
      Menu.prototype.tag = 'menu';
      Menu.prototype.html = rqzt('./templates/dash/site/menu');
      Menu.prototype.model = menu;
      Menu.prototype.route = function (url) {
        return riot.route(url)
      };
      Menu.prototype.js = function () {
        Menu.__super__.js.apply(this, arguments);
        return requestAnimationFrame(function () {
          var e, ref;
          try {
            return typeof window !== 'undefined' && window !== null ? (ref = window.Core) != null ? ref.init() : void 0 : void 0
          } catch (error) {
            e = error;
            return e
          }
        })
      };
      Menu.prototype.setActive = function (p) {
        activePage = p;
        return this.update()
      };
      Menu.prototype.getActive = function () {
        return activePage
      };
      Menu.setActive = function (p) {
        activePage = p;
        return riot.update()
      };
      Menu.getActive = function () {
        return activePage
      };
      return Menu
    }(View);
    Menu.register();
    module.exports = Router.Menu = Menu
  });
  // source: assets/js/dash/templates/dash/site/menu.html
  rqzt.define('./templates/dash/site/menu', function (module, exports, __dirname, __filename, process) {
    module.exports = '<!-- Start: Sidebar Menu -->\n<ul class="nav sidebar-menu" each="{ category, i in model }">\n  <li class="sidebar-label pt20">{ category.name }</li>\n  <li each="{ item, j in category.data }" class="{ active: this.parent.parent && this.parent.parent.getActive() === item }">\n    <a if="{!item.data}" id="menu-{ item.prototype.collection }" href="#{ item.prototype.collection }">\n      <span class="{ item.prototype.icon }"></span>\n      <span class="sidebar-title">{ item.prototype.name }</span>\n    </a>\n    <a if="{item.data}" href="#" class="accordion-toggle">\n      <span class="{ item.icon }"></span>\n      <span class="sidebar-title">Settings</span>\n      <span class="caret"></span>\n    </a>\n    <ul if="{ item.data }" class="nav sub-nav">\n      <li each="{ subitem, k in item.data }" class="{ active: this.parent.getActive() === subitem }">\n        <a if="{!data}" id="menu-{ subitem.prototype.collection }" href="#{ subitem.prototype.collection }">\n          <span class="{ subitem.prototype.icon }"></span>\n          <span class="sidebar-title">{ subitem.prototype.name }</span>\n        </a>\n      </li>\n    </ul>\n  </li>\n</ul>\n<!-- End: Sidebar Menu -->\n\n\n'
  });
  // source: assets/js/dash/table/index.coffee
  rqzt.define('./table', function (module, exports, __dirname, __filename, process) {
    var helpers, types;
    types = rqzt('./table/types');
    helpers = rqzt('./table/helpers');
    rqzt('./table/fields');
    module.exports = {
      helpers: helpers,
      BasicTableView: types.BasicTableView,
      TableFieldConfig: types.TableFieldConfig,
      lists: rqzt('./table/lists'),
      paged: rqzt('./table/paged'),
      field: types.field
    }
  });
  // source: assets/js/dash/table/types.coffee
  rqzt.define('./table/types', function (module, exports, __dirname, __filename, process) {
    var BasicTableView, Events, Source, TableFieldConfig, View, _, crowdcontrol, riot, tokenize, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    riot = rqzt('riot/riot');
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    tokenize = crowdcontrol.view.form.tokenize;
    View = crowdcontrol.view.View;
    Source = crowdcontrol.data.Source;
    TableFieldConfig = function () {
      TableFieldConfig.prototype.field = '';
      TableFieldConfig.prototype.name = '';
      TableFieldConfig.prototype.type = '';
      TableFieldConfig.prototype.hints = '';
      function TableFieldConfig(id1, name1, type1, hints) {
        this.id = id1;
        this.name = name1;
        this.type = type1 != null ? type1 : 'text';
        if (hints == null) {
          hints = ''
        }
        this.hints = tokenize(hints)
      }
      return TableFieldConfig
    }();
    Events.Table = {
      PrepareForNewData: 'table-prepare',
      NewData: 'table-new-data',
      StartSearch: 'table-start-search',
      EndSearch: 'table-end-search'
    };
    BasicTableView = function (superClass) {
      var obj;
      extend(BasicTableView, superClass);
      function BasicTableView() {
        return BasicTableView.__super__.constructor.apply(this, arguments)
      }
      BasicTableView.prototype.tag = 'basic-table';
      BasicTableView.prototype.html = rqzt('./templates/dash/table/template');
      BasicTableView.prototype.searching = false;
      BasicTableView.prototype.events = (obj = {}, obj['' + Events.Table.NewData] = function (model) {
        this.model = model;
        return riot.update()
      }, obj['' + Events.Table.StartSearch] = function () {
        return this.searching = true
      }, obj['' + Events.Table.EndSearch] = function () {
        return this.searching = false
      }, obj);
      BasicTableView.prototype.isEmpty = function () {
        var model;
        model = this.model;
        return model == null || !model.length || model.length === 0
      };
      BasicTableView.prototype.js = function (opts) {
        var header, i, len, ref, results;
        if (this.headers == null) {
          this.headers = opts.headers
        }
        this.headerMap = {};
        ref = this.headers;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          header = ref[i];
          results.push(this.headerMap[header.id] = header)
        }
        return results
      };
      return BasicTableView
    }(View);
    BasicTableView.register();
    module.exports = {
      BasicTableView: BasicTableView,
      TableFieldConfig: TableFieldConfig,
      field: function (id, name, type, hints) {
        return new TableFieldConfig(id, name, type, hints)
      }
    }
  });
  // source: assets/js/dash/templates/dash/table/template.html
  rqzt.define('./templates/dash/table/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div if="{ !isEmpty() }" class="table-responsive">\n  <table class="table table-striped table-hover">\n    <thead>\n      <tr>\n        <th class="{ text-right: type == \'date\' || type == \'ago\' || type == \'money\'}" each="{ headers }">{name}</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr each="{ row, i in model }" class="animated fadeIn">\n        <td each="{ field, j in this.parent.headers }">\n          <table-field field="{ field }" row="{ this.parent }"></table-field>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<h3 class="text-center pb10" if="{ isEmpty() }">\n  <div class="status-message" if="{ searching }">\n    <i class="text-center" class="glyphicon glyphicon-search" style="font-size:50px"></i>\n    <h2 class="text-center">Searching...</h2>\n  </div>\n  <div class="status-message" if="{ !searching }">\n    <yield></yield>\n  </div>\n</h3>\n'
  });
  // source: assets/js/dash/table/helpers.coffee
  rqzt.define('./table/helpers', function (module, exports, __dirname, __filename, process) {
    var TableFieldCondition, _, helpers, riot;
    riot = rqzt('riot/riot');
    _ = rqzt('underscore/underscore');
    TableFieldCondition = function () {
      function TableFieldCondition(predicate1, tagName1) {
        this.predicate = predicate1;
        this.tagName = tagName1
      }
      return TableFieldCondition
    }();
    helpers = {
      tagLookup: [],
      defaultTagName: 'basic-table-field',
      registerTag: function (predicate, tagName) {
        return this.tagLookup.push(new TableFieldCondition(predicate, tagName))
      },
      deleteTag: function (tagName) {
        var i, j, len, lookup, ref, results;
        ref = this.tagLookup;
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          lookup = ref[i];
          if (lookup.tagName === tagName) {
            results.push(this.tagLookup[i] = null)
          } else {
            results.push(void 0)
          }
        }
        return results
      },
      render: function (tableFieldConfig) {
        var j, len, lookup, ref, tag;
        if (tableFieldConfig == null) {
          return
        }
        ref = this.tagLookup;
        for (j = 0, len = ref.length; j < len; j++) {
          lookup = ref[j];
          if (lookup == null) {
            continue
          }
          if (lookup.predicate(tableFieldConfig)) {
            tag = lookup.tagName;
            return tag
          }
        }
        return this.defaultTagName
      }
    };
    riot.tag('table-field', '', function (opts) {
      var dummyOpts, field, tag, tags;
      field = opts.field;
      tag = helpers.render(field);
      dummyOpts = _.extend({}, opts);
      tags = riot.mount(this.root, tag, opts);
      return tags[0].js(opts)
    });
    module.exports = helpers
  });
  // source: assets/js/dash/table/fields/index.coffee
  rqzt.define('./table/fields', function (module, exports, __dirname, __filename, process) {
    var AgoTableFieldView, Api, BasicTableFieldView, DateTableFieldView, IdListTableFieldView, IdTableFieldView, MoneyTableFieldView, NumericTableFieldView, SnippetTableFieldView, TextareaTableFieldView, TotalTableFieldView, View, crowdcontrol, helpers, moment, util, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    moment = rqzt('moment/moment');
    util = rqzt('./util');
    helpers = rqzt('./table/helpers');
    View = crowdcontrol.view.View;
    Api = crowdcontrol.data.Api;
    BasicTableFieldView = function (superClass) {
      extend(BasicTableFieldView, superClass);
      function BasicTableFieldView() {
        return BasicTableFieldView.__super__.constructor.apply(this, arguments)
      }
      BasicTableFieldView.prototype.tag = 'basic-table-field';
      BasicTableFieldView.prototype.html = rqzt('./templates/dash/table/fields/basic-field');
      BasicTableFieldView.prototype.js = function (opts) {
        var currentObject, i, id, len, name, names, row;
        this.field = opts.field;
        this.row = row = opts.row;
        id = opts.field.id;
        names = id.split('.');
        if (names.length === 1) {
          return this.value = row[id]
        } else {
          currentObject = row;
          for (i = 0, len = names.length; i < len; i++) {
            name = names[i];
            if (currentObject[name] == null) {
              this.value = void 0;
              return
            }
            currentObject = currentObject[name]
          }
          return this.value = currentObject
        }
      };
      return BasicTableFieldView
    }(View);
    BasicTableFieldView.register();
    TextareaTableFieldView = function (superClass) {
      extend(TextareaTableFieldView, superClass);
      function TextareaTableFieldView() {
        return TextareaTableFieldView.__super__.constructor.apply(this, arguments)
      }
      TextareaTableFieldView.prototype.tag = 'textarea-table-field';
      TextareaTableFieldView.prototype.html = rqzt('./templates/dash/table/fields/textarea-field');
      return TextareaTableFieldView
    }(BasicTableFieldView);
    TextareaTableFieldView.register();
    SnippetTableFieldView = function (superClass) {
      extend(SnippetTableFieldView, superClass);
      function SnippetTableFieldView() {
        return SnippetTableFieldView.__super__.constructor.apply(this, arguments)
      }
      SnippetTableFieldView.prototype.tag = 'snippet-table-field';
      SnippetTableFieldView.prototype.js = function (opts) {
        var api;
        SnippetTableFieldView.__super__.js.apply(this, arguments);
        api = Api.get('crowdstart');
        return this.value = '<script src="' + api.url + '/mailinglist/' + this.value + '/js"></script>'
      };
      return SnippetTableFieldView
    }(TextareaTableFieldView);
    SnippetTableFieldView.register();
    IdTableFieldView = function (superClass) {
      extend(IdTableFieldView, superClass);
      function IdTableFieldView() {
        return IdTableFieldView.__super__.constructor.apply(this, arguments)
      }
      IdTableFieldView.prototype.tag = 'id-table-field';
      IdTableFieldView.prototype.html = rqzt('./templates/dash/table/fields/link-field');
      IdTableFieldView.prototype.js = function (opts) {
        IdTableFieldView.__super__.js.apply(this, arguments);
        this.displayField = opts.field.hints['id-display'];
        this.displayValue = this.displayField != null ? opts.row[this.displayField] : opts.row[this.field.id];
        return this.path = opts.field.hints['id-path']
      };
      return IdTableFieldView
    }(BasicTableFieldView);
    IdTableFieldView.register();
    IdListTableFieldView = function (superClass) {
      extend(IdListTableFieldView, superClass);
      function IdListTableFieldView() {
        return IdListTableFieldView.__super__.constructor.apply(this, arguments)
      }
      IdListTableFieldView.prototype.tag = 'id-list-table-field';
      IdListTableFieldView.prototype.html = rqzt('./templates/dash/table/fields/link-list-field');
      IdListTableFieldView.prototype.js = function (opts) {
        IdListTableFieldView.__super__.js.apply(this, arguments);
        return this.path = opts.field.hints['id-path']
      };
      return IdListTableFieldView
    }(BasicTableFieldView);
    IdListTableFieldView.register();
    NumericTableFieldView = function (superClass) {
      extend(NumericTableFieldView, superClass);
      function NumericTableFieldView() {
        return NumericTableFieldView.__super__.constructor.apply(this, arguments)
      }
      NumericTableFieldView.prototype.tag = 'numeric-table-field';
      NumericTableFieldView.prototype.html = rqzt('./templates/dash/table/fields/numeric-field');
      return NumericTableFieldView
    }(BasicTableFieldView);
    NumericTableFieldView.register();
    MoneyTableFieldView = function (superClass) {
      extend(MoneyTableFieldView, superClass);
      function MoneyTableFieldView() {
        return MoneyTableFieldView.__super__.constructor.apply(this, arguments)
      }
      MoneyTableFieldView.prototype.tag = 'money-table-field';
      MoneyTableFieldView.prototype.js = function () {
        MoneyTableFieldView.__super__.js.apply(this, arguments);
        return this.value = util.currency.renderUICurrencyFromJSON(this.row.currency, this.value)
      };
      return MoneyTableFieldView
    }(NumericTableFieldView);
    MoneyTableFieldView.register();
    TotalTableFieldView = function (superClass) {
      extend(TotalTableFieldView, superClass);
      function TotalTableFieldView() {
        return TotalTableFieldView.__super__.constructor.apply(this, arguments)
      }
      TotalTableFieldView.prototype.tag = 'total-table-field';
      TotalTableFieldView.prototype.js = function () {
        TotalTableFieldView.__super__.js.apply(this, arguments);
        return this.value = util.currency.renderUICurrencyFromJSON(this.row.currency, this.row.price * this.row.quantity)
      };
      return TotalTableFieldView
    }(NumericTableFieldView);
    TotalTableFieldView.register();
    DateTableFieldView = function (superClass) {
      extend(DateTableFieldView, superClass);
      function DateTableFieldView() {
        return DateTableFieldView.__super__.constructor.apply(this, arguments)
      }
      DateTableFieldView.prototype.tag = 'date-table-field';
      DateTableFieldView.prototype.html = rqzt('./templates/dash/table/fields/numeric-field');
      DateTableFieldView.prototype.js = function () {
        DateTableFieldView.__super__.js.apply(this, arguments);
        return this.value = moment(this.value).format('YYYY-MM-DD HH:mm')
      };
      return DateTableFieldView
    }(BasicTableFieldView);
    DateTableFieldView.register();
    AgoTableFieldView = function (superClass) {
      extend(AgoTableFieldView, superClass);
      function AgoTableFieldView() {
        return AgoTableFieldView.__super__.constructor.apply(this, arguments)
      }
      AgoTableFieldView.prototype.tag = 'ago-table-field';
      AgoTableFieldView.prototype.js = function () {
        AgoTableFieldView.__super__.js.apply(this, arguments);
        return this.value = moment(this.value).fromNow()
      };
      return AgoTableFieldView
    }(DateTableFieldView);
    AgoTableFieldView.register();
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'numeric'
    }, 'numeric-table-field');
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'money'
    }, 'money-table-field');
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'ago'
    }, 'ago-table-field');
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'date'
    }, 'date-table-field');
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'total'
    }, 'total-table-field');
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'id'
    }, 'id-table-field');
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'id-list'
    }, 'id-list-table-field');
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'textarea'
    }, 'textarea-table-field');
    helpers.registerTag(function (fieldCfg) {
      return fieldCfg.type === 'snippet'
    }, 'snippet-table-field')
  });
  // source: assets/js/dash/templates/dash/table/fields/basic-field.html
  rqzt.define('./templates/dash/table/fields/basic-field', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>{ value }</div>\n'
  });
  // source: assets/js/dash/templates/dash/table/fields/textarea-field.html
  rqzt.define('./templates/dash/table/fields/textarea-field', function (module, exports, __dirname, __filename, process) {
    module.exports = '<textarea>{ value }</textarea>\n'
  });
  // source: assets/js/dash/templates/dash/table/fields/link-field.html
  rqzt.define('./templates/dash/table/fields/link-field', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>\n  <a href="{ path }/{ value }">\n    { displayValue || value }\n  </a>\n</div>\n\n'
  });
  // source: assets/js/dash/templates/dash/table/fields/link-list-field.html
  rqzt.define('./templates/dash/table/fields/link-list-field', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>\n  <a href="{ this.parent.path }/{ v }" each="{ v in value }">\n    { v }\n    <br>\n  </a>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/table/fields/numeric-field.html
  rqzt.define('./templates/dash/table/fields/numeric-field', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="text-right">{ value }</div>\n'
  });
  // source: assets/js/dash/table/lists/index.coffee
  rqzt.define('./table/lists', function (module, exports, __dirname, __filename, process) {
    module['export'] = {
      user: rqzt('./table/lists/user'),
      order: rqzt('./table/lists/order'),
      item: rqzt('./table/lists/item'),
      payment: rqzt('./table/lists/payment'),
      referral: rqzt('./table/lists/referral'),
      referrer: rqzt('./table/lists/referrer')
    }
  });
  // source: assets/js/dash/table/lists/user.coffee
  rqzt.define('./table/lists/user', function (module, exports, __dirname, __filename, process) {
    var BasicList, Source, UserList, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicList = rqzt('./table/lists/list');
    UserList = function (superClass) {
      extend(UserList, superClass);
      function UserList() {
        return UserList.__super__.constructor.apply(this, arguments)
      }
      UserList.prototype.tag = 'user-list';
      UserList.prototype.path = 'user';
      UserList.prototype.headers = [
        field('id', 'ID', 'id', 'id-path:#user id-display:email'),
        field('firstName', 'First Name'),
        field('lastName', 'Last Name'),
        field('createdAt', 'Created On', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return UserList
    }(BasicList);
    UserList.register()
  });
  // source: assets/js/dash/table/lists/list.coffee
  rqzt.define('./table/lists/list', function (module, exports, __dirname, __filename, process) {
    var Api, BasicList, BasicTableView, crowdcontrol, field, m, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Api = crowdcontrol.data.Api;
    BasicTableView = table.BasicTableView;
    m = crowdcontrol.utils.mediator;
    BasicList = function (superClass) {
      extend(BasicList, superClass);
      function BasicList() {
        return BasicList.__super__.constructor.apply(this, arguments)
      }
      BasicList.prototype.tag = 'basic-list';
      BasicList.prototype.js = function (opts) {
        var api;
        BasicList.__super__.js.apply(this, arguments);
        if (opts.path != null) {
          if (opts.path) {
            this.path = opts.path
          }
          this.api = api = Api.get('crowdstart');
          m.trigger('start-spin', this.tag + this.path + '-list-load');
          return api.get(this.path).then(function (_this) {
            return function (res) {
              m.trigger('stop-spin', _this.tag + _this.path + '-list-load');
              _this.model = res.responseText;
              return _this.update()
            }
          }(this))
        }
      };
      return BasicList
    }(BasicTableView);
    module.exports = BasicList
  });
  // source: assets/js/dash/table/lists/order.coffee
  rqzt.define('./table/lists/order', function (module, exports, __dirname, __filename, process) {
    var BasicList, OrderList, Source, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicList = rqzt('./table/lists/list');
    OrderList = function (superClass) {
      extend(OrderList, superClass);
      function OrderList() {
        return OrderList.__super__.constructor.apply(this, arguments)
      }
      OrderList.prototype.tag = 'order-list';
      OrderList.prototype.path = 'order';
      OrderList.prototype.headers = [
        field('id', 'Number', 'id', 'id-display:number id-path:#order dontsort'),
        field('currency', 'Currency', 'upper'),
        field('total', 'Total', 'money'),
        field('status', 'Order Status'),
        field('paymentStatus', 'Paid'),
        field('fulfillmentStatus', 'Fulfillment Status'),
        field('couponCodes', 'Coupon(s)', 'id-list', 'id-path:#coupon'),
        field('createdAt', 'Created', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return OrderList
    }(BasicList);
    OrderList.register()
  });
  // source: assets/js/dash/table/lists/item.coffee
  rqzt.define('./table/lists/item', function (module, exports, __dirname, __filename, process) {
    var BasicFormView, BasicList, Events, ItemList, Source, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    BasicFormView = rqzt('./form/basic');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicList = rqzt('./table/lists/list');
    ItemList = function (superClass) {
      var obj;
      extend(ItemList, superClass);
      function ItemList() {
        return ItemList.__super__.constructor.apply(this, arguments)
      }
      ItemList.prototype.tag = 'item-list';
      ItemList.prototype.path = 'item';
      ItemList.prototype.itemsModel = 'items';
      ItemList.prototype.headers = [
        field('productId', 'Product Slug', 'id', 'id-display:productSlug id-path:../product'),
        field('productName', 'Product '),
        field('quantity', 'Quantity'),
        field('price', 'Unit Price', 'money'),
        field('totalPrice', 'Total', 'total')
      ];
      ItemList.prototype.js = function (opts) {
        var ref;
        ItemList.__super__.js.apply(this, arguments);
        return this.itemsModel = (ref = opts.itemsmodel) != null ? ref : this.itemsModel
      };
      ItemList.prototype.events = (obj = {}, obj['' + Events.Form.Prefill] = function (orderModel) {
        var i, item, len, ref;
        this.model = orderModel[this.itemsModel];
        if (this.model != null) {
          ref = this.model;
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            item.currency = orderModel.currency
          }
          return this.update()
        }
      }, obj);
      return ItemList
    }(BasicList);
    ItemList.register()
  });
  // source: assets/js/dash/form/basic.coffee
  rqzt.define('./form/basic', function (module, exports, __dirname, __filename, process) {
    var Api, BasicFormView, Events, FormView, Source, crowdcontrol, m, riot, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    riot = rqzt('riot/riot');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    FormView = crowdcontrol.view.form.FormView;
    Api = crowdcontrol.data.Api;
    Source = crowdcontrol.data.Source;
    m = crowdcontrol.utils.mediator;
    Events.Form.Prefill = 'form-data-load';
    Events.Form.ResponseSuccess = 'form-response-success';
    Events.Form.ResponseFailed = 'form-response-failed';
    BasicFormView = function (superClass) {
      var obj;
      extend(BasicFormView, superClass);
      function BasicFormView() {
        return BasicFormView.__super__.constructor.apply(this, arguments)
      }
      BasicFormView.prototype.tag = 'basic-form';
      BasicFormView.prototype.redirectPath = '';
      BasicFormView.prototype.path = '';
      BasicFormView.prototype.html = rqzt('./templates/dash/form/template');
      BasicFormView.prototype.id = null;
      BasicFormView.prototype.error = null;
      BasicFormView.prototype.processButtonText = 'Saving...';
      BasicFormView.prototype.successButtonText = 'Saved';
      BasicFormView.prototype.events = (obj = {}, obj['' + Events.Form.SubmitFailed] = function () {
        return requestAnimationFrame(function () {
          var $container;
          $container = $('.error-container');
          if ($container[0]) {
            return $('html, body').animate({ scrollTop: $container.offset().top - $(window).height() / 2 }, 1000)
          }
        })
      }, obj);
      BasicFormView.prototype.deleteModal = function () {
        return bootbox.dialog({
          title: 'Are You Sure?',
          message: 'Deleting this will remove it forever.',
          buttons: {
            Yes: {
              className: 'btn btn-danger',
              callback: function (_this) {
                return function () {
                  return _this['delete']()
                }
              }(this)
            },
            No: {
              className: 'btn btn-primary',
              callback: function () {
              }
            }
          }
        })
      };
      BasicFormView.prototype['delete'] = function () {
        m.trigger('start-spin', this.path + '-delete');
        return this.api['delete'](this.path)['finally'](function (_this) {
          return function (e) {
            if (e) {
              console.log(e.stack)
            }
            window.location.hash = _this.redirectPath;
            return riot.update()
          }
        }(this))
      };
      BasicFormView.prototype.js = function (opts) {
        var api;
        BasicFormView.__super__.js.apply(this, arguments);
        this.api = api = Api.get('crowdstart');
        if (this.id != null) {
          this.loading = true;
          m.trigger('start-spin', this.path + '-form-load');
          return api.get(this.path).then(function (_this) {
            return function (res) {
              m.trigger('stop-spin', _this.path + '-form-load');
              if (res.status !== 200 && res.status !== 204) {
                throw new Error('Form failed to load: ')
              }
              _this.model = res.responseText;
              _this.loadData(_this.model);
              _this.initFormGroup();
              _this.obs.trigger(Events.Form.Prefill, _this.model);
              return riot.update()
            }
          }(this))['catch'](function (_this) {
            return function (e) {
              console.log(e.stack);
              return _this.error = e
            }
          }(this))
        } else {
          return requestAnimationFrame(function (_this) {
            return function () {
              return _this.obs.trigger(Events.Form.Prefill, _this.model)
            }
          }(this))
        }
      };
      BasicFormView.prototype.initFormGroup = function () {
        var input, key, ref;
        if (this.id == null && this.inputs != null) {
          ref = this.inputs;
          for (key in ref) {
            input = ref[key];
            input.model.value = ''
          }
        }
        return BasicFormView.__super__.initFormGroup.apply(this, arguments)
      };
      BasicFormView.prototype.loadData = function (model) {
      };
      BasicFormView.prototype._submit = function (event) {
        var $button, buttonText, method;
        m.trigger('start-spin', this.path + '-form-save');
        this.update();
        method = this.id != null ? 'patch' : 'post';
        $button = $(event.target).find('input[type=submit], button[type=submit]');
        buttonText = $button.text();
        $button.text(this.processButtonText);
        $button.prop('disabled', true);
        this.fullyValidated = false;
        return this.api[method](this.path, this.model).then(function (_this) {
          return function (res) {
            if (res.status !== 200 && res.status !== 201 && res.status !== 204) {
              throw new Error(res.responseText.error.message)
            }
            _this.error = void 0;
            m.trigger('stop-spin', _this.path + '-form-save');
            $button.text(_this.successButtonText);
            setTimeout(function () {
              $button.text(buttonText);
              return $button.prop('disabled', false)
            }, 1000);
            _this.loadData(res.responseText);
            _this.obs.trigger(Events.Form.ResponseSuccess);
            return _this.update()
          }
        }(this))['catch'](function (_this) {
          return function (e) {
            _this.error = e;
            m.trigger('stop-spin', _this.path + '-form-save');
            $button.text('An Error Has Occured');
            setTimeout(function () {
              $button.text(buttonText);
              return $button.prop('disabled', false)
            }, 1000);
            _this.obs.trigger(Events.Form.ResponseFailed);
            return _this.update()
          }
        }(this))
      };
      return BasicFormView
    }(FormView);
    module.exports = BasicFormView
  });
  // source: assets/js/dash/templates/dash/form/template.html
  rqzt.define('./templates/dash/form/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<form class="form-horizontal" onsubmit="{ submit }" onreset="{ reset }">\n  <yield></yield/>\n</form>\n'
  });
  // source: assets/js/dash/table/lists/payment.coffee
  rqzt.define('./table/lists/payment', function (module, exports, __dirname, __filename, process) {
    var BasicList, PaymentList, Source, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicList = rqzt('./table/lists/list');
    PaymentList = function (superClass) {
      extend(PaymentList, superClass);
      function PaymentList() {
        return PaymentList.__super__.constructor.apply(this, arguments)
      }
      PaymentList.prototype.tag = 'payment-list';
      PaymentList.prototype.path = 'payment';
      PaymentList.prototype.headers = [
        field('id', 'Id', 'id', 'id-path:#payment'),
        field('account.chargeId', 'Stripe', 'id', 'id-path://dashboard.stripe.com/payments'),
        field('currency', 'Currency', 'upper'),
        field('amount', 'Total', 'money'),
        field('status', 'Status'),
        field('createdAt', 'Created', 'date')
      ];
      return PaymentList
    }(BasicList);
    PaymentList.register()
  });
  // source: assets/js/dash/table/lists/referral.coffee
  rqzt.define('./table/lists/referral', function (module, exports, __dirname, __filename, process) {
    var BasicList, ReferralList, Source, crowdcontrol, field, m, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicList = rqzt('./table/lists/list');
    m = crowdcontrol.utils.mediator;
    ReferralList = function (superClass) {
      extend(ReferralList, superClass);
      function ReferralList() {
        return ReferralList.__super__.constructor.apply(this, arguments)
      }
      ReferralList.prototype.tag = 'referral-list';
      ReferralList.prototype.path = 'referral';
      ReferralList.prototype.headers = [
        field('userId', 'User Id', 'id', 'id-path:../user/'),
        field('referrerId', 'Referral Token'),
        field('createdAt', 'Referred On', 'date')
      ];
      return ReferralList
    }(BasicList);
    ReferralList.register()
  });
  // source: assets/js/dash/table/lists/referrer.coffee
  rqzt.define('./table/lists/referrer', function (module, exports, __dirname, __filename, process) {
    var BasicList, ReferrerList, Source, crowdcontrol, field, m, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicList = rqzt('./table/lists/list');
    m = crowdcontrol.utils.mediator;
    ReferrerList = function (superClass) {
      extend(ReferrerList, superClass);
      function ReferrerList() {
        return ReferrerList.__super__.constructor.apply(this, arguments)
      }
      ReferrerList.prototype.tag = 'referrer-list';
      ReferrerList.prototype.path = 'referrer';
      ReferrerList.prototype.headers = [
        field('id', 'Referrer Token'),
        field('createdAt', 'Created', 'date')
      ];
      return ReferrerList
    }(BasicList);
    ReferrerList.register()
  });
  // source: assets/js/dash/table/paged/index.coffee
  rqzt.define('./table/paged', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      user: rqzt('./table/paged/user'),
      order: rqzt('./table/paged/order'),
      payment: rqzt('./table/paged/payment'),
      product: rqzt('./table/paged/product'),
      coupon: rqzt('./table/paged/coupon'),
      store: rqzt('./table/paged/store'),
      mailinglist: rqzt('./table/paged/mailinglist'),
      subscriber: rqzt('./table/paged/subscriber')
    }
  });
  // source: assets/js/dash/table/paged/user.coffee
  rqzt.define('./table/paged/user', function (module, exports, __dirname, __filename, process) {
    var BasicPagedTable, Source, UserPagedTable, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicPagedTable = rqzt('./table/paged/paged');
    UserPagedTable = function (superClass) {
      extend(UserPagedTable, superClass);
      function UserPagedTable() {
        return UserPagedTable.__super__.constructor.apply(this, arguments)
      }
      UserPagedTable.prototype.tag = 'user-paged-table';
      UserPagedTable.prototype.path = 'user';
      UserPagedTable.prototype.headers = [
        field('id', 'Email', 'id', 'id-path:#user id-display:email'),
        field('firstName', 'First Name'),
        field('lastName', 'Last Name'),
        field('createdAt', 'Created On', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return UserPagedTable
    }(BasicPagedTable);
    UserPagedTable.register()
  });
  // source: assets/js/dash/table/paged/paged.coffee
  rqzt.define('./table/paged/paged', function (module, exports, __dirname, __filename, process) {
    var Api, BasicPagedTable, BasicTableView, Events, _, capitalizeFirstLetter, crowdcontrol, getSortField, lowerCaseFirstLetter, m, store, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    store = rqzt('store/store');
    table = rqzt('./table/types');
    Api = crowdcontrol.data.Api;
    BasicTableView = table.BasicTableView;
    m = crowdcontrol.utils.mediator;
    lowerCaseFirstLetter = function (string) {
      return string.charAt(0).toLowerCase() + string.slice(1)
    };
    capitalizeFirstLetter = function (string) {
      return string.charAt(0).toUpperCase() + string.slice(1)
    };
    getSortField = function (sortField) {
      if (sortField === 'Id') {
        return 'Id_'
      }
      return sortField
    };
    BasicPagedTable = function (superClass) {
      var obj;
      extend(BasicPagedTable, superClass);
      function BasicPagedTable() {
        return BasicPagedTable.__super__.constructor.apply(this, arguments)
      }
      BasicPagedTable.prototype.tag = 'basic-paged-table';
      BasicPagedTable.prototype.html = rqzt('./templates/dash/table/paged/template');
      BasicPagedTable.prototype.page = 1;
      BasicPagedTable.prototype.maxPage = 2;
      BasicPagedTable.prototype.display = 10;
      BasicPagedTable.prototype.$pagination = $();
      BasicPagedTable.prototype.loaded = false;
      BasicPagedTable.prototype.lock = false;
      BasicPagedTable.prototype.staticModel = null;
      BasicPagedTable.prototype.events = (obj = {}, obj['' + Events.Table.PrepareForNewData] = function () {
        this.loaded = false;
        this.staticModel = null;
        this.model = [];
        this.lock = true;
        return this.update()
      }, obj['' + Events.Table.NewData] = function (model) {
        this.loaded = true;
        this.staticModel = model;
        return this.loadData()
      }, obj['' + Events.Form.SubmitSuccess] = function () {
        return setTimeout(function (_this) {
          return function () {
            return _this.refresh()
          }
        }(this), 1000)
      }, obj);
      BasicPagedTable.prototype.js = function (opts) {
        var display;
        BasicPagedTable.__super__.js.apply(this, arguments);
        display = store.get('display');
        if (display) {
          this.display = display
        } else {
          store.set('display', this.display)
        }
        this.filterModel = {
          sortField: 'UpdatedAt',
          sortDirection: '',
          minDate: '',
          maxDate: ''
        };
        if (opts.path) {
          this.path = opts.path
        }
        this.api = Api.get('crowdstart');
        this.on('update', function (_this) {
          return function () {
            return requestAnimationFrame(function () {
              return _this.initDynamicContent()
            })
          }
        }(this));
        return this.refresh()
      };
      BasicPagedTable.prototype.sort = function (id) {
        var field;
        field = capitalizeFirstLetter(id);
        return function (_this) {
          return function () {
            var ref;
            if (_this.locked) {
              return
            }
            if ((ref = _this.headerMap[id]) != null ? ref.hints['dontsort'] : void 0) {
              return
            }
            if (field === 'Number') {
              return
            }
            if (field !== _this.filterModel.sortField) {
              _this.filterModel.sortField = field;
              _this.filterModel.sortDirection = 'sort-desc'
            } else if (_this.filterModel.sortDirection !== 'sort-desc') {
              _this.filterModel.sortDirection = 'sort-desc'
            } else {
              _this.filterModel.sortDirection = 'sort-asc'
            }
            return _this.refresh()
          }
        }(this)
      };
      BasicPagedTable.prototype.initDynamicContent = function () {
        var $pagination, $select;
        $select = $($(this.root).find('select')[0]);
        if ($select[0] != null) {
          if (!this.initializedSelect) {
            $select.select2({ minimumResultsForSearch: 1e+400 }).change(function (_this) {
              return function (event) {
                return _this.updateDisplay(event)
              }
            }(this));
            this.initializedSelect = true
          } else {
            setTimeout(function (_this) {
              return function () {
                return $select.select2('val', _this.display)
              }
            }(this), 500)
          }
        }
        this.$pagination = $pagination = $(this.root).find('.pagination');
        if (!this.initializedPaging && $pagination[0] != null) {
          $pagination.jqPagination({
            paged: function (_this) {
              return function (page) {
                if (page !== _this.page && !_this.lock) {
                  _this.lock = true;
                  _this.page = page;
                  return _this.refresh()
                }
              }
            }(this)
          });
          return this.initializedPaging = true
        }
      };
      BasicPagedTable.prototype.updateDisplay = function (event) {
        var display;
        display = parseInt($(event.target).val(), 10);
        if (this.display !== display) {
          store.set('display', display);
          this.display = display;
          this.page = 1;
          this.refresh();
          return requestAnimationFrame(function (_this) {
            return function () {
              return _this.initDynamicContent()
            }
          }(this))
        }
      };
      BasicPagedTable.prototype.refresh = function () {
        var coeff, path, sortField;
        sortField = getSortField(this.filterModel.sortField);
        if (this.staticModel != null) {
          sortField = lowerCaseFirstLetter(sortField);
          coeff = 1;
          if (this.filterModel.sortDirection === 'sort-asc') {
            coeff = -1
          }
          this.staticModel.sort(function (a, b) {
            if (_.isNumber(a[sortField])) {
              return coeff * (a[sortField] - b[sortField])
            } else if (moment.isDate(a[sortField])) {
              return coeff * (moment(a[sortField]).isAfter(b[sortField]) ? 1 : -1)
            } else if (_.isString(a[sortField])) {
              return coeff * a[sortField].localeCompare(b[sortField])
            } else if (_.isBoolean(a[sortField])) {
              return coeff * (a[sortField] ? 1 : -1)
            } else {
              return -coeff
            }
          });
          this.loadData();
          return
        }
        path = this.path + '?page=' + this.page + '&display=' + this.display + '&sort=' + (this.filterModel.sortDirection === 'sort-desc' ? '' : '-') + sortField;
        if (!window.User.owner) {
          path += '&limit=1000'
        }
        requestAnimationFrame(function () {
          return $('.previous, .next').addClass('disabled')
        });
        return this.api.get(path).then(function (_this) {
          return function (res) {
            var data;
            _this.loaded = true;
            data = res.responseText;
            return _this.loadData(data)
          }
        }(this))
      };
      BasicPagedTable.prototype.loadData = function (data) {
        var ref;
        this.model = [];
        this.update();
        if (this.staticModel != null) {
          this.model = this.staticModel.slice(this.display * (this.page - 1), this.display * this.page);
          this.count = this.staticModel.length
        } else {
          this.model = data.models;
          this.count = data.count
        }
        this.maxPage = Math.ceil(this.count / ((ref = data != null ? data.display : void 0) != null ? ref : this.display));
        riot.update();
        this.initDynamicContent();
        this.$pagination.jqPagination('option', 'max_page', this.maxPage);
        this.lock = false;
        return requestAnimationFrame(function () {
          return $('.previous, .next').removeClass('disabled')
        })
      };
      return BasicPagedTable
    }(BasicTableView);
    module.exports = BasicPagedTable
  });
  // source: assets/js/dash/templates/dash/table/paged/template.html
  rqzt.define('./templates/dash/table/paged/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div if="{ !isEmpty() && loaded }">\n  <div class="section row p5">\n    <div class="col-sm-4 col-xs-8">\n      <select class="form-control" style="width:80px;" if="{ maxPage > 1 || model.length > 5 }">\n        <option value="5" __selected="{5 == display }">5</option>\n        <option value="10" __selected="{10 == display }">10</option>\n        <option value="20" __selected="{20 == display }">20</option>\n        <option value="50" __selected="{50 == display }">50</option>\n        <option value="100" __selected="{100 == display }">100</option>\n      </select>\n      <label if="{ maxPage > 1 || model.length > 5 }">&nbsp;&nbsp;Items per Page</label>\n    </div>\n    <div class="col-sm-4 hidden-xs">\n      <!-- <div class="pagination section text-center" if="{ maxPage > 1 && display > 20 }"> -->\n      <!--   <a href="#" class="previous" data-action="previous"> -->\n      <!--     &lsaquo; -->\n      <!--   </a> -->\n      <!--   <input class="text-center form-control" type="text" readonly="readonly" data-max-page="40"> -->\n      <!--   <a href="#" class="next" data-action="next"> -->\n      <!--     &rsaquo; -->\n      <!--   </a> -->\n      <!-- </div> -->\n    </div>\n    <div class="col-sm-4 col-xs-4 text-right" if="{ maxPage > 1 || model.length > 5 }">\n      <label class="form-control-static">{ count } Results</label>\n    </div>\n    <br if="{ maxPage > 1 || model.length > 5 }"/>\n    <br if="{ maxPage > 1 || model.length > 5 }"/>\n  </div>\n  <div class="table-responsive">\n    <table class="table table-striped table-hover mb20">\n      <thead>\n        <tr>\n          <th class="{ text-right: type == \'date\' || type == \'ago\' || type == \'money\', sortable: true }" each="{ headers }" onclick="{ this.parent.sort(hints[\'id-display\'] || id) }">{name}&nbsp;<i  if="{ this.parent.filterModel.sortField.toUpperCase() == id.toUpperCase() }" class="{ fa: true, fa-sort-asc: this.parent.filterModel.sortDirection == \'sort-asc\', fa-sort-desc: this.parent.filterModel.sortDirection == \'sort-desc\' }"></i></th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr each="{ row, i in model }" class="animated fadeIn">\n          <td each="{ field, j in this.parent.headers }">\n            <table-field field="{ field }" row="{ this.parent }"></table-field>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n  <div class="pagination section text-center" if="{ maxPage > 1 }">\n    <a href="#" class="previous" data-action="previous">\n      &lsaquo;\n    </a>\n    <input class="text-center form-control" type="text" readonly="readonly" data-max-page="40">\n    <a href="#" class="next" data-action="next">\n      &rsaquo;\n    </a>\n  </div>\n</div>\n<h3 class="text-center pb10" if="{ !loaded }">\n  <div class="status-message" if="{ searching }">\n    <i class="glyphicon glyphicon-search" style="font-size:50px"></i>\n    <h2 class="text-center">Searching...</h2>\n  </div>\n  <div class="status-message" if="{ !searching }">\n    <i class="fa fa-spinner fa-spin" style="font-size:50px"></i>\n    <h2 class="text-center">Loading...</h2>\n  </div>\n</h3>\n<h3 class="text-center pb10" if="{ isEmpty() && loaded }">\n  <div class="status-message" if="{ searching }">\n    <i class="glyphicon glyphicon-search" style="font-size:50px"></i>\n    <h2 class="text-center">Searching...</h2>\n  </div>\n  <div class="status-message" if="{ !searching }">\n    <yield></yield>\n  </div>\n</h3>\n'
  });
  // source: assets/js/dash/table/paged/order.coffee
  rqzt.define('./table/paged/order', function (module, exports, __dirname, __filename, process) {
    var BasicPagedTable, OrderPagedTable, Source, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicPagedTable = rqzt('./table/paged/paged');
    OrderPagedTable = function (superClass) {
      extend(OrderPagedTable, superClass);
      function OrderPagedTable() {
        return OrderPagedTable.__super__.constructor.apply(this, arguments)
      }
      OrderPagedTable.prototype.tag = 'order-paged-table';
      OrderPagedTable.prototype.path = 'order';
      OrderPagedTable.prototype.headers = [
        field('id', 'Number', 'id', 'id-display:number id-path:#order'),
        field('userId', 'User', 'id', 'id-path:#user'),
        field('currency', 'Currency', 'upper'),
        field('total', 'Total', 'money'),
        field('status', 'Status'),
        field('paymentStatus', 'Paid'),
        field('fulfillmentStatus', 'Fullfilled'),
        field('couponCodes', 'Coupon(s)', 'id-list', 'id-path:#coupon'),
        field('createdAt', 'Created On', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return OrderPagedTable
    }(BasicPagedTable);
    OrderPagedTable.register()
  });
  // source: assets/js/dash/table/paged/payment.coffee
  rqzt.define('./table/paged/payment', function (module, exports, __dirname, __filename, process) {
    var BasicPagedTable, PaymentPagedTable, Source, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicPagedTable = rqzt('./table/paged/paged');
    PaymentPagedTable = function (superClass) {
      extend(PaymentPagedTable, superClass);
      function PaymentPagedTable() {
        return PaymentPagedTable.__super__.constructor.apply(this, arguments)
      }
      PaymentPagedTable.prototype.tag = 'payment-paged-table';
      PaymentPagedTable.prototype.path = 'payment';
      PaymentPagedTable.prototype.headers = [
        field('id', 'Id', 'id', 'id-path:#payment'),
        field('account.chargeId', 'Stripe', 'id', 'id-path://dashboard.stripe.com/payments'),
        field('orderId', 'Order', 'id', 'id-path:#order'),
        field('currency', 'Currency', 'upper'),
        field('amount', 'Total', 'money'),
        field('status', 'Status'),
        field('createdAt', 'Created', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return PaymentPagedTable
    }(BasicPagedTable);
    PaymentPagedTable.register()
  });
  // source: assets/js/dash/table/paged/product.coffee
  rqzt.define('./table/paged/product', function (module, exports, __dirname, __filename, process) {
    var BasicPagedTable, ProductPagedTable, Source, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicPagedTable = rqzt('./table/paged/paged');
    ProductPagedTable = function (superClass) {
      extend(ProductPagedTable, superClass);
      function ProductPagedTable() {
        return ProductPagedTable.__super__.constructor.apply(this, arguments)
      }
      ProductPagedTable.prototype.tag = 'product-paged-table';
      ProductPagedTable.prototype.path = 'product';
      ProductPagedTable.prototype.headers = [
        field('id', 'Slug', 'id', 'id-display:slug id-path:#product'),
        field('name', 'Name', 'upper'),
        field('currency', 'Currency', 'upper'),
        field('listPrice', 'List Price', 'money'),
        field('price', 'Price', 'money'),
        field('available', 'Available'),
        field('createdAt', 'Created On', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return ProductPagedTable
    }(BasicPagedTable);
    ProductPagedTable.register()
  });
  // source: assets/js/dash/table/paged/coupon.coffee
  rqzt.define('./table/paged/coupon', function (module, exports, __dirname, __filename, process) {
    var BasicPagedTable, CouponPagedTable, Source, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicPagedTable = rqzt('./table/paged/paged');
    CouponPagedTable = function (superClass) {
      extend(CouponPagedTable, superClass);
      function CouponPagedTable() {
        return CouponPagedTable.__super__.constructor.apply(this, arguments)
      }
      CouponPagedTable.prototype.tag = 'coupon-paged-table';
      CouponPagedTable.prototype.path = 'coupon';
      CouponPagedTable.prototype.headers = [
        field('id', 'Code', 'id', 'id-display:code id-path:#coupon'),
        field('name', 'Name'),
        field('type', 'Type'),
        field('amount', 'Amount', 'money'),
        field('enabled', 'Enabled'),
        field('createdAt', 'Created On', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return CouponPagedTable
    }(BasicPagedTable);
    CouponPagedTable.register()
  });
  // source: assets/js/dash/table/paged/store.coffee
  rqzt.define('./table/paged/store', function (module, exports, __dirname, __filename, process) {
    var BasicPagedTable, Source, StorePagedTable, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicPagedTable = rqzt('./table/paged/paged');
    StorePagedTable = function (superClass) {
      extend(StorePagedTable, superClass);
      function StorePagedTable() {
        return StorePagedTable.__super__.constructor.apply(this, arguments)
      }
      StorePagedTable.prototype.tag = 'store-paged-table';
      StorePagedTable.prototype.path = 'store';
      StorePagedTable.prototype.headers = [
        field('id', 'Slug', 'id', 'id-display:slug id-path:#store'),
        field('name', 'Name'),
        field('currency', 'Currency', 'upper'),
        field('createdAt', 'Created On', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return StorePagedTable
    }(BasicPagedTable);
    StorePagedTable.register()
  });
  // source: assets/js/dash/table/paged/mailinglist.coffee
  rqzt.define('./table/paged/mailinglist', function (module, exports, __dirname, __filename, process) {
    var BasicPagedTable, MailingListPagedTable, Source, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicPagedTable = rqzt('./table/paged/paged');
    MailingListPagedTable = function (superClass) {
      extend(MailingListPagedTable, superClass);
      function MailingListPagedTable() {
        return MailingListPagedTable.__super__.constructor.apply(this, arguments)
      }
      MailingListPagedTable.prototype.tag = 'mailinglist-paged-table';
      MailingListPagedTable.prototype.path = 'mailinglist';
      MailingListPagedTable.prototype.headers = [
        field('id', 'Name', 'id', 'id-display:name id-path:#mailinglist'),
        field('mailchimp.id', 'MailChimp List ID'),
        field('id', 'Snippet', 'snippet'),
        field('createdAt', 'Created On', 'date'),
        field('updatedAt', 'Last Updated', 'ago')
      ];
      return MailingListPagedTable
    }(BasicPagedTable);
    MailingListPagedTable.register()
  });
  // source: assets/js/dash/table/paged/subscriber.coffee
  rqzt.define('./table/paged/subscriber', function (module, exports, __dirname, __filename, process) {
    var BasicPagedTable, Source, SubscriberPagedTable, crowdcontrol, field, table, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    table = rqzt('./table/types');
    field = table.field;
    Source = crowdcontrol.data.Source;
    BasicPagedTable = rqzt('./table/paged/paged');
    SubscriberPagedTable = function (superClass) {
      extend(SubscriberPagedTable, superClass);
      function SubscriberPagedTable() {
        return SubscriberPagedTable.__super__.constructor.apply(this, arguments)
      }
      SubscriberPagedTable.prototype.tag = 'subscriber-paged-table';
      SubscriberPagedTable.prototype.path = 'subscriber';
      SubscriberPagedTable.prototype.headers = [
        field('id', 'Email', 'id', 'id-path:#subscriber id-display:email'),
        field('userId', 'User', 'id', 'id-path:#user'),
        field('mailingListId', 'MailingList', 'id', 'id-path:#mailinglist'),
        field('client.referer', 'Referrer', '', 'dontsort'),
        field('unsubscribed', 'Unsubscribed', ''),
        field('createdAt', 'Created', 'date')
      ];
      return SubscriberPagedTable
    }(BasicPagedTable);
    SubscriberPagedTable.register()
  });
  // source: assets/js/dash/form/index.coffee
  rqzt.define('./form', function (module, exports, __dirname, __filename, process) {
    rqzt('./form/controls');
    module.exports = {
      admin: rqzt('./form/admin'),
      generic: rqzt('./form/generic'),
      randomPassword: rqzt('./form/random-password'),
      uniqueCoupon: rqzt('./form/unique-coupon'),
      pane: rqzt('./form/pane')
    }
  });
  // source: assets/js/dash/form/controls/index.coffee
  rqzt.define('./form/controls', function (module, exports, __dirname, __filename, process) {
    var AnalyticsEventsSelect, Api, BasicInputView, BasicSelectView, BasicTextareaView, CodeMirrorView, CountrySelectView, CouponTypeSelectView, CurrencySelectView, DatePickerView, DisabledInputView, Events, FulfillmentStatusSelect, IdLinkView, IdListLinkView, InputView, MailinglistThankyouSelectView, MoneyInputView, NumericInputView, OrderStatusSelect, PasswordInputView, PaymentStatusSelect, PercentInputView, ProductSelectView, ShippingServiceSelect, StaticDateView, StaticMoneyView, StaticPreView, StaticView, Switch, View, _, crowdcontrol, helpers, riot, util, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    _ = rqzt('underscore/underscore');
    riot = rqzt('riot/riot');
    util = rqzt('./util');
    Api = crowdcontrol.data.Api;
    View = crowdcontrol.view.View;
    InputView = crowdcontrol.view.form.InputView;
    helpers = crowdcontrol.view.form.helpers;
    helpers.defaultTagName = 'basic-input';
    StaticView = function (superClass) {
      extend(StaticView, superClass);
      function StaticView() {
        return StaticView.__super__.constructor.apply(this, arguments)
      }
      StaticView.prototype.tag = 'static';
      StaticView.prototype.html = rqzt('./templates/dash/form/controls/static');
      return StaticView
    }(InputView);
    StaticView.register();
    StaticPreView = function (superClass) {
      extend(StaticPreView, superClass);
      function StaticPreView() {
        return StaticPreView.__super__.constructor.apply(this, arguments)
      }
      StaticPreView.prototype.tag = 'static-pre';
      StaticPreView.prototype.html = rqzt('./templates/dash/form/controls/static-pre');
      return StaticPreView
    }(StaticView);
    StaticPreView.register();
    StaticDateView = function (superClass) {
      extend(StaticDateView, superClass);
      function StaticDateView() {
        return StaticDateView.__super__.constructor.apply(this, arguments)
      }
      StaticDateView.prototype.tag = 'static-date';
      StaticDateView.prototype.html = rqzt('./templates/dash/form/controls/static-date');
      return StaticDateView
    }(StaticView);
    StaticDateView.register();
    IdLinkView = function (superClass) {
      extend(IdLinkView, superClass);
      function IdLinkView() {
        return IdLinkView.__super__.constructor.apply(this, arguments)
      }
      IdLinkView.prototype.tag = 'id-link';
      IdLinkView.prototype.html = rqzt('./templates/dash/form/controls/id-link');
      IdLinkView.prototype.js = function (opts) {
        IdLinkView.__super__.js.apply(this, arguments);
        return this.path = opts.input.model.cfg.hints['id-path']
      };
      return IdLinkView
    }(StaticView);
    IdLinkView.register();
    IdListLinkView = function (superClass) {
      extend(IdListLinkView, superClass);
      function IdListLinkView() {
        return IdListLinkView.__super__.constructor.apply(this, arguments)
      }
      IdListLinkView.prototype.tag = 'id-list-link';
      IdListLinkView.prototype.html = rqzt('./templates/dash/form/controls/id-list-link');
      return IdListLinkView
    }(IdLinkView);
    IdListLinkView.register();
    BasicInputView = function (superClass) {
      extend(BasicInputView, superClass);
      function BasicInputView() {
        return BasicInputView.__super__.constructor.apply(this, arguments)
      }
      BasicInputView.prototype.errorHtml = '';
      BasicInputView.prototype.tag = 'basic-input';
      BasicInputView.prototype.html = rqzt('./templates/dash/form/controls/basic-input');
      BasicInputView.prototype.js = function (opts) {
        return this.model = opts.input ? opts.input.model : this.model
      };
      return BasicInputView
    }(InputView);
    BasicInputView.register();
    PasswordInputView = function (superClass) {
      extend(PasswordInputView, superClass);
      function PasswordInputView() {
        return PasswordInputView.__super__.constructor.apply(this, arguments)
      }
      PasswordInputView.prototype.tag = 'basic-password';
      PasswordInputView.prototype.html = rqzt('./templates/dash/form/controls/password');
      return PasswordInputView
    }(BasicInputView);
    PasswordInputView.register();
    NumericInputView = function (superClass) {
      var obj;
      extend(NumericInputView, superClass);
      function NumericInputView() {
        return NumericInputView.__super__.constructor.apply(this, arguments)
      }
      NumericInputView.prototype.tag = 'numeric-input';
      NumericInputView.prototype.events = (obj = {}, obj['' + Events.Input.Set] = function (name, value) {
        var v;
        if (name === this.model.name) {
          this.clearError();
          v = parseFloat(value);
          return this.model.value = isNaN(v) ? 0 : v
        }
      }, obj);
      NumericInputView.prototype.js = function (opts) {
        var v;
        NumericInputView.__super__.js.apply(this, arguments);
        v = parseFloat(this.model.value);
        return this.model.value = isNaN(v) ? 0 : v
      };
      return NumericInputView
    }(BasicInputView);
    NumericInputView.register();
    DatePickerView = function (superClass) {
      extend(DatePickerView, superClass);
      function DatePickerView() {
        return DatePickerView.__super__.constructor.apply(this, arguments)
      }
      DatePickerView.prototype.tag = 'date-picker';
      DatePickerView.prototype.js = function (opts) {
        DatePickerView.__super__.js.apply(this, arguments);
        return this.on('update', function (_this) {
          return function () {
            var $input;
            $input = $(_this.root).find('input');
            if ($input[0] != null) {
              if (!_this.initialized) {
                requestAnimationFrame(function () {
                  return $input.datepicker().on('changeDate', function (event) {
                    return _this.change(event)
                  })
                });
                return _this.initialized = true
              }
            } else {
              return requestAnimationFrame(function () {
                return _this.update()
              })
            }
          }
        }(this))
      };
      return DatePickerView
    }(BasicInputView);
    DatePickerView.register();
    BasicTextareaView = function (superClass) {
      extend(BasicTextareaView, superClass);
      function BasicTextareaView() {
        return BasicTextareaView.__super__.constructor.apply(this, arguments)
      }
      BasicTextareaView.prototype.tag = 'basic-textarea';
      BasicTextareaView.prototype.html = rqzt('./templates/dash/form/controls/basic-textarea');
      return BasicTextareaView
    }(BasicInputView);
    BasicTextareaView.register();
    CodeMirrorView = function (superClass) {
      extend(CodeMirrorView, superClass);
      function CodeMirrorView() {
        return CodeMirrorView.__super__.constructor.apply(this, arguments)
      }
      CodeMirrorView.prototype.tag = 'codemirror-js';
      CodeMirrorView.prototype.js = function (opts) {
        CodeMirrorView.__super__.js.apply(this, arguments);
        this.refresh();
        return this.on('update', function (_this) {
          return function () {
            return _this.refresh()
          }
        }(this))
      };
      CodeMirrorView.prototype.refresh = function () {
        var $el;
        if (this.editor != null) {
          this.editor.refresh();
          return
        }
        $el = $(this.root).find('textarea');
        if ($el[0] != null) {
          this.editor = CodeMirror.fromTextArea($el[0], {
            lineNumbers: true,
            mode: 'javascript',
            gutters: ['CodeMirror-lint-markers'],
            lint: true
          });
          this.editor.on('change', function (_this) {
            return function (instance, changeObj) {
              $el.val(_this.editor.getValue());
              return _this.change({ target: $el[0] })
            }
          }(this));
          return {
            requestAnimationFrame: function (_this) {
              return function () {
                return _this.editor.refresh()
              }
            }(this)
          }
        }
      };
      return CodeMirrorView
    }(BasicTextareaView);
    CodeMirrorView.register();
    Switch = function (superClass) {
      extend(Switch, superClass);
      function Switch() {
        return Switch.__super__.constructor.apply(this, arguments)
      }
      Switch.prototype.tag = 'switch';
      Switch.prototype.html = rqzt('./templates/dash/form/controls/switch');
      Switch.prototype.js = function (opts) {
        this.uid = '_' + Math.random() * 10000;
        return Switch.__super__.js.apply(this, arguments)
      };
      Switch.prototype.change = function (event) {
        var value;
        value = event.target.checked;
        if (value === true || value === 'true') {
          value === true
        } else {
          value = false
        }
        if (value !== this.model.value) {
          this.obs.trigger(Events.Input.Change, this.model.name, value);
          this.model.value = value;
          return this.update()
        }
      };
      return Switch
    }(BasicInputView);
    Switch.register();
    DisabledInputView = function (superClass) {
      extend(DisabledInputView, superClass);
      function DisabledInputView() {
        return DisabledInputView.__super__.constructor.apply(this, arguments)
      }
      DisabledInputView.prototype.tag = 'disabled-input';
      DisabledInputView.prototype.html = rqzt('./templates/dash/form/controls/disabled-input');
      return DisabledInputView
    }(BasicInputView);
    DisabledInputView.register();
    MoneyInputView = function (superClass) {
      var obj;
      extend(MoneyInputView, superClass);
      function MoneyInputView() {
        return MoneyInputView.__super__.constructor.apply(this, arguments)
      }
      MoneyInputView.prototype.tag = 'money-input';
      MoneyInputView.prototype.events = (obj = {}, obj['' + Events.Input.Set] = function (name, value) {
        if (name === this.model.name) {
          this.clearError();
          value = isNaN(parseFloat(value)) ? 0 : value;
          return this.currency(function (_this) {
            return function (code) {
              _this.model.value = util.currency.renderUICurrencyFromJSON(code, value);
              return _this.update()
            }
          }(this))
        }
      }, obj);
      MoneyInputView.prototype.change = function (event) {
        var value;
        value = this.getValue(event.target);
        return this.currency(function (_this) {
          return function (code) {
            _this.obs.trigger(Events.Input.Change, _this.model.name, util.currency.renderJSONCurrencyFromUI(code, value));
            _this.model.value = value;
            return _this.update
          }
        }(this))
      };
      MoneyInputView.prototype.currency = function (fn) {
        return this.obs.trigger(Events.Input.Get, 'currency').one(Events.Input.Result, function (result) {
          return fn(result)
        })
      };
      MoneyInputView.prototype.js = function (opts) {
        var model;
        this.model = opts.input ? opts.input.model : this.model;
        model = this.model;
        this.currency(function (code) {
          return model.value = util.currency.renderUICurrencyFromJSON(code, model.value)
        });
        return this.on('update', function (_this) {
          return function () {
            return _this.currency(function (code) {
              var value;
              value = util.currency.renderUpdatedUICurrency(code, model.value);
              if (value !== model.value) {
                model.value = value;
                return _this.update()
              }
            })
          }
        }(this))
      };
      return MoneyInputView
    }(BasicInputView);
    MoneyInputView.register();
    StaticMoneyView = function (superClass) {
      extend(StaticMoneyView, superClass);
      function StaticMoneyView() {
        return StaticMoneyView.__super__.constructor.apply(this, arguments)
      }
      StaticMoneyView.prototype.tag = 'static-money';
      StaticMoneyView.prototype.html = rqzt('./templates/dash/form/controls/static');
      return StaticMoneyView
    }(MoneyInputView);
    StaticMoneyView.register();
    PercentInputView = function (superClass) {
      extend(PercentInputView, superClass);
      function PercentInputView() {
        return PercentInputView.__super__.constructor.apply(this, arguments)
      }
      PercentInputView.prototype.tag = 'percent-input';
      PercentInputView.prototype.html = rqzt('./templates/dash/form/controls/percent-input');
      PercentInputView.prototype.change = function (event) {
        var value;
        value = this.getValue(event.target);
        value = parseFloat(value);
        if (isNaN(value)) {
          value = 0
        }
        this.obs.trigger(Events.Input.Change, this.model.name, value);
        this.model.value = value;
        return this.update()
      };
      return PercentInputView
    }(BasicInputView);
    PercentInputView.register();
    BasicSelectView = function (superClass) {
      var obj;
      extend(BasicSelectView, superClass);
      function BasicSelectView() {
        return BasicSelectView.__super__.constructor.apply(this, arguments)
      }
      BasicSelectView.prototype.tag = 'basic-select';
      BasicSelectView.prototype.html = rqzt('./templates/dash/form/controls/basic-select');
      BasicSelectView.prototype.any = false;
      BasicSelectView.prototype.tags = false;
      BasicSelectView.prototype.async = false;
      BasicSelectView.prototype.optionsLoaded = false;
      BasicSelectView.prototype.lastValueSet = null;
      BasicSelectView.prototype.events = (obj = {}, obj['' + Events.Input.Set] = function (name, value) {
        if (name === this.model.name && value != null) {
          this.clearError();
          this.model.value = value;
          return riot.update()
        }
      }, obj);
      BasicSelectView.prototype.options = function () {
        return this.selectOptions
      };
      BasicSelectView.prototype.changed = false;
      BasicSelectView.prototype.change = function (event) {
        var value;
        value = $(event.target).val();
        if (value !== this.model.value) {
          this.obs.trigger(Events.Input.Change, this.model.name, value);
          this.model.value = value;
          this.changed = true;
          return this.update()
        }
      };
      BasicSelectView.prototype.isCustom = function (o) {
        var name, options, value;
        options = o;
        if (options == null) {
          options = this.options()
        }
        for (name in options) {
          value = options[name];
          if (_.isObject(value)) {
            if (!this.isCustom(value)) {
              return false
            }
          } else if (name === this.model.value) {
            return false
          }
        }
        return true
      };
      BasicSelectView.prototype.asyncDone = function () {
        this.optionsLoaded = true;
        if (this.lastValueSet != null) {
          this.model.value = this.lastValueSet
        }
        return this.update()
      };
      BasicSelectView.prototype.initSelect = function ($select) {
        return $select.select2({
          tags: this.tags,
          placeholder: this.model.placeholder,
          minimumResultsForSearch: 10
        }).change(function (_this) {
          return function (event) {
            return _this.change(event)
          }
        }(this))
      };
      BasicSelectView.prototype.js = function (opts) {
        var ref;
        BasicSelectView.__super__.js.apply(this, arguments);
        this.any = (ref = opts.any) != null ? ref : false;
        this.selectOptions = opts.options;
        this.on('update', function (_this) {
          return function () {
            var $select;
            $select = $(_this.root).find('select');
            if ($select[0] != null) {
              if (!_this.initialized) {
                return requestAnimationFrame(function () {
                  _this.initSelect($select);
                  _this.initialized = true;
                  return _this.changed = true
                })
              } else if (_this.changed) {
                return requestAnimationFrame(function () {
                  if (_this.async && !_this.optionsLoaded) {
                    return _this.lastValueSet = _this.model.value
                  } else {
                    if (_this.isCustom()) {
                      $select.select('destroy');
                      _this.initSelect($select)
                    }
                    $select.select2('val', _this.model.value);
                    return _this.changed = false
                  }
                })
              }
            } else {
              return requestAnimationFrame(function () {
                return _this.update()
              })
            }
          }
        }(this));
        return this.on('unmount', function (_this) {
          return function () {
            var $select;
            return $select = $(_this.root).find('select')
          }
        }(this))
      };
      return BasicSelectView
    }(BasicInputView);
    BasicSelectView.register();
    MailinglistThankyouSelectView = function (superClass) {
      extend(MailinglistThankyouSelectView, superClass);
      function MailinglistThankyouSelectView() {
        return MailinglistThankyouSelectView.__super__.constructor.apply(this, arguments)
      }
      MailinglistThankyouSelectView.prototype.tag = 'mailinglist-thankyou-select';
      MailinglistThankyouSelectView.prototype.options = function () {
        return {
          html: 'Show HTML Template where form was.',
          redirect: 'Redirect to URL',
          disable: 'Use the default form action.'
        }
      };
      return MailinglistThankyouSelectView
    }(BasicSelectView);
    MailinglistThankyouSelectView.register();
    CountrySelectView = function (superClass) {
      extend(CountrySelectView, superClass);
      function CountrySelectView() {
        return CountrySelectView.__super__.constructor.apply(this, arguments)
      }
      CountrySelectView.prototype.tag = 'country-select';
      CountrySelectView.prototype.options = function () {
        var countries;
        countries = _.extend(window.countries, {});
        if (this.any) {
          countries['_any'] = 'Any Country'
        }
        return countries
      };
      return CountrySelectView
    }(BasicSelectView);
    CountrySelectView.register();
    CurrencySelectView = function (superClass) {
      extend(CurrencySelectView, superClass);
      function CurrencySelectView() {
        return CurrencySelectView.__super__.constructor.apply(this, arguments)
      }
      CurrencySelectView.prototype.tag = 'currency-select';
      CurrencySelectView.prototype.options = function () {
        var currencies;
        currencies = _.extend(window.currencies, {});
        if (this.any) {
          currencies['_any'] = 'Any Currency'
        }
        return currencies
      };
      return CurrencySelectView
    }(BasicSelectView);
    CurrencySelectView.register();
    CouponTypeSelectView = function (superClass) {
      extend(CouponTypeSelectView, superClass);
      function CouponTypeSelectView() {
        return CouponTypeSelectView.__super__.constructor.apply(this, arguments)
      }
      CouponTypeSelectView.prototype.tag = 'coupon-type-select';
      CouponTypeSelectView.prototype.options = function () {
        return {
          flat: "Flat (Deduct Amount from Product's Price in Product's Currency)",
          percent: "Percent (Deduct Percent from Product's Price)",
          'free-shipping': 'Free Shipping'
        }
      };
      return CouponTypeSelectView
    }(BasicSelectView);
    CouponTypeSelectView.register();
    ProductSelectView = function (superClass) {
      extend(ProductSelectView, superClass);
      function ProductSelectView() {
        return ProductSelectView.__super__.constructor.apply(this, arguments)
      }
      ProductSelectView.prototype.tag = 'product-type-select';
      ProductSelectView.prototype.async = true;
      ProductSelectView.prototype.options = function () {
        var api;
        if (this.products != null) {
          return this.products
        }
        api = Api.get('crowdstart');
        api.get('product').then(function (_this) {
          return function (res) {
            var i, len, product, ref;
            if (_this.any) {
              _this.products = { '_any': 'Any Product' }
            }
            ref = res.responseText.models;
            for (i = 0, len = ref.length; i < len; i++) {
              product = ref[i];
              _this.products[product.id] = product.name
            }
            return _this.asyncDone()
          }
        }(this));
        return this.products = { '_any': 'Any Product' }
      };
      return ProductSelectView
    }(BasicSelectView);
    ProductSelectView.register();
    AnalyticsEventsSelect = function (superClass) {
      extend(AnalyticsEventsSelect, superClass);
      function AnalyticsEventsSelect() {
        return AnalyticsEventsSelect.__super__.constructor.apply(this, arguments)
      }
      AnalyticsEventsSelect.prototype.tag = 'analytics-events-select';
      AnalyticsEventsSelect.prototype.html = rqzt('./templates/dash/form/controls/optgroup-select');
      AnalyticsEventsSelect.prototype.tags = true;
      AnalyticsEventsSelect.prototype.options = function () {
        return {
          'Standard Events': {
            'page': 'Load/Page View',
            'Sign-up': 'Sign-up',
            'Logged In': 'Logged In',
            'Viewed Product': 'Viewed Product',
            'Added Product': 'Added Product',
            'Removed Product': 'Removed Product',
            'Completed Order': 'Completed Order',
            'Viewed Promotion': 'Viewed Promotion',
            'Clicked Promotion': 'Clicked Promotion'
          },
          'E-Commerce Events': {
            'Viewed Product Category': 'Viewed Product Category',
            'Viewed Checkout Step': 'Viewed Checkout Step',
            'Completed Checkout Step': 'Completed Checkout Step',
            'Viewed Checkout Step': 'Viewed Checkout Step',
            'Completed Checkout Step': 'Completed Checkout Step',
            'Viewed Checkout Step': 'Viewed Checkout Step',
            'Completed Checkout Step': 'Completed Checkout Step'
          }
        }
      };
      return AnalyticsEventsSelect
    }(BasicSelectView);
    AnalyticsEventsSelect.register();
    OrderStatusSelect = function (superClass) {
      extend(OrderStatusSelect, superClass);
      function OrderStatusSelect() {
        return OrderStatusSelect.__super__.constructor.apply(this, arguments)
      }
      OrderStatusSelect.prototype.tag = 'order-status-select';
      OrderStatusSelect.prototype.options = function () {
        return {
          cancelled: 'Cancelled',
          completed: 'Completed',
          locked: 'Locked',
          'on-hold': 'On Hold',
          open: 'Open'
        }
      };
      return OrderStatusSelect
    }(BasicSelectView);
    OrderStatusSelect.register();
    PaymentStatusSelect = function (superClass) {
      extend(PaymentStatusSelect, superClass);
      function PaymentStatusSelect() {
        return PaymentStatusSelect.__super__.constructor.apply(this, arguments)
      }
      PaymentStatusSelect.prototype.tag = 'payment-status-select';
      PaymentStatusSelect.prototype.options = function () {
        return {
          cancelled: 'Cancelled',
          credit: 'Credit',
          disputed: 'Disputed',
          failed: 'Failed',
          fraudulent: 'Fraudulent',
          paid: 'Paid',
          refunded: 'Refunded',
          unpaid: 'Unpaid'
        }
      };
      return PaymentStatusSelect
    }(BasicSelectView);
    PaymentStatusSelect.register();
    FulfillmentStatusSelect = function (superClass) {
      extend(FulfillmentStatusSelect, superClass);
      function FulfillmentStatusSelect() {
        return FulfillmentStatusSelect.__super__.constructor.apply(this, arguments)
      }
      FulfillmentStatusSelect.prototype.tag = 'fulfillment-status-select';
      FulfillmentStatusSelect.prototype.options = function () {
        return {
          unfulfilled: 'Unfulfilled',
          labelled: 'Labelled',
          processing: 'Processing',
          shipped: 'Shipped',
          delivered: 'Delivered',
          cancelled: 'Cancelled'
        }
      };
      return FulfillmentStatusSelect
    }(BasicSelectView);
    FulfillmentStatusSelect.register();
    ShippingServiceSelect = function (superClass) {
      extend(ShippingServiceSelect, superClass);
      function ShippingServiceSelect() {
        return ShippingServiceSelect.__super__.constructor.apply(this, arguments)
      }
      ShippingServiceSelect.prototype.tag = 'shipping-service-select';
      ShippingServiceSelect.prototype.options = function () {
        return {
          'GD': 'Domestic Ground',
          '2D': 'Domestic 2 Day',
          '1D': 'Domestic 1 Day',
          'E-INTL': 'International Economy',
          'INTL': 'International Standard',
          'PL-INTL': 'International Plus',
          'PM-INTL': 'International Premium'
        }
      };
      return ShippingServiceSelect
    }(BasicSelectView);
    ShippingServiceSelect.register();
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['switch']
    }, 'switch');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['text']
    }, 'basic-textarea');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['js']
    }, 'codemirror-js');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['password']
    }, 'basic-password');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['disabled']
    }, 'disabled-input');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['basic-select']
    }, 'basic-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['country-select']
    }, 'country-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['coupon-type-select']
    }, 'coupon-type-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['product-type-select']
    }, 'product-type-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['date-picker']
    }, 'date-picker');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['mailinglist-thankyou-select']
    }, 'mailinglist-thankyou-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['currency-type-select']
    }, 'currency-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['analytics-events-select']
    }, 'analytics-events-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['order-status-select']
    }, 'order-status-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['payment-status-select']
    }, 'payment-status-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['fulfillment-status-select']
    }, 'fulfillment-status-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['shipping-service-select']
    }, 'shipping-service-select');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['static-money']
    }, 'static-money');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['static-date']
    }, 'static-date');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['static-pre']
    }, 'static-pre');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['static']
    }, 'static');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['id']
    }, 'id-link');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['id-list']
    }, 'id-list-link');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['numeric']
    }, 'numeric-input');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['money']
    }, 'money-input');
    helpers.registerTag(function (inputCfg) {
      return inputCfg.hints['percent']
    }, 'percent-input');
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['numeric']
    }, function (model, name) {
      var value;
      value = model[name];
      return parseFloat(value)
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['required']
    }, function (model, name) {
      var value;
      value = model[name];
      if (_.isNumber(value)) {
        return value
      }
      value = value != null ? value.trim() : void 0;
      if (value == null || value === '') {
        throw new Error('Required')
      }
      return value
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['min']
    }, function (model, name) {
      var value;
      value = model[name];
      if (value != null & value.length >= parseInt(this.hints['min'], 10)) {
        return value
      }
      throw new Error('Minimum Length is ' + this.hints['min'])
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['password-match']
    }, function (model, name) {
      var value, value2;
      value = model[name];
      value2 = model[this.hints['password-match']];
      if (value === value2) {
        return value
      }
      throw new Error('Your passwords must match')
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['email']
    }, function (model, name) {
      var re, value;
      value = model[name];
      value = value != null ? value.trim().toLowerCase() : void 0;
      re = /[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
      if (value != null && value.match(re)) {
        return value
      }
      throw new Error('Enter a valid email')
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['money']
    }, function (model, name) {
      var value;
      value = model[name];
      return parseFloat(value)
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['percent']
    }, function (model, name) {
      var value;
      value = model[name];
      value = parseFloat(value);
      if (isNaN(value)) {
        value = 0
      }
      return value
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['email-unique']
    }, function (model, name) {
      var value;
      value = model[name];
      if (value === this.hints['email-unique-exception']) {
        return value
      }
      return Api.get('crowdstart').get('account/exists/' + value).then(function (res) {
        if (res.responseText.exists) {
          throw new Error('Email already exists')
        }
        return value
      }, function () {
        return value
      })
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['unique']
    }, function (model, name) {
      var value;
      value = model[name];
      if (value === this.hints['unique-exception']) {
        return value
      }
      return Api.get('crowdstart').get(this.hints['unique-api'] + '/' + value).then(function (res) {
        if (res.status === 200 || res.staticText === 'OK') {
          throw new Error("'" + value + "' is already in use")
        }
        return value
      }, function () {
        return value
      })
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['copy']
    }, function (model, name) {
      var value;
      value = model[name];
      model[this.hints.copy] = value;
      return value
    });
    helpers.registerValidator(function (inputCfg) {
      return inputCfg.hints['gtzero']
    }, function (model, name) {
      var value;
      value = model[name];
      if (value < 0) {
        return 0
      }
      return value
    })
  });
  // source: assets/js/dash/templates/dash/form/controls/static.html
  rqzt.define('./templates/dash/form/controls/static', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>\n  <label __for="{ model.name }" class="control-label text-left { opts.labelclasses || \'col-xs-12\' }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses || \'col-xs-12\' }">\n    <p class="form-control-static">{ model.value || \'&nbsp;\' }</p>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/static-pre.html
  rqzt.define('./templates/dash/form/controls/static-pre', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>\n  <label __for="{ model.name }" class="control-label text-left { opts.labelclasses || \'col-xs-12\' }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses || \'col-xs-12\' }">\n    <pre class="form-control-static">{ JSON.stringify(model.value, null, 2) || \'&nbsp;\' }</pre>\n    {console.log(\'val\', model.value)}\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/static-date.html
  rqzt.define('./templates/dash/form/controls/static-date', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>\n  <label __for="{ model.name }" class="control-label text-left { opts.labelclasses || \'col-xs-12\' }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses || \'col-xs-12\' }">\n    <p class="form-control-static">{ moment(model.value).format("dddd, DD MMMM YYYY") }</p>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/id-link.html
  rqzt.define('./templates/dash/form/controls/id-link', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>\n  <label __for="{ model.name }" class="control-label text-left { opts.labelclasses || \'col-xs-12\' }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses || \'col-xs-12\' }">\n    <p class="form-control-static">\n      <a href="{ path }/{ model.value }">\n        { model.value }\n      </a>\n    </p>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/id-list-link.html
  rqzt.define('./templates/dash/form/controls/id-list-link', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>\n  <label __for="{ model.name }" class="control-label text-left { opts.labelclasses || \'col-xs-12\' }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses || \'col-xs-12\' }">\n    <p class="form-control-static">\n      <a href="{ this.parent.path }/{ v }" each="{ v in model.value }">\n        { v }\n        <br>\n      </a>\n    </p>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/basic-input.html
  rqzt.define('./templates/dash/form/controls/basic-input', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="{has-error: hasError()}">\n  <label __for="{ model.name }" class="control-label { opts.labelclasses }" if="{ opts.label }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses }">\n    <input id="{ model.name }" name="{ model.name }" type="text" onchange="{ change }" onblur="{ change }" value="{ model.value }" placeholder="{ model.placeholder }" class="form-control"></input>\n    <div if="{hasError()}" class="error-container help-block animated fadeInUp">{ error }</div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/password.html
  rqzt.define('./templates/dash/form/controls/password', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="{has-error: hasError()}">\n  <label __for="{ model.name }" class="control-label { opts.labelclasses }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses }">\n    <input id="{ model.name }" name="{ model.name }" type="password" onchange="{ change }" onblur="{ change }" value="{ model.value }" placeholder="{ model.placeholder }" class="form-control"></input>\n    <div if="{hasError()}" class="error-container help-block animated fadeInUp">{ error }</div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/basic-textarea.html
  rqzt.define('./templates/dash/form/controls/basic-textarea', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="{has-error: hasError()}">\n  <label __for="{ model.name }" class="control-label { opts.labelclasses }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses }">\n    <textarea id="{ model.name }" name="{ model.name }" type="text"  onchange="{ change }" onblur="{ change }" placeholder="{ model.placeholder }" class="form-control">{ model.value }</textarea>\n    <div if="{hasError()}" class="error-container help-block animated fadeInUp">{ error }</div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/switch.html
  rqzt.define('./templates/dash/form/controls/switch', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="{has-error: hasError()}">\n  <label __for="{ model.name }" class="control-label { opts.labelclasses }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section admin-form { opts.controlclasses }" style="margin:5px 0">\n    <label class="switch switch-primary">\n      <input id="{ model.name+uid }" name="{ model.name+uid }" type="checkbox" onchange="{ change }" onblur="{ change }" __checked ="{ model.value }"></input>\n      <label for="{ model.name+uid }" data-on="YES" data-off="NO"></label>\n    </label>\n    <div if="{hasError()}" class="error-container help-block animated fadeInUp">{ error }</div>\n  </div>\n</div>\n\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/disabled-input.html
  rqzt.define('./templates/dash/form/controls/disabled-input', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="{form-group: true, has-error: hasError()}">\n  <label __for="{ model.name }" class="control-label { opts.labelclasses || \'col-md-3\' }">{ opts.label }</label>\n  <div class=" { opts.controlclasses || \'col-md-9\' }">\n    <input id="{ model.name }" name="{ model.name }" type="text" onchange="{ change }" onblur="{ change }" value="{ model.value }" placeholder="{ model.placeholder }" class="form-control" disabled></input>\n  </div>\n</div>\n\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/percent-input.html
  rqzt.define('./templates/dash/form/controls/percent-input', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="{has-error: hasError()}">\n  <label __for="{ model.name }" class="control-label { opts.labelclasses }" if="{ opts.label }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses }">\n    <input id="{ model.name }" name="{ model.name }" type="text" onchange="{ change }" onblur="{ change }" value="{ model.value + \'%\' }" placeholder="{ model.placeholder }" class="form-control"></input>\n    <div if="{hasError()}" class="error-container help-block animated fadeInUp">{ error }</div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/basic-select.html
  rqzt.define('./templates/dash/form/controls/basic-select', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="{has-error: hasError()}">\n  <label __for="{ model.name }" class="control-label { opts.labelclasses }" if="{ opts.label }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses }">\n    <select id="{ model.name }" name="{ model.name }" onchange="{ change }" onblur="{ change }" value="{ model.value }" class="form-control" data-placeholder="{ model.placeholder }" style="width:100%">\n      <option if="{ model.placeholder }"></option>\n      <option each="{ value, name in options() }" value="{value}" __selected="{ this.parent.model.value == value }">{name}</option>\n\n      <optgroup if="{ tags && isCustom() }" label="Custom Events">\n        <option value="{ model.value }" selected>{ model.value }<option>\n      </optgroup>\n\n    </select>\n    <div if="{hasError()}" class="error-container help-block animated fadeInUp">{ error }</div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/templates/dash/form/controls/optgroup-select.html
  rqzt.define('./templates/dash/form/controls/optgroup-select', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="{has-error: hasError()}">\n  <label __for="{ model.name }" class="control-label { opts.labelclasses }">\n    <span>{ opts.label }</span>\n  </label>\n  <div class="section { opts.controlclasses }">\n    <select id="{ model.name }" name="{ model.name }" onchange="{ change }" onblur="{ change }" value="{ model.value }" class="form-control" data-placeholder="{ model.placeholder }" style="width:100%">\n      <option if="{ model.placeholder }"></option>\n      <optgroup each="{ label, options in options() }" label="{ label }">\n        <option each="{ value, name in options }" value="{value}" __selected="{ this.parent.parent.model.value == value }">{name}</option>\n      </optgroup>\n\n      <optgroup if="{ tags && isCustom() }" label="Custom Events">\n        <option value="{ model.value }" selected>{ model.value }<option>\n      </optgroup>\n\n    </select>\n    <div if="{hasError()}" class="error-container help-block animated fadeInUp">{ error }</div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/form/admin/index.coffee
  rqzt.define('./form/admin', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      apikeys: rqzt('./form/admin/apikeys'),
      profile: rqzt('./form/admin/profile'),
      stripeIntegration: rqzt('./form/admin/stripeintegration'),
      newpassword: rqzt('./form/admin/newpassword'),
      organization: rqzt('./form/admin/organization')
    }
  });
  // source: assets/js/dash/form/admin/apikeys.coffee
  rqzt.define('./form/admin/apikeys', function (module, exports, __dirname, __filename, process) {
    var ApiKeysForm, Events, Form, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    Form = rqzt('./form/admin/form');
    ApiKeysForm = function (superClass) {
      var obj;
      extend(ApiKeysForm, superClass);
      function ApiKeysForm() {
        return ApiKeysForm.__super__.constructor.apply(this, arguments)
      }
      ApiKeysForm.prototype.tag = 'api-keys-admin-form';
      ApiKeysForm.prototype.path = 'keys';
      ApiKeysForm.prototype.processButtonText = 'Generating';
      ApiKeysForm.prototype.successButtonText = 'Generated';
      ApiKeysForm.prototype.prefill = false;
      ApiKeysForm.prototype.events = (obj = {}, obj['' + Events.Form.ResponseSuccess] = function () {
        return window.location.reload()
      }, obj);
      ApiKeysForm.prototype.inputConfigs = [
        input('live-secret-key', '', 'text'),
        input('live-published-key', '', 'text'),
        input('test-secret-key', '', 'text'),
        input('test-published-key', '', 'text')
      ];
      ApiKeysForm.prototype.generateModal = function (event) {
        return bootbox.dialog({
          title: 'Warning: This will reset all your keys!',
          message: 'Any software integrated with Hanzo will need to be updated to use the new keys.',
          buttons: {
            Reset: {
              className: 'btn btn-danger',
              callback: function (_this) {
                return function () {
                  return _this.submit(event)
                }
              }(this)
            },
            Cancel: {
              className: 'btn btn-primary',
              callback: function () {
              }
            }
          }
        })
      };
      ApiKeysForm.prototype.js = function () {
        this.model = window.Keys;
        return ApiKeysForm.__super__.js.apply(this, arguments)
      };
      return ApiKeysForm
    }(Form);
    ApiKeysForm.register();
    module.exports = ApiKeysForm
  });
  // source: assets/js/dash/form/admin/form.coffee
  rqzt.define('./form/admin/form', function (module, exports, __dirname, __filename, process) {
    var AdminForm, Api, BasicForm, Events, FormView, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    BasicForm = rqzt('./form/basic');
    FormView = crowdcontrol.view.form.FormView;
    Api = crowdcontrol.data.Api;
    AdminForm = function (superClass) {
      extend(AdminForm, superClass);
      function AdminForm() {
        return AdminForm.__super__.constructor.apply(this, arguments)
      }
      AdminForm.prototype.tag = 'admin-form';
      AdminForm.prototype.path = '';
      AdminForm.prototype.processButtonText = 'Saving...';
      AdminForm.prototype.successButtonText = 'Saved';
      AdminForm.prototype.prefill = false;
      AdminForm.prototype.html = BasicForm.prototype.html;
      AdminForm.prototype.events = BasicForm.prototype.events;
      AdminForm.prototype.reset = function () {
      };
      AdminForm.prototype._submit = BasicForm.prototype._submit;
      AdminForm.prototype.loadData = function (model) {
      };
      AdminForm.prototype.js = function (opts) {
        var api;
        AdminForm.__super__.js.apply(this, arguments);
        this.api = api = Api.get('dash');
        if (this.prefill) {
          return api.get(this.path).then(function (_this) {
            return function (res) {
              if (res.status !== 200) {
                throw new Error('Form failed to load')
              }
              _this.model = res.responseText;
              _this.initFormGroup();
              _this.obs.trigger(Events.Form.Prefill, _this.model);
              return riot.update()
            }
          }(this))['catch'](function (e) {
            return console.log(e.stack)
          })
        }
      };
      return AdminForm
    }(FormView);
    module.exports = AdminForm
  });
  // source: assets/js/dash/form/admin/profile.coffee
  rqzt.define('./form/admin/profile', function (module, exports, __dirname, __filename, process) {
    var Form, ProfileForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    input = rqzt('./form/input');
    Form = rqzt('./form/admin/form');
    ProfileForm = function (superClass) {
      extend(ProfileForm, superClass);
      function ProfileForm() {
        return ProfileForm.__super__.constructor.apply(this, arguments)
      }
      ProfileForm.prototype.tag = 'profile-admin-form';
      ProfileForm.prototype.path = 'profile';
      ProfileForm.prototype.prefill = true;
      ProfileForm.prototype.inputConfigs = [
        input('email', 'Email', 'required'),
        input('firstName', 'First Name', 'required'),
        input('lastName', 'Last Name', 'required'),
        input('phone', 'Phone')
      ];
      return ProfileForm
    }(Form);
    ProfileForm.register();
    module.exports = ProfileForm
  });
  // source: assets/js/dash/form/admin/stripeintegration.coffee
  rqzt.define('./form/admin/stripeintegration', function (module, exports, __dirname, __filename, process) {
    var Form, StripeIntegrationForm, _, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    input = rqzt('./form/input');
    Form = rqzt('./form/admin/form');
    StripeIntegrationForm = function (superClass) {
      extend(StripeIntegrationForm, superClass);
      function StripeIntegrationForm() {
        return StripeIntegrationForm.__super__.constructor.apply(this, arguments)
      }
      StripeIntegrationForm.prototype.tag = 'st-ripe-integration-form';
      StripeIntegrationForm.prototype.path = 'stripe';
      StripeIntegrationForm.prototype.prefill = true;
      StripeIntegrationForm.prototype._submit = function () {
      };
      StripeIntegrationForm.prototype.stripeOAuth = function () {
        return window.location.href = 'https://connect.stripe.com/oauth/authorize?response_type=code&client_id=' + this.model.clientId + '&scope=read_write&state=movetoserver&stripe_landing=login&redirect_uri=' + this.model.redirectUrl
      };
      StripeIntegrationForm.prototype.stripeSync = function (event) {
        this.api.get('stripe/sync');
        $(event.target).html('Syncing...');
        return this.syncing = true
      };
      return StripeIntegrationForm
    }(Form);
    StripeIntegrationForm.register();
    module.exports = StripeIntegrationForm
  });
  // source: assets/js/dash/form/admin/newpassword.coffee
  rqzt.define('./form/admin/newpassword', function (module, exports, __dirname, __filename, process) {
    var Form, NewPasswordForm, _, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    input = rqzt('./form/input');
    Form = rqzt('./form/admin/form');
    NewPasswordForm = function (superClass) {
      extend(NewPasswordForm, superClass);
      function NewPasswordForm() {
        return NewPasswordForm.__super__.constructor.apply(this, arguments)
      }
      NewPasswordForm.prototype.tag = 'new-password-admin-form';
      NewPasswordForm.prototype.path = 'profile/password';
      NewPasswordForm.prototype.prefill = false;
      NewPasswordForm.prototype.inputConfigs = [
        input('oldPassword', '******', 'password required min:6'),
        input('password', '******', 'password required min:6'),
        input('confirmPassword', '******', 'password required min:6 password-match:password')
      ];
      return NewPasswordForm
    }(Form);
    NewPasswordForm.register();
    module.exports = NewPasswordForm
  });
  // source: assets/js/dash/form/admin/organization.coffee
  rqzt.define('./form/admin/organization', function (module, exports, __dirname, __filename, process) {
    var Form, OrganizationForm, _, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    input = rqzt('./form/input');
    Form = rqzt('./form/admin/form');
    OrganizationForm = function (superClass) {
      extend(OrganizationForm, superClass);
      function OrganizationForm() {
        return OrganizationForm.__super__.constructor.apply(this, arguments)
      }
      OrganizationForm.prototype.tag = 'organization-admin-form';
      OrganizationForm.prototype.path = 'organization';
      OrganizationForm.prototype.prefill = true;
      OrganizationForm.prototype.inputConfigs = [
        input('name', '', 'static'),
        input('fullName', 'Ex. Crowdstart', 'required'),
        input('website', 'Ex. hanzo.io', ''),
        input('emailWhitelist', 'Ex. your@email.com', 'text'),
        input('googleAnalytics', ''),
        input('facebookTag', '')
      ];
      return OrganizationForm
    }(Form);
    OrganizationForm.register();
    module.exports = OrganizationForm
  });
  // source: assets/js/dash/form/generic/index.coffee
  rqzt.define('./form/generic', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      user: rqzt('./form/generic/user'),
      item: rqzt('./form/generic/item'),
      order: rqzt('./form/generic/order'),
      payment: rqzt('./form/generic/payment'),
      product: rqzt('./form/generic/product'),
      coupon: rqzt('./form/generic/coupon'),
      affiliate: rqzt('./form/generic/affiliate'),
      store: rqzt('./form/generic/store'),
      mailinglist: rqzt('./form/generic/mailinglist'),
      subscriber: rqzt('./form/generic/subscriber')
    }
  });
  // source: assets/js/dash/form/generic/user.coffee
  rqzt.define('./form/generic/user', function (module, exports, __dirname, __filename, process) {
    var Api, Form, UserForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Api = crowdcontrol.data.Api;
    input = rqzt('./form/input');
    Form = rqzt('./form/generic/form');
    UserForm = function (superClass) {
      extend(UserForm, superClass);
      UserForm.prototype.tag = 'user-form';
      UserForm.prototype.redirectPath = '#users';
      UserForm.prototype.path = 'user';
      UserForm.prototype.affiliated = false;
      UserForm.prototype.inputConfigs = [
        input('id', '', 'static'),
        input('email', 'your@email.com', 'required email email-unique email-unique-exception:'),
        input('firstName', 'First Name', 'required'),
        input('lastName', 'Last Name', 'required'),
        input('phone', 'Phone'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date'),
        input('enabled', '', 'switch'),
        input('billingAddress.line1', 'Street Address'),
        input('billingAddress.line2', 'Apt/Suite Number'),
        input('billingAddress.city', 'City'),
        input('billingAddress.state', 'State'),
        input('billingAddress.postalCode', 'Postal/ZIP Code'),
        input('billingAddress.country', 'Choose a Country...', 'country-select'),
        input('shippingAddress.line1', 'Street Address'),
        input('shippingAddress.line2', 'Apt/Suite Number'),
        input('shippingAddress.city', 'City'),
        input('shippingAddress.state', 'State'),
        input('shippingAddress.postalCode', 'Postal/ZIP Code', 'postal-code'),
        input('shippingAddress.country', 'Choose a Country...', 'country-select')
      ];
      function UserForm() {
        UserForm.__super__.constructor.apply(this, arguments)
      }
      UserForm.prototype.loadData = function (model) {
        UserForm.__super__.loadData.apply(this, arguments);
        this.inputConfigs[1].hints['email-unique-exception'] = model.email;
        return this.affiliated = model.affiliateId != null && model.affiliateId !== ''
      };
      UserForm.prototype.assignToUser = function (model) {
        if (this.model.affiliateId !== model.id) {
          this.model.affiliateId = model.id;
          return this._submit({})
        }
      };
      return UserForm
    }(Form);
    UserForm.register();
    module.exports = UserForm
  });
  // source: assets/js/dash/form/generic/form.coffee
  rqzt.define('./form/generic/form', function (module, exports, __dirname, __filename, process) {
    var BasicFormView, Events, GenericForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    BasicFormView = rqzt('./form/basic');
    GenericForm = function (superClass) {
      extend(GenericForm, superClass);
      function GenericForm() {
        return GenericForm.__super__.constructor.apply(this, arguments)
      }
      GenericForm.prototype.tag = 'form';
      GenericForm.prototype.redirectPath = '';
      GenericForm.prototype.path = '';
      GenericForm.prototype.resetModel = null;
      GenericForm.prototype.inputConfigs = [];
      GenericForm.prototype.js = function (opts) {
        var id;
        this.id = id = opts.id;
        if (this.id != null) {
          this.path += '/' + opts.id
        } else {
          this.resetModel = JSON.parse(JSON.stringify(this.model))
        }
        return GenericForm.__super__.js.apply(this, arguments)
      };
      GenericForm.prototype.reset = function (event) {
        if (event != null) {
          event.preventDefault()
        }
        this.model = JSON.parse(JSON.stringify(this.resetModel));
        this.initFormGroup.apply(this);
        this._reset(event);
        this.obs.trigger(Events.Form.Prefill, this.model);
        return riot.update()
      };
      GenericForm.prototype._reset = function (event) {
      };
      GenericForm.prototype._submit = function (event) {
        var p;
        p = GenericForm.__super__._submit.apply(this, arguments);
        return p.then(function (_this) {
          return function () {
            if (_this.id != null) {
              return _this.resetModel = JSON.parse(JSON.stringify(_this.model))
            } else {
              return _this.reset()
            }
          }
        }(this))
      };
      GenericForm.prototype.loadData = function (model) {
        return this.resetModel = JSON.parse(JSON.stringify(model))
      };
      return GenericForm
    }(BasicFormView);
    module.exports = GenericForm
  });
  // source: assets/js/dash/form/generic/item.coffee
  rqzt.define('./form/generic/item', function (module, exports, __dirname, __filename, process) {
    var Api, BasicFormView, Events, Form, ItemForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    BasicFormView = rqzt('./form/basic');
    Form = rqzt('./form/generic/form');
    Api = crowdcontrol.data.Api;
    ItemForm = function (superClass) {
      extend(ItemForm, superClass);
      function ItemForm() {
        return ItemForm.__super__.constructor.apply(this, arguments)
      }
      ItemForm.prototype.tag = 'item-form';
      ItemForm.prototype.inputConfigs = [
        input('productId', '', 'product-type-select'),
        input('quantity', '', 'numeric')
      ];
      ItemForm.prototype.js = function () {
        return ItemForm.__super__.js.apply(this, arguments)
      };
      return ItemForm
    }(Form);
    ItemForm.register()
  });
  // source: assets/js/dash/form/generic/order.coffee
  rqzt.define('./form/generic/order', function (module, exports, __dirname, __filename, process) {
    var Api, BasicFormView, Events, Form, OrderForm, OrderUserStaticForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    BasicFormView = rqzt('./form/basic');
    Form = rqzt('./form/generic/form');
    Api = crowdcontrol.data.Api;
    OrderForm = function (superClass) {
      extend(OrderForm, superClass);
      function OrderForm() {
        return OrderForm.__super__.constructor.apply(this, arguments)
      }
      OrderForm.prototype.tag = 'order-form';
      OrderForm.prototype.redirectPath = 'orders';
      OrderForm.prototype.path = 'order';
      OrderForm.prototype.inputConfigs = [
        input('id', '', 'static'),
        input('number', '', 'static'),
        input('userId', '', 'id id-path:#user'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date'),
        input('shippingAddress.name', 'Recipient Name', 'required'),
        input('shippingAddress.line1', 'Street Address', 'required'),
        input('shippingAddress.line2', 'Apt/Suite Number'),
        input('shippingAddress.city', 'City', 'required'),
        input('shippingAddress.state', 'State', 'required'),
        input('shippingAddress.postalCode', 'Postal/ZIP Code', 'postal-code'),
        input('shippingAddress.country', 'Choose a Country...', 'country-select', 'required'),
        input('refundAmount', 'Refund Amount', 'money gtzero'),
        input('giftEmail', ''),
        input('giftMessage', ''),
        input('currency', '', 'static'),
        input('lineTotal', '', 'static-money'),
        input('discount', '', 'static-money'),
        input('subtotal', '', 'static-money'),
        input('shipping', '', 'static-money'),
        input('refunded', '', 'static-money'),
        input('tax', '', 'static-money'),
        input('total', '', 'static-money'),
        input('couponCodes', '', 'id-list id-path:#coupon'),
        input('status', '', 'order-status-select'),
        input('paymentStatus', '', 'payment-status-select'),
        input('fulfillmentStatus', '', 'fulfillment-status-select'),
        input('shippingService', '', 'shipping-service-select'),
        input('fulfillment.externalId', '', 'static'),
        input('fulfillment.trackingNumber', '', 'static'),
        input('fulfillment.carrier', '', 'static'),
        input('fulfillment.service', '', 'static'),
        input('fulfillment.cost', '', 'static'),
        input('fulfillment.createdAt', '', 'static-date'),
        input('fulfillment.shippedAt', '', 'static-date'),
        input('fulfillment.deliveredAt', '', 'static-date'),
        input('metadata', '', 'static-pre')
      ];
      OrderForm.prototype.initFormGroup = function () {
        OrderForm.__super__.initFormGroup.apply(this, arguments);
        this.model.shippingService = this.inputs.shippingService.model.value = 'GD';
        this.inputs.couponCodes.model.value = this.model.couponCodes;
        return this.inputs.refundAmount.model.value = this.model.refundAmount = this.model.total - this.model.refunded
      };
      OrderForm.prototype.refundModal = function () {
        var value;
        value = $('#refundAmount').val();
        bootbox.dialog({
          title: 'Are You Sure?',
          message: 'This will issue a ' + value + ' refund.',
          buttons: {
            Refund: {
              className: 'btn btn-danger',
              callback: function (_this) {
                return function () {
                  return _this.refund()
                }
              }(this)
            },
            "Don't Refund": {
              className: 'btn btn-primary',
              callback: function () {
              }
            }
          }
        });
        return false
      };
      OrderForm.prototype.shippingModal = function () {
        var value;
        value = $('#refundAmount').val();
        bootbox.dialog({
          title: 'Are You Sure?',
          message: 'This will ship this order.',
          buttons: {
            Ship: {
              className: 'btn btn-danger',
              callback: function (_this) {
                return function () {
                  return _this.ship()
                }
              }(this)
            },
            "Don't Ship": {
              className: 'btn btn-primary',
              callback: function () {
              }
            }
          }
        });
        return false
      };
      OrderForm.prototype.refund = function () {
        return this.api.post(this.path + '/refund', { amount: this.model.refundAmount })['finally'](function (e) {
          if (e) {
            console.log(e.stack)
          }
          return window.location.reload()
        })
      };
      OrderForm.prototype.ship = function () {
        var api;
        api = Api.get('dash');
        return api.post('shipwire/ship/' + this.model.id, { service: this.model.shippingService })['finally'](function (e) {
          if (e) {
            console.log(e.stack)
          }
          return window.location.reload()
        })
      };
      return OrderForm
    }(Form);
    OrderForm.register();
    OrderUserStaticForm = function (superClass) {
      var obj;
      extend(OrderUserStaticForm, superClass);
      function OrderUserStaticForm() {
        return OrderUserStaticForm.__super__.constructor.apply(this, arguments)
      }
      OrderUserStaticForm.prototype.tag = 'order-user-static-form';
      OrderUserStaticForm.prototype.basePath = 'user';
      OrderUserStaticForm.prototype.inputConfigs = [
        input('id', '', 'id id-path:#user'),
        input('email', 'your@email.com', 'static'),
        input('firstName', 'First Name', 'static'),
        input('lastName', 'Last Name', 'static'),
        input('phone', 'Phone', 'static'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      OrderUserStaticForm.prototype.events = (obj = {}, obj['' + Events.Form.Prefill] = function (orderModel) {
        var api;
        this.loading = true;
        this.orderId = orderModel.id;
        if (orderModel.userId) {
          this.path = this.basePath + '/' + orderModel.userId;
          this.api = api = Api.get('crowdstart');
          return api.get(this.path).then(function (_this) {
            return function (res) {
              if (res.status !== 200) {
                throw new Error('Form failed to load')
              }
              _this.model = res.responseText;
              _this.loadData(_this.model);
              _this.initFormGroup();
              return riot.update()
            }
          }(this))['catch'](function (_this) {
            return function (e) {
              _this.error = e;
              console.log(e.stack);
              return riot.update()
            }
          }(this))
        } else {
          this.error = new Error('No UserId');
          return riot.update()
        }
      }, obj);
      OrderUserStaticForm.prototype.js = function () {
        return this.initFormGroup()
      };
      OrderUserStaticForm.prototype.refund = function (event) {
        var api;
        if (orderModel.userId) {
          this.path = this.basePath + '/' + orderModel.userId;
          this.api = api = Api.get('crowdstart');
          return api.get(this.path).then(function (res) {
            if (res.status !== 200) {
              throw new Error('Refund Failed')
            }
          })['catch'](function (_this) {
            return function (e) {
              _this.error = e;
              console.log(e.stack);
              return riot.update()
            }
          }(this))
        }
      };
      OrderUserStaticForm.prototype.resendOrderConfirmation = function (event) {
        var api;
        api = Api.get('dash');
        api.get('sendorderconfirmation/' + this.orderId);
        $(event.target).html('Sent!');
        return this.sending = true
      };
      OrderUserStaticForm.prototype.resendShippingConfirmation = function (event) {
        var api;
        api = Api.get('dash');
        api.get('sendfulfillmentconfirmation/' + this.orderId);
        $(event.target).html('Sent!');
        return this.sending = true
      };
      OrderUserStaticForm.prototype.resendRefundConfirmation = function (event) {
        var api;
        api = Api.get('dash');
        api.get('sendrefundconfirmation/' + this.orderId);
        $(event.target).html('Sent!');
        return this.sending = true
      };
      return OrderUserStaticForm
    }(BasicFormView);
    OrderUserStaticForm.register();
    module.exports = OrderForm
  });
  // source: assets/js/dash/form/generic/payment.coffee
  rqzt.define('./form/generic/payment', function (module, exports, __dirname, __filename, process) {
    var Api, BasicFormView, Events, Form, PaymentForm, PaymentUserStaticForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    BasicFormView = rqzt('./form/basic');
    Form = rqzt('./form/generic/form');
    Api = crowdcontrol.data.Api;
    PaymentForm = function (superClass) {
      extend(PaymentForm, superClass);
      function PaymentForm() {
        return PaymentForm.__super__.constructor.apply(this, arguments)
      }
      PaymentForm.prototype.tag = 'payment-form';
      PaymentForm.prototype.redirectPath = 'payments';
      PaymentForm.prototype.path = 'payment';
      PaymentForm.prototype.inputConfigs = [
        input('id', '', 'static'),
        input('type', '', 'static'),
        input('orderId', '', 'id id-path:#order'),
        input('amount', '', 'static-money'),
        input('amountRefunded', '', 'static-money'),
        input('fee', '', 'static-money'),
        input('status', '', 'static'),
        input('captured', '', 'static'),
        input('live', '', 'static'),
        input('test', '', 'static'),
        input('client.ip', '', 'static'),
        input('client.userAgent', '', 'static'),
        input('client.language', '', 'static'),
        input('client.referer', '', 'static'),
        input('client.city', '', 'static'),
        input('client.region', '', 'static'),
        input('client.country', '', 'static'),
        input('account.chargeId', '', 'id id-path://dashboard.stripe.com/charges'),
        input('account.customerId', '', 'id id-path://dashboard.stripe.com/customers'),
        input('account.cardId', '', 'static'),
        input('account.balanceTransactionId', '', 'static'),
        input('account.fingerprint', '', 'static'),
        input('account.funding', '', 'static'),
        input('account.lastFour', '', 'static'),
        input('account.brand', '', 'static'),
        input('account.month', '', 'static'),
        input('account.year', '', 'static'),
        input('account.country', '', 'static'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      return PaymentForm
    }(Form);
    PaymentForm.register();
    PaymentUserStaticForm = function (superClass) {
      var obj;
      extend(PaymentUserStaticForm, superClass);
      function PaymentUserStaticForm() {
        return PaymentUserStaticForm.__super__.constructor.apply(this, arguments)
      }
      PaymentUserStaticForm.prototype.tag = 'payment-user-static-form';
      PaymentUserStaticForm.prototype.basePath = 'user';
      PaymentUserStaticForm.prototype.inputConfigs = [
        input('id', '', 'id id-path:#user'),
        input('email', 'your@email.com', 'static'),
        input('firstName', 'First Name', 'static'),
        input('lastName', 'Last Name', 'static'),
        input('phone', 'Phone', 'static'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      PaymentUserStaticForm.prototype.events = (obj = {}, obj['' + Events.Form.Prefill] = function (paymentModel) {
        var api, ref, userId;
        this.loading = true;
        this.paymentId = paymentModel.id;
        userId = paymentModel != null ? (ref = paymentModel.buyer) != null ? ref.userId : void 0 : void 0;
        if (userId) {
          this.path = this.basePath + '/' + userId;
          this.api = api = Api.get('crowdstart');
          return api.get(this.path).then(function (_this) {
            return function (res) {
              if (res.status !== 200) {
                throw new Error('Form failed to load')
              }
              _this.model = res.responseText;
              _this.loadData(_this.model);
              _this.initFormGroup();
              return riot.update()
            }
          }(this))['catch'](function (_this) {
            return function (e) {
              _this.error = e;
              console.log(e.stack);
              return riot.update()
            }
          }(this))
        } else {
          this.error = new Error('No UserId');
          return riot.update()
        }
      }, obj);
      PaymentUserStaticForm.prototype.js = function () {
        return this.initFormGroup()
      };
      return PaymentUserStaticForm
    }(BasicFormView);
    PaymentUserStaticForm.register();
    module.exports = PaymentForm
  });
  // source: assets/js/dash/form/generic/product.coffee
  rqzt.define('./form/generic/product', function (module, exports, __dirname, __filename, process) {
    var Api, Form, ProductForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    input = rqzt('./form/input');
    Form = rqzt('./form/generic/form');
    Api = crowdcontrol.data.Api;
    ProductForm = function (superClass) {
      extend(ProductForm, superClass);
      function ProductForm() {
        return ProductForm.__super__.constructor.apply(this, arguments)
      }
      ProductForm.prototype.tag = 'product-form';
      ProductForm.prototype.redirectPath = 'products';
      ProductForm.prototype.path = 'product';
      ProductForm.prototype.model = {
        currency: 'usd',
        available: true
      };
      ProductForm.prototype.inputConfigs = [
        input('id', '', 'static'),
        input('name', 'Product Name (Shirt)', 'required'),
        input('slug', 'Product Slug (SHIRT-123)', 'required unique unique-api:product'),
        input('description', 'Describe this product', 'text'),
        input('currency', '', 'currency-type-select'),
        input('listPrice', 'How much this should cost', 'money'),
        input('price', 'How much this costs right now', 'money'),
        input('estimatedDelivery', 'Estimated Delivery'),
        input('size', '10cm x 10cm x 10cm'),
        input('weight', '1000', 'numeric'),
        input('available', '', 'switch'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      ProductForm.prototype.loadData = function (model) {
        ProductForm.__super__.loadData.apply(this, arguments);
        return this.inputConfigs[2].hints['unique-exception'] = model.slug
      };
      return ProductForm
    }(Form);
    ProductForm.register();
    module.exports = ProductForm
  });
  // source: assets/js/dash/form/generic/coupon.coffee
  rqzt.define('./form/generic/coupon', function (module, exports, __dirname, __filename, process) {
    var Api, CouponForm, Form, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    input = rqzt('./form/input');
    Form = rqzt('./form/generic/form');
    Api = crowdcontrol.data.Api;
    CouponForm = function (superClass) {
      extend(CouponForm, superClass);
      function CouponForm() {
        return CouponForm.__super__.constructor.apply(this, arguments)
      }
      CouponForm.prototype.tag = 'coupon-form';
      CouponForm.prototype.redirectPath = 'coupons';
      CouponForm.prototype.path = 'coupon';
      CouponForm.prototype.model = {
        productId: '_any',
        enabled: true
      };
      CouponForm.prototype.inputConfigs = [
        input('id', '', 'static'),
        input('name', 'Name', 'required'),
        input('code', 'Coupon Code', 'required unique unique-api:coupon'),
        input('type', 'Coupon Type', 'coupon-type-select'),
        input('amount', 'Coupon Amount', 'money'),
        input('limit', 'Limit', 'numeric'),
        input('enabled', 'Enabled', 'switch'),
        input('dynamic', 'Dynamic', 'switch'),
        input('productId', 'Select a Product', 'product-type-select'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      CouponForm.prototype._submit = function (event) {
        if (this.model.productId === '_any') {
          this.model.productId = ''
        }
        return CouponForm.__super__._submit.apply(this, arguments)
      };
      CouponForm.prototype.loadData = function (model) {
        CouponForm.__super__.loadData.apply(this, arguments);
        if (model.productId === '') {
          model.productId = '_any'
        }
        return this.inputConfigs[2].hints['unique-exception'] = model.code
      };
      return CouponForm
    }(Form);
    CouponForm.register();
    module.exports = CouponForm
  });
  // source: assets/js/dash/form/generic/affiliate.coffee
  rqzt.define('./form/generic/affiliate', function (module, exports, __dirname, __filename, process) {
    var AffiliateForm, Api, Events, Form, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    input = rqzt('./form/input');
    Form = rqzt('./form/generic/form');
    Events = crowdcontrol.Events;
    Api = crowdcontrol.data.Api;
    AffiliateForm = function (superClass) {
      extend(AffiliateForm, superClass);
      AffiliateForm.prototype.tag = 'affiliate-form';
      AffiliateForm.prototype.redirectPath = 'users';
      AffiliateForm.prototype.path = 'affiliate';
      AffiliateForm.prototype.model = {
        enabled: false,
        commision: {
          percent: 0,
          flat: 0
        }
      };
      AffiliateForm.prototype.assignToUserFn = function () {
      };
      AffiliateForm.prototype.inputConfigs = [
        input('commission.percent', 'Percent Fee', 'percent'),
        input('commission.flat', 'Flat Fee', 'money'),
        input('enabled', '', 'switch'),
        input('couponId', '', '')
      ];
      function AffiliateForm() {
        this.model = {
          enabled: false,
          commision: {
            percent: 0,
            flat: 0
          }
        };
        AffiliateForm.__super__.constructor.apply(this, arguments)
      }
      AffiliateForm.prototype.js = function (opts) {
        this.assignToUserFn = opts.assigntouserfn;
        if (!this.userObs) {
          this.userObs = opts.userobs;
          this.userObs.on('' + Events.Form.Prefill, function (_this) {
            return function (model) {
              _this.opts.id = _this.model.id = model.affiliateId;
              _this.model.userId = model.id;
              return _this.js(_this.opts)
            }
          }(this))
        }
        return AffiliateForm.__super__.js.apply(this, arguments)
      };
      AffiliateForm.prototype.loadData = function (model) {
        var ref;
        if (model != null) {
          if ((ref = model.commission) != null) {
            ref.percent *= 100
          }
        }
        return AffiliateForm.__super__.loadData.apply(this, arguments)
      };
      AffiliateForm.prototype._submit = function (event) {
        this.model.commission.percent /= 100;
        return AffiliateForm.__super__._submit.call(this, event).then(function (_this) {
          return function () {
            _this.model.commission.percent *= 100;
            return _this.assignToUserFn(model)
          }
        }(this))
      };
      return AffiliateForm
    }(Form);
    AffiliateForm.register();
    module.exports = AffiliateForm
  });
  // source: assets/js/dash/form/generic/store.coffee
  rqzt.define('./form/generic/store', function (module, exports, __dirname, __filename, process) {
    var Api, Form, StoreForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    input = rqzt('./form/input');
    Form = rqzt('./form/generic/form');
    Api = crowdcontrol.data.Api;
    StoreForm = function (superClass) {
      extend(StoreForm, superClass);
      function StoreForm() {
        return StoreForm.__super__.constructor.apply(this, arguments)
      }
      StoreForm.prototype.tag = 'store-form';
      StoreForm.prototype.redirectPath = 'stores';
      StoreForm.prototype.path = 'store';
      StoreForm.prototype.model = { currency: 'usd' };
      StoreForm.prototype.inputConfigs = [
        input('id', '', 'static'),
        input('name', 'Name', 'required'),
        input('slug', 'Store Slug', 'required unique unique-api:store'),
        input('currency', 'Store Currency', 'currency-type-select'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      StoreForm.prototype.loadData = function (model) {
        StoreForm.__super__.loadData.apply(this, arguments);
        return this.inputConfigs[2].hints['unique-exception'] = model.slug
      };
      return StoreForm
    }(Form);
    StoreForm.register();
    module.exports = StoreForm
  });
  // source: assets/js/dash/form/generic/mailinglist.coffee
  rqzt.define('./form/generic/mailinglist', function (module, exports, __dirname, __filename, process) {
    var Api, Form, MailingListForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    input = rqzt('./form/input');
    Form = rqzt('./form/generic/form');
    Api = crowdcontrol.data.Api;
    MailingListForm = function (superClass) {
      extend(MailingListForm, superClass);
      function MailingListForm() {
        return MailingListForm.__super__.constructor.apply(this, arguments)
      }
      MailingListForm.prototype.tag = 'mailinglist-form';
      MailingListForm.prototype.redirectPath = 'mailinglists';
      MailingListForm.prototype.path = 'mailinglist';
      MailingListForm.prototype.model = { facebook: { currency: 'usd' } };
      MailingListForm.prototype.inputConfigs = [
        input('id', '', 'static'),
        input('name', 'Mailing List Name (Shirt)', 'required unique unique-api:mailinglist'),
        input('thankyou.type', 'Choose what happens after form submit', 'mailinglist-thankyou-select required'),
        input('thankyou.html', 'HTML ex. Thank You or <p style="font-weight:600">Thank You</p>\nUrl ex. /thankyou or www.yoursite.com/thankyou.html', 'text copy:thankyou.url'),
        input('mailchimp.id', 'ex. z1593c999e', 'required'),
        input('mailchimp.apiKey', 'ex. myapikey-us2', 'required'),
        input('mailchimp.doubleOptin', 'Double Optin?', 'switch'),
        input('mailchimp.updateExisting', 'Update Existing?', 'switch'),
        input('mailchimp.replaceInterests', 'Replace Interests?', 'switch'),
        input('mailchimp.sendWelcome', 'Send Welcome?', 'switch'),
        input('google.name', 'Event Name'),
        input('google.category', 'Event Category'),
        input('facebook.id', 'Event Id'),
        input('facebook.value', 'ex 0'),
        input('facebook.currency', 'Facebook Currency', 'currency-type-select'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      MailingListForm.prototype.loadData = function (model) {
        MailingListForm.__super__.loadData.apply(this, arguments);
        return this.inputConfigs[1].hints['unique-exception'] = model.name
      };
      return MailingListForm
    }(Form);
    MailingListForm.register();
    module.exports = MailingListForm
  });
  // source: assets/js/dash/form/generic/subscriber.coffee
  rqzt.define('./form/generic/subscriber', function (module, exports, __dirname, __filename, process) {
    var Api, BasicFormView, Events, Form, SubscriberForm, SubscriberUserStaticForm, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    BasicFormView = rqzt('./form/basic');
    Form = rqzt('./form/generic/form');
    Api = crowdcontrol.data.Api;
    SubscriberForm = function (superClass) {
      extend(SubscriberForm, superClass);
      function SubscriberForm() {
        return SubscriberForm.__super__.constructor.apply(this, arguments)
      }
      SubscriberForm.prototype.tag = 'subscriber-form';
      SubscriberForm.prototype.redirectPath = 'subscribers';
      SubscriberForm.prototype.path = 'subscriber';
      SubscriberForm.prototype.inputConfigs = [
        input('id', '', 'static'),
        input('email', 'Email'),
        input('mailingListId', '', 'id id-path:#mailinglist'),
        input('userId', '', 'static'),
        input('unsubscribed', 'Unsubscribed', 'switch'),
        input('metadata', '{}', 'text'),
        input('client.ip', '', 'static'),
        input('client.userAgent', '', 'static'),
        input('client.language', '', 'static'),
        input('client.referer', '', 'static'),
        input('client.city', '', 'static'),
        input('client.region', '', 'static'),
        input('client.country', '', 'static'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      return SubscriberForm
    }(Form);
    SubscriberForm.register();
    SubscriberUserStaticForm = function (superClass) {
      var obj;
      extend(SubscriberUserStaticForm, superClass);
      function SubscriberUserStaticForm() {
        return SubscriberUserStaticForm.__super__.constructor.apply(this, arguments)
      }
      SubscriberUserStaticForm.prototype.tag = 'subscriber-user-static-form';
      SubscriberUserStaticForm.prototype.basePath = 'user';
      SubscriberUserStaticForm.prototype.inputConfigs = [
        input('id', '', 'id id-path:#user'),
        input('email', 'your@email.com', 'static'),
        input('firstName', 'First Name', 'static'),
        input('lastName', 'Last Name', 'static'),
        input('phone', 'Phone', 'static'),
        input('createdAt', '', 'static-date'),
        input('updatedAt', '', 'static-date')
      ];
      SubscriberUserStaticForm.prototype.events = (obj = {}, obj['' + Events.Form.Prefill] = function (subscriberModel) {
        var api, userId;
        this.loading = true;
        this.subscriberId = subscriberModel.id;
        userId = subscriberModel != null ? subscriberModel.userId : void 0;
        if (userId) {
          this.path = this.basePath + '/' + userId;
          this.api = api = Api.get('crowdstart');
          return api.get(this.path).then(function (_this) {
            return function (res) {
              if (res.status !== 200) {
                throw new Error('Form failed to load')
              }
              _this.model = res.responseText;
              _this.loadData(_this.model);
              _this.initFormGroup();
              return riot.update()
            }
          }(this))['catch'](function (_this) {
            return function (e) {
              _this.error = e;
              console.log(e.stack);
              return riot.update()
            }
          }(this))
        } else {
          this.error = new Error('No UserId');
          return riot.update()
        }
      }, obj);
      SubscriberUserStaticForm.prototype.js = function () {
        return this.initFormGroup()
      };
      return SubscriberUserStaticForm
    }(BasicFormView);
    SubscriberUserStaticForm.register();
    module.exports = SubscriberForm
  });
  // source: assets/js/dash/form/random-password/index.coffee
  rqzt.define('./form/random-password', function (module, exports, __dirname, __filename, process) {
    var Api, FormView, ResetPasswordFormView, _, crowdcontrol, input, m, riot, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    riot = rqzt('riot/riot');
    crowdcontrol = rqzt('crowdcontrol/lib');
    input = rqzt('./form/input');
    Api = crowdcontrol.data.Api;
    FormView = crowdcontrol.view.form.FormView;
    m = crowdcontrol.utils.mediator;
    ResetPasswordFormView = function (superClass) {
      extend(ResetPasswordFormView, superClass);
      function ResetPasswordFormView() {
        return ResetPasswordFormView.__super__.constructor.apply(this, arguments)
      }
      ResetPasswordFormView.prototype.tag = 'reset-password-form';
      ResetPasswordFormView.prototype.html = rqzt('./templates/dash/form/random-password/template');
      ResetPasswordFormView.prototype.model = { password: '' };
      ResetPasswordFormView.prototype.resetModel = null;
      ResetPasswordFormView.prototype.inputConfigs = [input('password', 'Password Appears Here')];
      ResetPasswordFormView.prototype.js = function (opts) {
        var api;
        ResetPasswordFormView.__super__.js.apply(this, arguments);
        this.api = api = Api.get('crowdstart');
        return this.userId = opts.userId || opts.userid
      };
      ResetPasswordFormView.prototype.submit = function () {
        m.trigger('start-spin', 'user-form-save');
        return this.api.get('user/' + this.userId + '/password/reset').then(function (_this) {
          return function (data) {
            m.trigger('stop-spin', 'user-form-save');
            _this.model = data.responseText;
            _this.initFormGroup();
            return riot.update()
          }
        }(this), function () {
          return m.trigger('stop-spin', 'user-form-save')
        })
      };
      return ResetPasswordFormView
    }(FormView);
    ResetPasswordFormView.register()
  });
  // source: assets/js/dash/templates/dash/form/random-password/template.html
  rqzt.define('./templates/dash/form/random-password/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<form class="form-horizontal" onsubmit="{ submit }">\n  <div class="form-group">\n    <control label="" input="{ inputs.password }" labelclasses="" controlclasses="col-xs-12"></control>\n  </div>\n  <div class="form-actions text-center">\n    <button type="button" class="btn btn-dark" onclick="{ submit }">Random Password</button>\n  </div>\n</form>\n\n'
  });
  // source: assets/js/dash/form/unique-coupon/index.coffee
  rqzt.define('./form/unique-coupon', function (module, exports, __dirname, __filename, process) {
    var Api, FormView, UniqueCouponFormView, _, crowdcontrol, input, m, riot, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    riot = rqzt('riot/riot');
    crowdcontrol = rqzt('crowdcontrol/lib');
    input = rqzt('./form/input');
    Api = crowdcontrol.data.Api;
    FormView = crowdcontrol.view.form.FormView;
    m = crowdcontrol.utils.mediator;
    UniqueCouponFormView = function (superClass) {
      extend(UniqueCouponFormView, superClass);
      function UniqueCouponFormView() {
        return UniqueCouponFormView.__super__.constructor.apply(this, arguments)
      }
      UniqueCouponFormView.prototype.tag = 'unique-coupon-form';
      UniqueCouponFormView.prototype.html = rqzt('./templates/dash/form/unique-coupon/template');
      UniqueCouponFormView.prototype.model = {
        couponCode: '',
        code: ''
      };
      UniqueCouponFormView.prototype.uniqueCouponModel = null;
      UniqueCouponFormView.prototype.inputConfigs = [
        input('couponCode', 'Type Coupon Code Here'),
        input('code', 'Coupon Code Appears Here')
      ];
      UniqueCouponFormView.prototype.js = function (opts) {
        var api;
        UniqueCouponFormView.__super__.js.apply(this, arguments);
        this.api = api = Api.get('crowdstart');
        return this.userId = opts.userId || opts.userid
      };
      UniqueCouponFormView.prototype.submit = function () {
        m.trigger('start-spin', 'user-form-save');
        return this.api.get('coupon/' + this.model.couponCode + '/code/' + this.userId).then(function (_this) {
          return function (data) {
            var couponCode;
            m.trigger('stop-spin', 'user-form-save');
            couponCode = _this.model.couponCode;
            _this.model = data.responseText;
            _this.model.couponCode = couponCode;
            _this.initFormGroup();
            return riot.update()
          }
        }(this), function () {
          return m.trigger('stop-spin', 'user-form-save')
        })
      };
      return UniqueCouponFormView
    }(FormView);
    UniqueCouponFormView.register()
  });
  // source: assets/js/dash/templates/dash/form/unique-coupon/template.html
  rqzt.define('./templates/dash/form/unique-coupon/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<form class="form-horizontal" onsubmit="{ submit }">\n  <div class="form-group">\n    <control label="" input="{ inputs.couponCode }" labelclasses="" controlclasses="col-xs-12"></control>\n  </div>\n  <div class="form-group">\n    <control label="" input="{ inputs.code }" labelclasses="" controlclasses="col-xs-12"></control>\n  </div>\n  <div class="form-actions text-center">\n    <button type="button" class="btn btn-dark" onclick="{ submit }">Unique Coupon</button>\n  </div>\n</form>\n\n'
  });
  // source: assets/js/dash/form/pane/index.coffee
  rqzt.define('./form/pane', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      order: rqzt('./form/pane/order'),
      user: rqzt('./form/pane/user')
    }
  });
  // source: assets/js/dash/form/pane/order.coffee
  rqzt.define('./form/pane/order', function (module, exports, __dirname, __filename, process) {
    var Events, OrderFilterPane, Pane, _, crowdcontrol, input, localizeDate, moment, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    moment = rqzt('moment/moment');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    Pane = rqzt('./form/pane/pane');
    localizeDate = function (date) {
      var ref, ref1, ref2, tokens;
      tokens = date.split('/');
      return moment(((ref = tokens[2]) != null ? ref : '2015') + ' ' + ((ref1 = tokens[0]) != null ? ref1 : '01') + ' ' + ((ref2 = tokens[1]) != null ? ref2 : '01'), 'YYYY-MM-DD').format('YYYY-MM-DD')
    };
    OrderFilterPane = function (superClass) {
      extend(OrderFilterPane, superClass);
      function OrderFilterPane() {
        return OrderFilterPane.__super__.constructor.apply(this, arguments)
      }
      OrderFilterPane.prototype.tag = 'order-filter-pane';
      OrderFilterPane.prototype.html = rqzt('./templates/dash/form/pane/order');
      OrderFilterPane.prototype.path = 'search/order';
      OrderFilterPane.prototype.inputConfigs = [
        input('minTotal', '', 'money'),
        input('maxTotal', '', 'money'),
        input('currency', '', 'currency-type-select'),
        input('minDate', '', 'date-picker'),
        input('maxDate', '', 'date-picker'),
        input('country', '', 'country-select'),
        input('type', '', 'basic-select'),
        input('couponCodes', 'Coupon Code'),
        input('status', '', 'basic-select'),
        input('paymentStatus', '', 'basic-select'),
        input('paymentStatus', '', 'basic-select'),
        input('fulfillmentStatus', '', 'basic-select'),
        input('preorder', '', 'basic-select'),
        input('confirmed', '', 'basic-select'),
        input('productIds', '', 'product-type-select')
      ];
      OrderFilterPane.prototype.statusOptions = {
        _any: 'Any Order State',
        cancelled: 'Cancelled',
        completed: 'Completed',
        locked: 'Locked',
        open: 'Open',
        'on-hold': 'On Hold'
      };
      OrderFilterPane.prototype.paymentStatusOptions = {
        _any: 'Any Payment State',
        credit: 'Credit',
        disputed: 'Disputed',
        failed: 'Failed',
        fraudulent: 'Fraud',
        paid: 'Paid',
        refunded: 'Refunded',
        unpaid: 'Unpaid'
      };
      OrderFilterPane.prototype.fulfillmentStatusOptions = {
        _any: 'Any Fulfillment State',
        cancelled: 'Cancelled',
        processing: 'Processing',
        shipped: 'Shipped',
        unfulfilled: 'Unfulfilled'
      };
      OrderFilterPane.prototype.preorderOptions = {
        _any: 'Any Preorder State',
        'true': 'Preorder',
        'false': 'Not Preorder'
      };
      OrderFilterPane.prototype.confirmedOptions = {
        _any: 'Any Confirmation State',
        'true': 'Confirmed',
        'false': 'Unconfirmed'
      };
      OrderFilterPane.prototype.typeOptions = {
        _any: 'Any Payment Processor',
        stripe: 'Stripe',
        paypal: 'Paypal'
      };
      OrderFilterPane.prototype.js = function () {
        this.model = {
          maxDate: moment().format('L'),
          minTotal: 0,
          maxTotal: 0,
          country: '_any',
          currency: '_any',
          minDate: '01/01/2015',
          couponCodes: '',
          type: '_any',
          status: '_any',
          paymentStatus: '_any',
          fulfillmentStatus: '_any',
          preorder: '_any',
          confirmed: '_any',
          productIds: '_any'
        };
        return OrderFilterPane.__super__.js.apply(this, arguments)
      };
      OrderFilterPane.prototype.queryString = function () {
        var maxDate, maxDateStr, minDate, minDateStr, query, swap;
        minDate = localizeDate(this.model.minDate);
        maxDate = localizeDate(this.model.maxDate);
        if (moment(minDate, 'YYYY-MM-DD').isAfter(moment(maxDate, 'YYYY-MM-DD'))) {
          swap = maxDate;
          maxDate = minDate;
          minDate = swap2
        }
        riot.update();
        minDateStr = moment(minDate, 'YYYY-MM-DD').format('YYYY-MM-DD');
        maxDateStr = moment(maxDate, 'YYYY-MM-DD').format('YYYY-MM-DD');
        query = 'CreatedAt >= ' + encodeURIComponent(minDateStr) + ' AND CreatedAt <= ' + encodeURIComponent(maxDateStr);
        if (this.model.country !== '_any') {
          query += ' AND ShippingAddressCountryCode = "' + encodeURIComponent(this.model.country) + '"'
        }
        if (this.model.currency !== '_any') {
          query += ' AND Currency = "' + encodeURIComponent(this.model.currency) + '"'
        }
        if (this.model.minTotal !== 0) {
          query += ' AND Total >= ' + encodeURIComponent(this.model.minTotal)
        }
        if (this.model.maxTotal !== 0) {
          query += ' AND Total <= ' + encodeURIComponent(this.model.maxTotal)
        }
        if (this.model.status !== '_any') {
          query += ' AND Status = "' + encodeURIComponent(this.model.status) + '"'
        }
        if (this.model.paymentStatus !== '_any') {
          query += ' AND PaymentStatus = "' + encodeURIComponent(this.model.paymentStatus) + '"'
        }
        if (this.model.fulfillmentStatus !== '_any') {
          query += ' AND FulfillmentStatus = "' + encodeURIComponent(this.model.fulfillmentStatus) + '"'
        }
        if (this.model.preorder !== '_any') {
          query += ' AND Preorder = "' + encodeURIComponent(this.model.preorder) + '"'
        }
        if (this.model.confirmed !== '_any') {
          query += ' AND Confirmed = "' + encodeURIComponent(this.model.confirmed) + '"'
        }
        if (this.model.type !== '_any') {
          query += ' AND Type = "' + encodeURIComponent(this.model.type) + '"'
        }
        if (this.model.couponCodes) {
          query += ' AND CouponCodes = "' + encodeURIComponent(this.model.couponCodes) + '"'
        }
        if (this.model.productIds !== '_any') {
          query += ' AND ProductIds = "' + encodeURIComponent(this.model.productIds) + '"'
        }
        return query
      };
      return OrderFilterPane
    }(Pane);
    OrderFilterPane.register();
    module.exports = OrderFilterPane
  });
  // source: assets/js/dash/form/pane/pane.coffee
  rqzt.define('./form/pane/pane', function (module, exports, __dirname, __filename, process) {
    var Api, BasicForm, Events, FormView, Pane, _, crowdcontrol, input, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    BasicForm = rqzt('./form/basic');
    FormView = crowdcontrol.view.form.FormView;
    Api = crowdcontrol.data.Api;
    Pane = function (superClass) {
      extend(Pane, superClass);
      function Pane() {
        return Pane.__super__.constructor.apply(this, arguments)
      }
      Pane.prototype.tag = 'pane';
      Pane.prototype.path = '';
      Pane.prototype.html = BasicForm.prototype.html;
      Pane.prototype.events = BasicForm.prototype.events;
      Pane.prototype.reset = function () {
      };
      Pane.prototype.js = function (opts) {
        var api, ref;
        Pane.__super__.js.apply(this, arguments);
        this.tableObs = (ref = opts.tableobs) != null ? ref : this.obs;
        this.api = api = Api.get('crowdstart');
        return this.on('update', function (_this) {
          return function () {
            return setTimeout(function () {
              var $root;
              $root = $(_this.root);
              $root.children().attr('style', '');
              return requestAnimationFrame(function () {
                return $root.children().height($root.height())
              })
            }, 500)
          }
        }(this))
      };
      Pane.prototype.queryString = function () {
        return ''
      };
      Pane.prototype._submit = function (event) {
        var path;
        this.searching = true;
        this.update();
        path = this.path + '?q=' + this.queryString();
        if (window.User.owner) {
          path += '&limit=1000'
        }
        this.tableObs.trigger(Events.Table.PrepareForNewData);
        return this.api.get(path, this.model).then(function (_this) {
          return function (res) {
            var data, ref;
            _this.searching = false;
            _this.update();
            if (res.status !== 200) {
              throw new Error(res.responseText.error.message)
            }
            data = (ref = res.responseText) != null ? ref : [];
            return _this.tableObs.trigger(Events.Table.NewData, data)
          }
        }(this))['catch'](function (_this) {
          return function (e) {
            console.log(e.stack);
            return _this.error = e
          }
        }(this))
      };
      return Pane
    }(FormView);
    module.exports = Pane
  });
  // source: assets/js/dash/templates/dash/form/pane/order.html
  rqzt.define('./templates/dash/form/pane/order', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="tray tray-right tray290 p20">\n  <div class="admin-form">\n    <h4>Filter Orders</h4>\n    <hr class="short">\n    <h5><small>Date Range (MM/DD/YYYY)</small></h5>\n    <div class="section row">\n      <div class="col-md-6">\n        <control input="{ inputs.minDate }"></control>\n      </div>\n      <div class="col-md-6">\n        <control input="{ inputs.maxDate }"></control>\n      </div>\n    </div>\n    <h5><small>Products</small></h5>\n    <div class="section">\n      <control input="{ inputs.productIds }"></control>\n    </div>\n    <h5><small>Country</small></h5>\n    <div class="section">\n      <control input="{ inputs.country }" any="{ true }"></control>\n    </div>\n    <h5><small>Sales Amount</small></h5>\n    <div class="section">\n      <control input="{ inputs.currency }" any="{ true }"></control>\n    </div>\n    <div class="section row">\n      <div class="col-md-6">\n        <control input="{ inputs.minTotal }"></control>\n      </div>\n      <div class="col-md-6">\n        <control input="{ inputs.maxTotal }"></control>\n      </div>\n    </div>\n    <h5><small>Coupon</small></h5>\n    <div class="section">\n      <control input="{ inputs.couponCodes }"></control>\n    </div>\n    <h5><small>Payment Processor</small></h5>\n    <div class="section">\n      <control input="{ inputs.type }" options="{ typeOptions }"></control>\n    </div>\n    <h5><small>Status</small></h5>\n    <div class="section">\n      <control input="{ inputs.status }" options="{ statusOptions }"></control>\n    </div>\n    <div class="section">\n      <control input="{ inputs.paymentStatus }" options="{ paymentStatusOptions }"></control>\n    </div>\n    <div class="section">\n      <control input="{ inputs.fulfillmentStatus }" options="{ fulfillmentStatusOptions }"></control>\n    </div>\n    <div class="section">\n      <control input="{ inputs.preorder }" options="{ preorderOptions }"></control>\n    </div>\n    <div class="section">\n      <control input="{ inputs.confirmed }" options="{ confirmedOptions }"></control>\n    </div>\n    <hr class="short">\n    <div class="section">\n      <button class="btn btn-default btn-block btn-sm ph25" type="button" onclick="{ submit }" __disabled="{ searching }">{ searching ? \'Searching...\' : \'Search\' }</button>\n    </div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/form/pane/user.coffee
  rqzt.define('./form/pane/user', function (module, exports, __dirname, __filename, process) {
    var Events, Pane, UserFilterPane, _, crowdcontrol, input, localizeDate, moment, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    moment = rqzt('moment/moment');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    input = rqzt('./form/input');
    Pane = rqzt('./form/pane/pane');
    localizeDate = function (date) {
      var ref, ref1, ref2, tokens;
      tokens = date.split('/');
      return moment(((ref = tokens[2]) != null ? ref : '2015') + ' ' + ((ref1 = tokens[0]) != null ? ref1 : '01') + ' ' + ((ref2 = tokens[1]) != null ? ref2 : '01'), 'YYYY-MM-DD').format('YYYY-MM-DD')
    };
    UserFilterPane = function (superClass) {
      extend(UserFilterPane, superClass);
      function UserFilterPane() {
        return UserFilterPane.__super__.constructor.apply(this, arguments)
      }
      UserFilterPane.prototype.tag = 'user-filter-pane';
      UserFilterPane.prototype.html = rqzt('./templates/dash/form/pane/user');
      UserFilterPane.prototype.path = 'search/user';
      UserFilterPane.prototype.inputConfigs = [
        input('email', 'Email'),
        input('firstName', 'First Name'),
        input('lastName', 'Last Name'),
        input('line1', 'Street Address'),
        input('line2', 'Apartment/Suite'),
        input('city', 'City'),
        input('state', 'State'),
        input('postal', 'Postal/ZIP'),
        input('minDate', '', 'date-picker'),
        input('maxDate', '', 'date-picker'),
        input('country', '', 'country-select')
      ];
      UserFilterPane.prototype.js = function () {
        this.model = {
          email: '',
          firstName: '',
          lastName: '',
          line1: '',
          line2: '',
          city: '',
          state: '',
          postal: '',
          country: '_any',
          minDate: '01/01/2015',
          maxDate: moment().format('L')
        };
        return UserFilterPane.__super__.js.apply(this, arguments)
      };
      UserFilterPane.prototype.queryString = function () {
        var maxDate, maxDateStr, minDate, minDateStr, query, swap;
        minDate = localizeDate(this.model.minDate);
        maxDate = localizeDate(this.model.maxDate);
        if (moment(minDate, 'YYYY-MM-DD').isAfter(moment(maxDate, 'YYYY-MM-DD'))) {
          swap = maxDate;
          maxDate = minDate;
          minDate = swap2
        }
        riot.update();
        minDateStr = moment(minDate, 'YYYY-MM-DD').format('YYYY-MM-DD');
        maxDateStr = moment(maxDate, 'YYYY-MM-DD').format('YYYY-MM-DD');
        query = 'CreatedAt >= ' + encodeURIComponent(minDateStr) + ' AND CreatedAt <= ' + encodeURIComponent(maxDateStr);
        if (this.model.email) {
          query += ' AND Email = "' + encodeURIComponent(this.model.email) + '"'
        }
        if (this.model.firstName) {
          query += ' AND FirstName = "' + encodeURIComponent(this.model.firstName) + '"'
        }
        if (this.model.lastName) {
          query += ' AND LastName = "' + encodeURIComponent(this.model.lastName) + '"'
        }
        if (this.model.line1) {
          query += ' AND ShippingAddressLine1 = "' + encodeURIComponent(this.model.line1) + '"'
        }
        if (this.model.line2) {
          query += ' AND ShippingAddressLine2 = "' + encodeURIComponent(this.model.line2) + '"'
        }
        if (this.model.city) {
          query += ' AND ShippingAddressCity = "' + encodeURIComponent(this.model.city) + '"'
        }
        if (this.model.state) {
          query += ' AND ShippingAddressState = "' + encodeURIComponent(this.model.state) + '"'
        }
        if (this.model.postal) {
          query += ' AND ShippingAddressPostalCode = "' + encodeURIComponent(this.model.postal) + '"'
        }
        if (this.model.country !== '_any') {
          query += ' AND ShippingAddressCountryCode = "' + encodeURIComponent(this.model.country) + '"'
        }
        return query
      };
      return UserFilterPane
    }(Pane);
    UserFilterPane.register();
    module.exports = UserFilterPane
  });
  // source: assets/js/dash/templates/dash/form/pane/user.html
  rqzt.define('./templates/dash/form/pane/user', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="tray tray-right tray290 p20">\n  <div class="admin-form">\n    <h4>Filter Users</h4>\n    <hr class="short">\n    <h5><small>Date Range (MM/DD/YYYY)</small></h5>\n    <div class="section row">\n      <div class="col-md-6">\n        <control input="{ inputs.minDate }"></control>\n      </div>\n      <div class="col-md-6">\n        <control input="{ inputs.maxDate }"></control>\n      </div>\n    </div>\n    <h5><small>Contact</small></h5>\n    <div class="section">\n      <control input="{ inputs.email }"></control>\n    </div>\n    <div class="section">\n      <control input="{ inputs.firstName }"></control>\n    </div>\n    <div class="section">\n      <control input="{ inputs.lastName }"></control>\n    </div>\n    <h5><small>Address</small></h5>\n    <div class="section">\n      <control input="{ inputs.line1 }"></control>\n    </div>\n    <div class="section">\n      <control input="{ inputs.line2 }"></control>\n    </div>\n    <div class="section">\n      <control input="{ inputs.city }"></control>\n    </div>\n    <div class="section row">\n      <div class="col-md-6">\n        <control input="{ inputs.state }"></control>\n      </div>\n      <div class="col-md-6">\n        <control input="{ inputs.postal }"></control>\n      </div>\n    </div>\n    <div class="section">\n      <control input="{ inputs.country }" any="true"></control>\n    </div>\n    <hr class="short">\n    <div class="section">\n      <button class="btn btn-default btn-block btn-sm ph25" type="button" onclick="{ submit }" __disabled="{ searching }">{ searching ? \'Searching...\' : \'Search\' }</button>\n    </div>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/widget/index.coffee
  rqzt.define('./widget', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      VariantOptions: rqzt('./widget/variant-options'),
      Balance: rqzt('./widget/balance'),
      Spinner: rqzt('./widget/spinner'),
      Search: rqzt('./widget/search'),
      Gmap: rqzt('./widget/gmap'),
      Listing: rqzt('./widget/listing'),
      DnD: rqzt('./widget/dnd')
    }
  });
  // source: assets/js/dash/widget/variant-options/index.coffee
  rqzt.define('./widget/variant-options', function (module, exports, __dirname, __filename, process) {
    var Events, VariantOptionsEditor, View, crowdcontrol, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    View = crowdcontrol.view.View;
    VariantOptionsEditor = function (superClass) {
      var obj;
      extend(VariantOptionsEditor, superClass);
      function VariantOptionsEditor() {
        return VariantOptionsEditor.__super__.constructor.apply(this, arguments)
      }
      VariantOptionsEditor.prototype.tag = 'variant-options';
      VariantOptionsEditor.prototype.html = rqzt('./widget/variant-options/template');
      VariantOptionsEditor.prototype.events = (obj = {}, obj['' + Events.Form.Load] = function (model) {
        var i, j, len, option, ref;
        this.formModel = model;
        this.model = model.options;
        if (!this.model) {
          this.model = model.options = []
        }
        ref = this.model;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          option = ref[i];
          option.i = i
        }
        return this.update()
      }, obj);
      VariantOptionsEditor.prototype.addOption = function () {
        return this.model.push({
          i: this.model.length,
          name: '',
          values: ''
        })
      };
      VariantOptionsEditor.prototype.changeOption = function (i) {
        return function (_this) {
          return function (event) {
            return _this.model[i].name = $(event.target).val()
          }
        }(this)
      };
      VariantOptionsEditor.prototype.changeOptionValues = function (i, $input) {
        return this.model[i].values = $input.val().split(',')
      };
      VariantOptionsEditor.prototype.deleteOption = function (i) {
        return function (_this) {
          return function () {
            var j, len, option, ref, results;
            _this.model.splice(i, 1);
            ref = _this.model;
            results = [];
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              option = ref[i];
              results.push(option.i = i)
            }
            return results
          }
        }(this)
      };
      VariantOptionsEditor.prototype.js = function () {
        return this.on('update', function (_this) {
          return function () {
            return setTimeout(function () {
              var $tagsInput;
              return $tagsInput = $(_this.root).find('.input-tags').each(function (i, el) {
                var $el, option;
                $el = $(el);
                if ($el.parent().children('.tagsinput')[0] == null) {
                  option = _this.model[i];
                  return $el.tagsInput({
                    width: 'auto',
                    height: 'auto',
                    defaultText: '+',
                    onChange: function (input) {
                      return _this.changeOptionValues(option.i, $(input))
                    }
                  })
                }
              })
            }, 500)
          }
        }(this))
      };
      return VariantOptionsEditor
    }(View);
    VariantOptionsEditor.register()
  });
  // source: assets/js/dash/widget/variant-options/template.html
  rqzt.define('./widget/variant-options/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="row">\n  <h5 class="col-xs-offset-1 col-xs-3 variant-option-header">\n    Option Name\n  </h5>\n  <h5 class="col-xs-7">\n    Possible Values\n  </h5>\n  <h5 class="col-xs-1 variant-option-header">\n    Delete\n  </h5>\n</div>\n<div class="form-group animated fadeInUp" each="{ model }">\n  <label for="{ name }" class="control-label col-xs-offset-1 col-xs-3 variant-option">\n    <input id="{ name + \'_name\' }" name="{ name + \'_name\' }" class="form-control" type="text" onchange="{ this.parent.changeOption(i) }"  onblur="{ this.parent.changeOption(i) }" value="{ name }">\n  </label>\n  <div class="col-xs-7">\n    <input id="{ name }" name="{ name }" class="form-control input-tags" type="text" value="{ values.join(\',\') }">\n  </div>\n  <div class="col-xs-1">\n    <button class="btn btn-xs btn-danger" style="margin-top:5px" onclick="{ this.parent.deleteOption(i) }">x</button>\n  </div>\n</div>\n<div class="form-group click-for-new" onclick="{ addOption }">\n  <div class="control-label col-xs-offset-1 col-xs-3 variant-option">\n    <input class="form-control" type="text" placeholder="Click to add a option" disabled>\n  </div>\n  <div class="col-xs-7">\n    <input class="form-control" type="text" placeholder="Click here to add a new option" disabled>\n  </div>\n  <div class="col-xs-1">\n    <span class="btn btn-xs btn-danger btn-disabled" style="margin-top:5px">x</span>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/widget/balance/index.coffee
  rqzt.define('./widget/balance', function (module, exports, __dirname, __filename, process) {
    var Api, BalanceWidget, BalanceWidgetFormView, BasicTableView, Events, FormView, View, _, crowdcontrol, field, input, m, moment, table, util, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    moment = rqzt('moment/moment');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    util = rqzt('./util');
    table = rqzt('./table');
    field = table.field;
    input = rqzt('./form/input');
    Api = crowdcontrol.data.Api;
    View = crowdcontrol.view.View;
    BasicTableView = table.BasicTableView;
    FormView = crowdcontrol.view.form.FormView;
    m = crowdcontrol.utils.mediator;
    BalanceWidgetFormView = function (superClass) {
      extend(BalanceWidgetFormView, superClass);
      function BalanceWidgetFormView() {
        return BalanceWidgetFormView.__super__.constructor.apply(this, arguments)
      }
      BalanceWidgetFormView.prototype.tag = 'balance-widget-form';
      BalanceWidgetFormView.prototype.path = 'transaction';
      BalanceWidgetFormView.prototype.html = rqzt('./templates/dash/widget/balance/balance-form');
      BalanceWidgetFormView.prototype.inputConfigs = [
        input('type', '', 'required basic-select'),
        input('amount', 'ex 100', 'required money'),
        input('currency', '', 'currency-type-select')
      ];
      BalanceWidgetFormView.prototype.js = function (opts) {
        var api;
        BalanceWidgetFormView.__super__.js.apply(this, arguments);
        return this.api = api = Api.get('crowdstart')
      };
      BalanceWidgetFormView.prototype._submit = function () {
        return this.api.post(this.path, this.model).then(function (_this) {
          return function () {
            return setTimeout(function () {
              return _this.obs.trigger('refresh')
            }, 500)
          }
        }(this))
      };
      return BalanceWidgetFormView
    }(FormView);
    BalanceWidgetFormView.register();
    BalanceWidget = function (superClass) {
      extend(BalanceWidget, superClass);
      function BalanceWidget() {
        return BalanceWidget.__super__.constructor.apply(this, arguments)
      }
      BalanceWidget.prototype.tag = 'balance-widget';
      BalanceWidget.prototype.html = rqzt('./templates/dash/widget/balance/template');
      BalanceWidget.prototype.currencyOptions = {};
      BalanceWidget.prototype.isEmpty = true;
      BalanceWidget.prototype.formModel = {
        userId: '',
        type: 'deposit',
        amount: 0,
        currency: 'points'
      };
      BalanceWidget.prototype.accountingOptions = {
        deposit: 'Add(+)',
        withdraw: 'Subtract(-)'
      };
      BalanceWidget.prototype.tableHeaders = [
        field('type', 'Type'),
        field('amount', 'Amount', 'money'),
        field('description', 'Description'),
        field('createdAt', 'Created', 'date')
      ];
      BalanceWidget.prototype.events = {
        refresh: function () {
          m.trigger('start-spin', 'balance-form-load');
          this.api.get(this.path).then(function (_this) {
            return function (res) {
              m.trigger('stop-spin', 'balance-form-load');
              return _this.updateModel(res.responseText)
            }
          }(this));
          return this.update()
        }
      };
      BalanceWidget.prototype.updateModel = function (model) {
        var currency, i, len, newModel, row, transactions;
        if (!_.isArray(model) || model.length === 0) {
          this.isEmpty = true;
          return
        }
        this.isEmpty = false;
        model.sort(function (a, b) {
          if (moment(a.createdAt).isBefore(b.createdAt)) {
            return 1
          }
          return -1
        });
        this.currency = currency = model[0].currency;
        this.currencyOptions = {};
        newModel = {};
        for (i = 0, len = model.length; i < len; i++) {
          row = model[i];
          transactions = newModel[row.currency];
          if (!transactions) {
            transactions = newModel[row.currency] = []
          }
          transactions.push(row);
          this.currencyOptions[row.currency] = row.currency
        }
        this.model = newModel;
        this.obs.trigger(Events.Table.NewData, newModel[currency]);
        return this.update()
      };
      BalanceWidget.prototype.change = function (event) {
        var currency;
        currency = $(event.target).val();
        if (this.currency !== currency) {
          this.currency = currency;
          this.obs.trigger(Events.Table.NewData, this.model[this.currency]);
          return this.update()
        }
      };
      BalanceWidget.prototype.balance = function () {
        var amount, i, len, transaction, transactions;
        transactions = this.model[this.currency];
        amount = 0;
        for (i = 0, len = transactions.length; i < len; i++) {
          transaction = transactions[i];
          amount += transaction.type === 'deposit' ? transaction.amount : -transaction.amount
        }
        return util.currency.renderUICurrencyFromJSON(this.currency, amount)
      };
      BalanceWidget.prototype.js = function (opts) {
        var userId;
        userId = opts.userId = opts.userId || opts.userid;
        this.path = 'user/' + userId + '/transactions';
        this.api = Api.get('crowdstart');
        this.obs.trigger('refresh');
        this.formModel.userId = userId;
        return this.on('update', function (_this) {
          return function () {
            var $select;
            $select = $(_this.root).find('#balance-currency-select');
            if ($select[0] != null) {
              if (!_this.initialized) {
                $select.select2({ minimumResultsForSearch: 10 }).change(function (event) {
                  return _this.change(event)
                });
                return _this.initialized = true
              } else {
                return setTimeout(function () {
                  return $select.select2('val', _this.currency)
                }, 500)
              }
            }
          }
        }(this))
      };
      return BalanceWidget
    }(View);
    BalanceWidget.register()
  });
  // source: assets/js/dash/templates/dash/widget/balance/balance-form.html
  rqzt.define('./templates/dash/widget/balance/balance-form', function (module, exports, __dirname, __filename, process) {
    module.exports = '<form onsubmit="{ submit }">\n  <div class="section col-xs-12 mb20" style="padding:0">\n    <control label="Do you want to add or subtract credit?" input="{inputs.type}" options="{ opts.accountingoptions }" labelclasses="col-md-6" controlclasses="col-md-6"></control>\n  </div>\n  <div class="section col-xs-12 mb20" style="padding:0">\n    <control label="How much credit do you want to issue?" input="{inputs.amount}" labelclasses="col-md-6" controlclasses="col-md-6"></control>\n  </div>\n  <div class="section col-xs-12 mb20" style="padding:0">\n    <control label="What currency is the credit in?" input="{inputs.currency}" labelclasses="col-md-6" controlclasses="col-md-6"></control>\n  </div>\n  <div class="form-actions text-center section">\n    <button type="button" class="btn btn-dark" onclick="{ submit }">Add Transaction</button>\n  </div>\n</form>\n'
  });
  // source: assets/js/dash/templates/dash/widget/balance/template.html
  rqzt.define('./templates/dash/widget/balance/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div>\n  <div class="form-group" if="{ !isEmpty }">\n    <div class="col-xs-6">\n      <label for="balance-currency-select" class="control-label" style="float:left;text-align:left;">Currency</label>\n      <div class="col-xs-6">\n        <select id="balance-currency-select">\n          <option each="{ value, name in currencyOptions }" value="{ value }" __selected="{ parent.currency == value }">{ window.currencies[value] }</option>\n        </select>\n      </div>\n    </div>\n    <div class="col-xs-6 form-control-static" style="text-align:right">\n      <label class="control-label pn">\n        Total:\n      </label>\n      { balance() }\n    </div>\n  </div>\n  <basic-table class="{table-viewport: !isEmpty, mb20: true}" headers="{ tableHeaders }" obs="{ obs }">\n    No Transactions Found\n  </basic-table>\n  <balance-widget-form model="{ formModel }" accountingoptions="{ accountingOptions }" obs="{ obs }">\n  </balance-widget-form>\n</div>\n'
  });
  // source: assets/js/dash/widget/spinner/index.coffee
  rqzt.define('./widget/spinner', function (module, exports, __dirname, __filename, process) {
    var ModalSpinner, View, crowdcontrol, m, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    View = crowdcontrol.view.View;
    m = crowdcontrol.utils.mediator;
    ModalSpinner = function (superClass) {
      extend(ModalSpinner, superClass);
      function ModalSpinner() {
        return ModalSpinner.__super__.constructor.apply(this, arguments)
      }
      ModalSpinner.prototype.tag = 'modal-spinner';
      ModalSpinner.prototype.html = '<div class="{ animated: true, fadeIn: isActive(), fadeOut: !isActive(), hide: hide }"><div class="loader"></div></div>';
      ModalSpinner.prototype.js = function () {
        var hideId;
        this.active = {};
        this.hide = true;
        hideId = 0;
        m.on('start-spin', function (_this) {
          return function (name) {
            if (name == null) {
              name = ''
            }
            _this.hide = false;
            clearTimeout(hideId);
            _this.active[name] = true;
            return _this.update()
          }
        }(this));
        return m.on('stop-spin', function (_this) {
          return function (name) {
            if (name == null) {
              name = ''
            }
            clearTimeout(hideId);
            hideId = setTimeout(function () {
              _this.hide = true;
              return _this.update()
            }, 1000);
            _this.active[name] = false;
            return _this.update()
          }
        }(this))
      };
      ModalSpinner.prototype.isActive = function () {
        var active, name, ref;
        if (this.active != null) {
          ref = this.active;
          for (name in ref) {
            active = ref[name];
            if (active) {
              return true
            }
          }
        }
        return false
      };
      return ModalSpinner
    }(View);
    ModalSpinner.register()
  });
  // source: assets/js/dash/widget/search/index.coffee
  rqzt.define('./widget/search', function (module, exports, __dirname, __filename, process) {
    var Api, Events, Search, View, crowdcontrol, utils, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    rqzt('./table');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    utils = crowdcontrol.utils;
    View = crowdcontrol.view.View;
    Api = crowdcontrol.data.Api;
    Search = function (superClass) {
      extend(Search, superClass);
      function Search() {
        return Search.__super__.constructor.apply(this, arguments)
      }
      Search.prototype.tag = 'search-widget';
      Search.prototype.html = rqzt('./templates/dash/widget/search/template');
      Search.prototype.js = function (opts) {
        var api, q;
        Search.__super__.js.apply(this, arguments);
        this.userObs = {};
        utils.shim.observable(this.userObs);
        this.orderObs = {};
        utils.shim.observable(this.orderObs);
        this.api = api = Api.get('dash');
        q = window.location.search;
        if (!window.User.owner) {
          q += '&limit=1000'
        }
        requestAnimationFrame(function (_this) {
          return function () {
            _this.userObs.trigger(Events.Table.StartSearch);
            _this.orderObs.trigger(Events.Table.StartSearch);
            return riot.update()
          }
        }(this));
        return api.get('search' + q).then(function (_this) {
          return function (res) {
            var model;
            if (res.status !== 200 && res.status !== 204) {
              throw new Error('Form failed to load: ')
            }
            _this.model = model = res.responseText;
            _this.userObs.trigger(Events.Table.NewData, model.users);
            _this.orderObs.trigger(Events.Table.NewData, model.orders);
            _this.userObs.trigger(Events.Table.EndSearch);
            _this.orderObs.trigger(Events.Table.EndSearch);
            return riot.update()
          }
        }(this))['catch'](function (e) {
          return console.log(e.stack)
        })
      };
      return Search
    }(View);
    Search.register();
    module.exports = Search
  });
  // source: assets/js/dash/templates/dash/widget/search/template.html
  rqzt.define('./templates/dash/widget/search/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<yield></yield>\n'
  });
  // source: assets/js/dash/widget/gmap/index.coffee
  rqzt.define('./widget/gmap', function (module, exports, __dirname, __filename, process) {
    var Events, Gmap, View, crowdcontrol, gmapsLoaded, needsRefresh, riot, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    riot = rqzt('riot/riot');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    View = crowdcontrol.view.View;
    gmapsLoaded = false;
    needsRefresh = [];
    window.gmapsInit = function () {
      var fn, i, len, results1;
      gmapsLoaded = true;
      results1 = [];
      for (i = 0, len = needsRefresh.length; i < len; i++) {
        fn = needsRefresh[i];
        results1.push(fn())
      }
      return results1
    };
    Gmap = function (superClass) {
      var obj;
      extend(Gmap, superClass);
      function Gmap() {
        return Gmap.__super__.constructor.apply(this, arguments)
      }
      Gmap.prototype.tag = 'gmap';
      Gmap.prototype.addressField = 'address';
      Gmap.prototype.events = (obj = {}, obj['' + Events.Input.Set] = function (name) {
        if (name === this.addressField + '.line1' || name === this.addressField + '.line2' || name === this.addressField + '.city' || name === this.addressField + '.state' || name === this.addressField + '.postalCode' || name === this.addressField + '.country') {
          return this.refresh()
        }
      }, obj['' + Events.Form.Prefill] = function (model) {
        this.model = model;
        return this.refresh()
      }, obj);
      Gmap.prototype.refresh = function () {
        var GMaps, address, city, country, line1, line2, postalCode, ref, ref1, ref2, ref3, ref4, ref5, ref6, state;
        if (!gmapsLoaded) {
          return
        }
        GMaps = rqzt('gmaps/gmaps');
        if (((ref = this.model) != null ? ref[this.addressField] : void 0) != null) {
          line1 = (ref1 = this.model[this.addressField].line1) != null ? ref1 : '';
          line2 = (ref2 = this.model[this.addressField].line2) != null ? ref2 : '';
          city = (ref3 = this.model[this.addressField].city) != null ? ref3 : '';
          state = (ref4 = this.model[this.addressField].state) != null ? ref4 : '';
          postalCode = (ref5 = this.model[this.addressField].postalCode) != null ? ref5 : '';
          country = (ref6 = this.model[this.addressField].country) != null ? ref6 : '';
          address = line1 + ' ' + line2 + ' ' + city + ' ' + state + ' ' + postalCode + ' ' + country
        }
        if (address !== this.lastAddress) {
          this.lastAddress = address;
          return GMaps.geocode({
            address: address,
            callback: function (_this) {
              return function (results, status) {
                var latlng;
                if (status === 'OK') {
                  if (_this.map == null) {
                    _this.map = new GMaps({
                      div: _this.root,
                      lat: 21.3280681,
                      lng: -157.798970564,
                      zoom: 12
                    })
                  }
                  latlng = results[0].geometry.location;
                  _this.map.removeMarkers();
                  _this.map.setCenter(latlng.lat(), latlng.lng());
                  return _this.map.addMarker({
                    lat: latlng.lat(),
                    lng: latlng.lng()
                  })
                }
              }
            }(this)
          })
        }
      };
      Gmap.prototype.js = function (opts) {
        var ref;
        Gmap.__super__.js.call(this);
        this.addressField = (ref = opts.addressfield) != null ? ref : this.addressField;
        $(this.root).addClass('map');
        this.on('update', function (_this) {
          return function () {
            return _this.refresh()
          }
        }(this));
        return needsRefresh.push(function (_this) {
          return function () {
            if (!gmapsLoaded) {
              return _this.refresh()
            }
          }
        }(this))
      };
      return Gmap
    }(View);
    Gmap.register();
    module.exports = Gmap
  });
  // source: node_modules/gmaps/gmaps.js
  rqzt.define('gmaps/gmaps', function (module, exports, __dirname, __filename, process) {
    'use strict';
    (function (root, factory) {
      if (typeof exports === 'object') {
        module.exports = factory()
      } else if (typeof define === 'function' && define.amd) {
        define([
          'jquery',
          'googlemaps!'
        ], factory)
      } else {
        root.GMaps = factory()
      }
    }(this, function () {
      /*!
 * GMaps.js v0.4.24
 * http://hpneo.github.com/gmaps/
 *
 * Copyright 2016, Gustavo Leon
 * Released under the MIT License.
 */
      var extend_object = function (obj, new_obj) {
        var name;
        if (obj === new_obj) {
          return obj
        }
        for (name in new_obj) {
          if (new_obj[name] !== undefined) {
            obj[name] = new_obj[name]
          }
        }
        return obj
      };
      var replace_object = function (obj, replace) {
        var name;
        if (obj === replace) {
          return obj
        }
        for (name in replace) {
          if (obj[name] != undefined) {
            obj[name] = replace[name]
          }
        }
        return obj
      };
      var array_map = function (array, callback) {
        var original_callback_params = Array.prototype.slice.call(arguments, 2), array_return = [], array_length = array.length, i;
        if (Array.prototype.map && array.map === Array.prototype.map) {
          array_return = Array.prototype.map.call(array, function (item) {
            var callback_params = original_callback_params.slice(0);
            callback_params.splice(0, 0, item);
            return callback.apply(this, callback_params)
          })
        } else {
          for (i = 0; i < array_length; i++) {
            callback_params = original_callback_params;
            callback_params.splice(0, 0, array[i]);
            array_return.push(callback.apply(this, callback_params))
          }
        }
        return array_return
      };
      var array_flat = function (array) {
        var new_array = [], i;
        for (i = 0; i < array.length; i++) {
          new_array = new_array.concat(array[i])
        }
        return new_array
      };
      var coordsToLatLngs = function (coords, useGeoJSON) {
        var first_coord = coords[0], second_coord = coords[1];
        if (useGeoJSON) {
          first_coord = coords[1];
          second_coord = coords[0]
        }
        return new google.maps.LatLng(first_coord, second_coord)
      };
      var arrayToLatLng = function (coords, useGeoJSON) {
        var i;
        for (i = 0; i < coords.length; i++) {
          if (!(coords[i] instanceof google.maps.LatLng)) {
            if (coords[i].length > 0 && typeof coords[i][0] === 'object') {
              coords[i] = arrayToLatLng(coords[i], useGeoJSON)
            } else {
              coords[i] = coordsToLatLngs(coords[i], useGeoJSON)
            }
          }
        }
        return coords
      };
      var getElementsByClassName = function (class_name, context) {
        var element, _class = class_name.replace('.', '');
        if ('jQuery' in this && context) {
          element = $('.' + _class, context)[0]
        } else {
          element = document.getElementsByClassName(_class)[0]
        }
        return element
      };
      var getElementById = function (id, context) {
        var element, id = id.replace('#', '');
        if ('jQuery' in window && context) {
          element = $('#' + id, context)[0]
        } else {
          element = document.getElementById(id)
        }
        ;
        return element
      };
      var findAbsolutePosition = function (obj) {
        var curleft = 0, curtop = 0;
        if (obj.offsetParent) {
          do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop
          } while (obj = obj.offsetParent)
        }
        return [
          curleft,
          curtop
        ]
      };
      var GMaps = function (global) {
        'use strict';
        var doc = document;
        /**
   * Creates a new GMaps instance, including a Google Maps map.
   * @class GMaps
   * @constructs
   * @param {object} options - `options` accepts all the [MapOptions](https://developers.google.com/maps/documentation/javascript/reference#MapOptions) and [events](https://developers.google.com/maps/documentation/javascript/reference#Map) listed in the Google Maps API. Also accepts:
   * * `lat` (number): Latitude of the map's center
   * * `lng` (number): Longitude of the map's center
   * * `el` (string or HTMLElement): container where the map will be rendered
   * * `markerClusterer` (function): A function to create a marker cluster. You can use MarkerClusterer or MarkerClustererPlus.
   */
        var GMaps = function (options) {
          if (!(typeof window.google === 'object' && window.google.maps)) {
            if (typeof window.console === 'object' && window.console.error) {
              console.error('Google Maps API is required. Please register the following JavaScript library https://maps.googleapis.com/maps/api/js.')
            }
            return function () {
            }
          }
          if (!this)
            return new GMaps(options);
          options.zoom = options.zoom || 15;
          options.mapType = options.mapType || 'roadmap';
          var valueOrDefault = function (value, defaultValue) {
            return value === undefined ? defaultValue : value
          };
          var self = this, i, events_that_hide_context_menu = [
              'bounds_changed',
              'center_changed',
              'click',
              'dblclick',
              'drag',
              'dragend',
              'dragstart',
              'idle',
              'maptypeid_changed',
              'projection_changed',
              'resize',
              'tilesloaded',
              'zoom_changed'
            ], events_that_doesnt_hide_context_menu = [
              'mousemove',
              'mouseout',
              'mouseover'
            ], options_to_be_deleted = [
              'el',
              'lat',
              'lng',
              'mapType',
              'width',
              'height',
              'markerClusterer',
              'enableNewStyle'
            ], identifier = options.el || options.div, markerClustererFunction = options.markerClusterer, mapType = google.maps.MapTypeId[options.mapType.toUpperCase()], map_center = new google.maps.LatLng(options.lat, options.lng), zoomControl = valueOrDefault(options.zoomControl, true), zoomControlOpt = options.zoomControlOpt || {
              style: 'DEFAULT',
              position: 'TOP_LEFT'
            }, zoomControlStyle = zoomControlOpt.style || 'DEFAULT', zoomControlPosition = zoomControlOpt.position || 'TOP_LEFT', panControl = valueOrDefault(options.panControl, true), mapTypeControl = valueOrDefault(options.mapTypeControl, true), scaleControl = valueOrDefault(options.scaleControl, true), streetViewControl = valueOrDefault(options.streetViewControl, true), overviewMapControl = valueOrDefault(overviewMapControl, true), map_options = {}, map_base_options = {
              zoom: this.zoom,
              center: map_center,
              mapTypeId: mapType
            }, map_controls_options = {
              panControl: panControl,
              zoomControl: zoomControl,
              zoomControlOptions: {
                style: google.maps.ZoomControlStyle[zoomControlStyle],
                position: google.maps.ControlPosition[zoomControlPosition]
              },
              mapTypeControl: mapTypeControl,
              scaleControl: scaleControl,
              streetViewControl: streetViewControl,
              overviewMapControl: overviewMapControl
            };
          if (typeof options.el === 'string' || typeof options.div === 'string') {
            if (identifier.indexOf('#') > -1) {
              /**
             * Container element
             *
             * @type {HTMLElement}
             */
              this.el = getElementById(identifier, options.context)
            } else {
              this.el = getElementsByClassName.apply(this, [
                identifier,
                options.context
              ])
            }
          } else {
            this.el = identifier
          }
          if (typeof this.el === 'undefined' || this.el === null) {
            throw 'No element defined.'
          }
          window.context_menu = window.context_menu || {};
          window.context_menu[self.el.id] = {};
          /**
     * Collection of custom controls in the map UI
     *
     * @type {array}
     */
          this.controls = [];
          /**
     * Collection of map's overlays
     *
     * @type {array}
     */
          this.overlays = [];
          /**
     * Collection of KML/GeoRSS and FusionTable layers
     *
     * @type {array}
     */
          this.layers = [];
          /**
     * Collection of data layers (See {@link GMaps#addLayer})
     *
     * @type {object}
     */
          this.singleLayers = {};
          /**
     * Collection of map's markers
     *
     * @type {array}
     */
          this.markers = [];
          /**
     * Collection of map's lines
     *
     * @type {array}
     */
          this.polylines = [];
          /**
     * Collection of map's routes requested by {@link GMaps#getRoutes}, {@link GMaps#renderRoute}, {@link GMaps#drawRoute}, {@link GMaps#travelRoute} or {@link GMaps#drawSteppedRoute}
     *
     * @type {array}
     */
          this.routes = [];
          /**
     * Collection of map's polygons
     *
     * @type {array}
     */
          this.polygons = [];
          this.infoWindow = null;
          this.overlay_el = null;
          /**
     * Current map's zoom
     *
     * @type {number}
     */
          this.zoom = options.zoom;
          this.registered_events = {};
          this.el.style.width = options.width || this.el.scrollWidth || this.el.offsetWidth;
          this.el.style.height = options.height || this.el.scrollHeight || this.el.offsetHeight;
          google.maps.visualRefresh = options.enableNewStyle;
          for (i = 0; i < options_to_be_deleted.length; i++) {
            delete options[options_to_be_deleted[i]]
          }
          if (options.disableDefaultUI != true) {
            map_base_options = extend_object(map_base_options, map_controls_options)
          }
          map_options = extend_object(map_base_options, options);
          for (i = 0; i < events_that_hide_context_menu.length; i++) {
            delete map_options[events_that_hide_context_menu[i]]
          }
          for (i = 0; i < events_that_doesnt_hide_context_menu.length; i++) {
            delete map_options[events_that_doesnt_hide_context_menu[i]]
          }
          /**
     * Google Maps map instance
     *
     * @type {google.maps.Map}
     */
          this.map = new google.maps.Map(this.el, map_options);
          if (markerClustererFunction) {
            /**
       * Marker Clusterer instance
       *
       * @type {object}
       */
            this.markerClusterer = markerClustererFunction.apply(this, [this.map])
          }
          var buildContextMenuHTML = function (control, e) {
            var html = '', options = window.context_menu[self.el.id][control];
            for (var i in options) {
              if (options.hasOwnProperty(i)) {
                var option = options[i];
                html += '<li><a id="' + control + '_' + i + '" href="#">' + option.title + '</a></li>'
              }
            }
            if (!getElementById('gmaps_context_menu'))
              return;
            var context_menu_element = getElementById('gmaps_context_menu');
            context_menu_element.innerHTML = html;
            var context_menu_items = context_menu_element.getElementsByTagName('a'), context_menu_items_count = context_menu_items.length, i;
            for (i = 0; i < context_menu_items_count; i++) {
              var context_menu_item = context_menu_items[i];
              var assign_menu_item_action = function (ev) {
                ev.preventDefault();
                options[this.id.replace(control + '_', '')].action.apply(self, [e]);
                self.hideContextMenu()
              };
              google.maps.event.clearListeners(context_menu_item, 'click');
              google.maps.event.addDomListenerOnce(context_menu_item, 'click', assign_menu_item_action, false)
            }
            var position = findAbsolutePosition.apply(this, [self.el]), left = position[0] + e.pixel.x - 15, top = position[1] + e.pixel.y - 15;
            context_menu_element.style.left = left + 'px';
            context_menu_element.style.top = top + 'px'  // context_menu_element.style.display = 'block';
          };
          this.buildContextMenu = function (control, e) {
            if (control === 'marker') {
              e.pixel = {};
              var overlay = new google.maps.OverlayView;
              overlay.setMap(self.map);
              overlay.draw = function () {
                var projection = overlay.getProjection(), position = e.marker.getPosition();
                e.pixel = projection.fromLatLngToContainerPixel(position);
                buildContextMenuHTML(control, e)
              }
            } else {
              buildContextMenuHTML(control, e)
            }
            var context_menu_element = getElementById('gmaps_context_menu');
            setTimeout(function () {
              context_menu_element.style.display = 'block'
            }, 0)
          };
          /**
     * Add a context menu for a map or a marker.
     *
     * @param {object} options - The `options` object should contain:
     * * `control` (string): Kind of control the context menu will be attached. Can be "map" or "marker".
     * * `options` (array): A collection of context menu items:
     *   * `title` (string): Item's title shown in the context menu.
     *   * `name` (string): Item's identifier.
     *   * `action` (function): Function triggered after selecting the context menu item.
     */
          this.setContextMenu = function (options) {
            window.context_menu[self.el.id][options.control] = {};
            var i, ul = doc.createElement('ul');
            for (i in options.options) {
              if (options.options.hasOwnProperty(i)) {
                var option = options.options[i];
                window.context_menu[self.el.id][options.control][option.name] = {
                  title: option.title,
                  action: option.action
                }
              }
            }
            ul.id = 'gmaps_context_menu';
            ul.style.display = 'none';
            ul.style.position = 'absolute';
            ul.style.minWidth = '100px';
            ul.style.background = 'white';
            ul.style.listStyle = 'none';
            ul.style.padding = '8px';
            ul.style.boxShadow = '2px 2px 6px #ccc';
            if (!getElementById('gmaps_context_menu')) {
              doc.body.appendChild(ul)
            }
            var context_menu_element = getElementById('gmaps_context_menu');
            google.maps.event.addDomListener(context_menu_element, 'mouseout', function (ev) {
              if (!ev.relatedTarget || !this.contains(ev.relatedTarget)) {
                window.setTimeout(function () {
                  context_menu_element.style.display = 'none'
                }, 400)
              }
            }, false)
          };
          /**
     * Hide the current context menu
     */
          this.hideContextMenu = function () {
            var context_menu_element = getElementById('gmaps_context_menu');
            if (context_menu_element) {
              context_menu_element.style.display = 'none'
            }
          };
          var setupListener = function (object, name) {
            google.maps.event.addListener(object, name, function (e) {
              if (e == undefined) {
                e = this
              }
              options[name].apply(this, [e]);
              self.hideContextMenu()
            })
          };
          //google.maps.event.addListener(this.map, 'idle', this.hideContextMenu);
          google.maps.event.addListener(this.map, 'zoom_changed', this.hideContextMenu);
          for (var ev = 0; ev < events_that_hide_context_menu.length; ev++) {
            var name = events_that_hide_context_menu[ev];
            if (name in options) {
              setupListener(this.map, name)
            }
          }
          for (var ev = 0; ev < events_that_doesnt_hide_context_menu.length; ev++) {
            var name = events_that_doesnt_hide_context_menu[ev];
            if (name in options) {
              setupListener(this.map, name)
            }
          }
          google.maps.event.addListener(this.map, 'rightclick', function (e) {
            if (options.rightclick) {
              options.rightclick.apply(this, [e])
            }
            if (window.context_menu[self.el.id]['map'] != undefined) {
              self.buildContextMenu('map', e)
            }
          });
          /**
     * Trigger a `resize` event, useful if you need to repaint the current map (for changes in the viewport or display / hide actions).
     */
          this.refresh = function () {
            google.maps.event.trigger(this.map, 'resize')
          };
          /**
     * Adjust the map zoom to include all the markers added in the map.
     */
          this.fitZoom = function () {
            var latLngs = [], markers_length = this.markers.length, i;
            for (i = 0; i < markers_length; i++) {
              if (typeof this.markers[i].visible === 'boolean' && this.markers[i].visible) {
                latLngs.push(this.markers[i].getPosition())
              }
            }
            this.fitLatLngBounds(latLngs)
          };
          /**
     * Adjust the map zoom to include all the coordinates in the `latLngs` array.
     *
     * @param {array} latLngs - Collection of `google.maps.LatLng` objects.
     */
          this.fitLatLngBounds = function (latLngs) {
            var total = latLngs.length, bounds = new google.maps.LatLngBounds, i;
            for (i = 0; i < total; i++) {
              bounds.extend(latLngs[i])
            }
            this.map.fitBounds(bounds)
          };
          /**
     * Center the map using the `lat` and `lng` coordinates.
     *
     * @param {number} lat - Latitude of the coordinate.
     * @param {number} lng - Longitude of the coordinate.
     * @param {function} [callback] - Callback that will be executed after the map is centered.
     */
          this.setCenter = function (lat, lng, callback) {
            this.map.panTo(new google.maps.LatLng(lat, lng));
            if (callback) {
              callback()
            }
          };
          /**
     * Return the HTML element container of the map.
     *
     * @returns {HTMLElement} the element container.
     */
          this.getElement = function () {
            return this.el
          };
          /**
     * Increase the map's zoom.
     *
     * @param {number} [magnitude] - The number of times the map will be zoomed in.
     */
          this.zoomIn = function (value) {
            value = value || 1;
            this.zoom = this.map.getZoom() + value;
            this.map.setZoom(this.zoom)
          };
          /**
     * Decrease the map's zoom.
     *
     * @param {number} [magnitude] - The number of times the map will be zoomed out.
     */
          this.zoomOut = function (value) {
            value = value || 1;
            this.zoom = this.map.getZoom() - value;
            this.map.setZoom(this.zoom)
          };
          var native_methods = [], method;
          for (method in this.map) {
            if (typeof this.map[method] == 'function' && !this[method]) {
              native_methods.push(method)
            }
          }
          for (i = 0; i < native_methods.length; i++) {
            (function (gmaps, scope, method_name) {
              gmaps[method_name] = function () {
                return scope[method_name].apply(scope, arguments)
              }
            }(this, this.map, native_methods[i]))
          }
        };
        return GMaps
      }(this);
      GMaps.prototype.createControl = function (options) {
        var control = document.createElement('div');
        control.style.cursor = 'pointer';
        if (options.disableDefaultStyles !== true) {
          control.style.fontFamily = 'Roboto, Arial, sans-serif';
          control.style.fontSize = '11px';
          control.style.boxShadow = 'rgba(0, 0, 0, 0.298039) 0px 1px 4px -1px'
        }
        for (var option in options.style) {
          control.style[option] = options.style[option]
        }
        if (options.id) {
          control.id = options.id
        }
        if (options.title) {
          control.title = options.title
        }
        if (options.classes) {
          control.className = options.classes
        }
        if (options.content) {
          if (typeof options.content === 'string') {
            control.innerHTML = options.content
          } else if (options.content instanceof HTMLElement) {
            control.appendChild(options.content)
          }
        }
        if (options.position) {
          control.position = google.maps.ControlPosition[options.position.toUpperCase()]
        }
        for (var ev in options.events) {
          (function (object, name) {
            google.maps.event.addDomListener(object, name, function () {
              options.events[name].apply(this, [this])
            })
          }(control, ev))
        }
        control.index = 1;
        return control
      };
      /**
 * Add a custom control to the map UI.
 *
 * @param {object} options - The `options` object should contain:
 * * `style` (object): The keys and values of this object should be valid CSS properties and values.
 * * `id` (string): The HTML id for the custom control.
 * * `classes` (string): A string containing all the HTML classes for the custom control.
 * * `content` (string or HTML element): The content of the custom control.
 * * `position` (string): Any valid [`google.maps.ControlPosition`](https://developers.google.com/maps/documentation/javascript/controls#ControlPositioning) value, in lower or upper case.
 * * `events` (object): The keys of this object should be valid DOM events. The values should be functions.
 * * `disableDefaultStyles` (boolean): If false, removes the default styles for the controls like font (family and size), and box shadow.
 * @returns {HTMLElement}
 */
      GMaps.prototype.addControl = function (options) {
        var control = this.createControl(options);
        this.controls.push(control);
        this.map.controls[control.position].push(control);
        return control
      };
      /**
 * Remove a control from the map. `control` should be a control returned by `addControl()`.
 *
 * @param {HTMLElement} control - One of the controls returned by `addControl()`.
 * @returns {HTMLElement} the removed control.
 */
      GMaps.prototype.removeControl = function (control) {
        var position = null, i;
        for (i = 0; i < this.controls.length; i++) {
          if (this.controls[i] == control) {
            position = this.controls[i].position;
            this.controls.splice(i, 1)
          }
        }
        if (position) {
          for (i = 0; i < this.map.controls.length; i++) {
            var controlsForPosition = this.map.controls[control.position];
            if (controlsForPosition.getAt(i) == control) {
              controlsForPosition.removeAt(i);
              break
            }
          }
        }
        return control
      };
      GMaps.prototype.createMarker = function (options) {
        if (options.lat == undefined && options.lng == undefined && options.position == undefined) {
          throw 'No latitude or longitude defined.'
        }
        var self = this, details = options.details, fences = options.fences, outside = options.outside, base_options = {
            position: new google.maps.LatLng(options.lat, options.lng),
            map: null
          }, marker_options = extend_object(base_options, options);
        delete marker_options.lat;
        delete marker_options.lng;
        delete marker_options.fences;
        delete marker_options.outside;
        var marker = new google.maps.Marker(marker_options);
        marker.fences = fences;
        if (options.infoWindow) {
          marker.infoWindow = new google.maps.InfoWindow(options.infoWindow);
          var info_window_events = [
            'closeclick',
            'content_changed',
            'domready',
            'position_changed',
            'zindex_changed'
          ];
          for (var ev = 0; ev < info_window_events.length; ev++) {
            (function (object, name) {
              if (options.infoWindow[name]) {
                google.maps.event.addListener(object, name, function (e) {
                  options.infoWindow[name].apply(this, [e])
                })
              }
            }(marker.infoWindow, info_window_events[ev]))
          }
        }
        var marker_events = [
          'animation_changed',
          'clickable_changed',
          'cursor_changed',
          'draggable_changed',
          'flat_changed',
          'icon_changed',
          'position_changed',
          'shadow_changed',
          'shape_changed',
          'title_changed',
          'visible_changed',
          'zindex_changed'
        ];
        var marker_events_with_mouse = [
          'dblclick',
          'drag',
          'dragend',
          'dragstart',
          'mousedown',
          'mouseout',
          'mouseover',
          'mouseup'
        ];
        for (var ev = 0; ev < marker_events.length; ev++) {
          (function (object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function () {
                options[name].apply(this, [this])
              })
            }
          }(marker, marker_events[ev]))
        }
        for (var ev = 0; ev < marker_events_with_mouse.length; ev++) {
          (function (map, object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function (me) {
                if (!me.pixel) {
                  me.pixel = map.getProjection().fromLatLngToPoint(me.latLng)
                }
                options[name].apply(this, [me])
              })
            }
          }(this.map, marker, marker_events_with_mouse[ev]))
        }
        google.maps.event.addListener(marker, 'click', function () {
          this.details = details;
          if (options.click) {
            options.click.apply(this, [this])
          }
          if (marker.infoWindow) {
            self.hideInfoWindows();
            marker.infoWindow.open(self.map, marker)
          }
        });
        google.maps.event.addListener(marker, 'rightclick', function (e) {
          e.marker = this;
          if (options.rightclick) {
            options.rightclick.apply(this, [e])
          }
          if (window.context_menu[self.el.id]['marker'] != undefined) {
            self.buildContextMenu('marker', e)
          }
        });
        if (marker.fences) {
          google.maps.event.addListener(marker, 'dragend', function () {
            self.checkMarkerGeofence(marker, function (m, f) {
              outside(m, f)
            })
          })
        }
        return marker
      };
      GMaps.prototype.addMarker = function (options) {
        var marker;
        if (options.hasOwnProperty('gm_accessors_')) {
          // Native google.maps.Marker object
          marker = options
        } else {
          if (options.hasOwnProperty('lat') && options.hasOwnProperty('lng') || options.position) {
            marker = this.createMarker(options)
          } else {
            throw 'No latitude or longitude defined.'
          }
        }
        marker.setMap(this.map);
        if (this.markerClusterer) {
          this.markerClusterer.addMarker(marker)
        }
        this.markers.push(marker);
        GMaps.fire('marker_added', marker, this);
        return marker
      };
      GMaps.prototype.addMarkers = function (array) {
        for (var i = 0, marker; marker = array[i]; i++) {
          this.addMarker(marker)
        }
        return this.markers
      };
      GMaps.prototype.hideInfoWindows = function () {
        for (var i = 0, marker; marker = this.markers[i]; i++) {
          if (marker.infoWindow) {
            marker.infoWindow.close()
          }
        }
      };
      GMaps.prototype.removeMarker = function (marker) {
        for (var i = 0; i < this.markers.length; i++) {
          if (this.markers[i] === marker) {
            this.markers[i].setMap(null);
            this.markers.splice(i, 1);
            if (this.markerClusterer) {
              this.markerClusterer.removeMarker(marker)
            }
            GMaps.fire('marker_removed', marker, this);
            break
          }
        }
        return marker
      };
      GMaps.prototype.removeMarkers = function (collection) {
        var new_markers = [];
        if (typeof collection == 'undefined') {
          for (var i = 0; i < this.markers.length; i++) {
            var marker = this.markers[i];
            marker.setMap(null);
            GMaps.fire('marker_removed', marker, this)
          }
          if (this.markerClusterer && this.markerClusterer.clearMarkers) {
            this.markerClusterer.clearMarkers()
          }
          this.markers = new_markers
        } else {
          for (var i = 0; i < collection.length; i++) {
            var index = this.markers.indexOf(collection[i]);
            if (index > -1) {
              var marker = this.markers[index];
              marker.setMap(null);
              if (this.markerClusterer) {
                this.markerClusterer.removeMarker(marker)
              }
              GMaps.fire('marker_removed', marker, this)
            }
          }
          for (var i = 0; i < this.markers.length; i++) {
            var marker = this.markers[i];
            if (marker.getMap() != null) {
              new_markers.push(marker)
            }
          }
          this.markers = new_markers
        }
      };
      GMaps.prototype.drawOverlay = function (options) {
        var overlay = new google.maps.OverlayView, auto_show = true;
        overlay.setMap(this.map);
        if (options.auto_show != null) {
          auto_show = options.auto_show
        }
        overlay.onAdd = function () {
          var el = document.createElement('div');
          el.style.borderStyle = 'none';
          el.style.borderWidth = '0px';
          el.style.position = 'absolute';
          el.style.zIndex = 100;
          el.innerHTML = options.content;
          overlay.el = el;
          if (!options.layer) {
            options.layer = 'overlayLayer'
          }
          var panes = this.getPanes(), overlayLayer = panes[options.layer], stop_overlay_events = [
              'contextmenu',
              'DOMMouseScroll',
              'dblclick',
              'mousedown'
            ];
          overlayLayer.appendChild(el);
          for (var ev = 0; ev < stop_overlay_events.length; ev++) {
            (function (object, name) {
              google.maps.event.addDomListener(object, name, function (e) {
                if (navigator.userAgent.toLowerCase().indexOf('msie') != -1 && document.all) {
                  e.cancelBubble = true;
                  e.returnValue = false
                } else {
                  e.stopPropagation()
                }
              })
            }(el, stop_overlay_events[ev]))
          }
          if (options.click) {
            panes.overlayMouseTarget.appendChild(overlay.el);
            google.maps.event.addDomListener(overlay.el, 'click', function () {
              options.click.apply(overlay, [overlay])
            })
          }
          google.maps.event.trigger(this, 'ready')
        };
        overlay.draw = function () {
          var projection = this.getProjection(), pixel = projection.fromLatLngToDivPixel(new google.maps.LatLng(options.lat, options.lng));
          options.horizontalOffset = options.horizontalOffset || 0;
          options.verticalOffset = options.verticalOffset || 0;
          var el = overlay.el, content = el.children[0], content_height = content.clientHeight, content_width = content.clientWidth;
          switch (options.verticalAlign) {
          case 'top':
            el.style.top = pixel.y - content_height + options.verticalOffset + 'px';
            break;
          default:
          case 'middle':
            el.style.top = pixel.y - content_height / 2 + options.verticalOffset + 'px';
            break;
          case 'bottom':
            el.style.top = pixel.y + options.verticalOffset + 'px';
            break
          }
          switch (options.horizontalAlign) {
          case 'left':
            el.style.left = pixel.x - content_width + options.horizontalOffset + 'px';
            break;
          default:
          case 'center':
            el.style.left = pixel.x - content_width / 2 + options.horizontalOffset + 'px';
            break;
          case 'right':
            el.style.left = pixel.x + options.horizontalOffset + 'px';
            break
          }
          el.style.display = auto_show ? 'block' : 'none';
          if (!auto_show) {
            options.show.apply(this, [el])
          }
        };
        overlay.onRemove = function () {
          var el = overlay.el;
          if (options.remove) {
            options.remove.apply(this, [el])
          } else {
            overlay.el.parentNode.removeChild(overlay.el);
            overlay.el = null
          }
        };
        this.overlays.push(overlay);
        return overlay
      };
      GMaps.prototype.removeOverlay = function (overlay) {
        for (var i = 0; i < this.overlays.length; i++) {
          if (this.overlays[i] === overlay) {
            this.overlays[i].setMap(null);
            this.overlays.splice(i, 1);
            break
          }
        }
      };
      GMaps.prototype.removeOverlays = function () {
        for (var i = 0, item; item = this.overlays[i]; i++) {
          item.setMap(null)
        }
        this.overlays = []
      };
      GMaps.prototype.drawPolyline = function (options) {
        var path = [], points = options.path;
        if (points.length) {
          if (points[0][0] === undefined) {
            path = points
          } else {
            for (var i = 0, latlng; latlng = points[i]; i++) {
              path.push(new google.maps.LatLng(latlng[0], latlng[1]))
            }
          }
        }
        var polyline_options = {
          map: this.map,
          path: path,
          strokeColor: options.strokeColor,
          strokeOpacity: options.strokeOpacity,
          strokeWeight: options.strokeWeight,
          geodesic: options.geodesic,
          clickable: true,
          editable: false,
          visible: true
        };
        if (options.hasOwnProperty('clickable')) {
          polyline_options.clickable = options.clickable
        }
        if (options.hasOwnProperty('editable')) {
          polyline_options.editable = options.editable
        }
        if (options.hasOwnProperty('icons')) {
          polyline_options.icons = options.icons
        }
        if (options.hasOwnProperty('zIndex')) {
          polyline_options.zIndex = options.zIndex
        }
        var polyline = new google.maps.Polyline(polyline_options);
        var polyline_events = [
          'click',
          'dblclick',
          'mousedown',
          'mousemove',
          'mouseout',
          'mouseover',
          'mouseup',
          'rightclick'
        ];
        for (var ev = 0; ev < polyline_events.length; ev++) {
          (function (object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function (e) {
                options[name].apply(this, [e])
              })
            }
          }(polyline, polyline_events[ev]))
        }
        this.polylines.push(polyline);
        GMaps.fire('polyline_added', polyline, this);
        return polyline
      };
      GMaps.prototype.removePolyline = function (polyline) {
        for (var i = 0; i < this.polylines.length; i++) {
          if (this.polylines[i] === polyline) {
            this.polylines[i].setMap(null);
            this.polylines.splice(i, 1);
            GMaps.fire('polyline_removed', polyline, this);
            break
          }
        }
      };
      GMaps.prototype.removePolylines = function () {
        for (var i = 0, item; item = this.polylines[i]; i++) {
          item.setMap(null)
        }
        this.polylines = []
      };
      GMaps.prototype.drawCircle = function (options) {
        options = extend_object({
          map: this.map,
          center: new google.maps.LatLng(options.lat, options.lng)
        }, options);
        delete options.lat;
        delete options.lng;
        var polygon = new google.maps.Circle(options), polygon_events = [
            'click',
            'dblclick',
            'mousedown',
            'mousemove',
            'mouseout',
            'mouseover',
            'mouseup',
            'rightclick'
          ];
        for (var ev = 0; ev < polygon_events.length; ev++) {
          (function (object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function (e) {
                options[name].apply(this, [e])
              })
            }
          }(polygon, polygon_events[ev]))
        }
        this.polygons.push(polygon);
        return polygon
      };
      GMaps.prototype.drawRectangle = function (options) {
        options = extend_object({ map: this.map }, options);
        var latLngBounds = new google.maps.LatLngBounds(new google.maps.LatLng(options.bounds[0][0], options.bounds[0][1]), new google.maps.LatLng(options.bounds[1][0], options.bounds[1][1]));
        options.bounds = latLngBounds;
        var polygon = new google.maps.Rectangle(options), polygon_events = [
            'click',
            'dblclick',
            'mousedown',
            'mousemove',
            'mouseout',
            'mouseover',
            'mouseup',
            'rightclick'
          ];
        for (var ev = 0; ev < polygon_events.length; ev++) {
          (function (object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function (e) {
                options[name].apply(this, [e])
              })
            }
          }(polygon, polygon_events[ev]))
        }
        this.polygons.push(polygon);
        return polygon
      };
      GMaps.prototype.drawPolygon = function (options) {
        var useGeoJSON = false;
        if (options.hasOwnProperty('useGeoJSON')) {
          useGeoJSON = options.useGeoJSON
        }
        delete options.useGeoJSON;
        options = extend_object({ map: this.map }, options);
        if (useGeoJSON == false) {
          options.paths = [options.paths.slice(0)]
        }
        if (options.paths.length > 0) {
          if (options.paths[0].length > 0) {
            options.paths = array_flat(array_map(options.paths, arrayToLatLng, useGeoJSON))
          }
        }
        var polygon = new google.maps.Polygon(options), polygon_events = [
            'click',
            'dblclick',
            'mousedown',
            'mousemove',
            'mouseout',
            'mouseover',
            'mouseup',
            'rightclick'
          ];
        for (var ev = 0; ev < polygon_events.length; ev++) {
          (function (object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function (e) {
                options[name].apply(this, [e])
              })
            }
          }(polygon, polygon_events[ev]))
        }
        this.polygons.push(polygon);
        GMaps.fire('polygon_added', polygon, this);
        return polygon
      };
      GMaps.prototype.removePolygon = function (polygon) {
        for (var i = 0; i < this.polygons.length; i++) {
          if (this.polygons[i] === polygon) {
            this.polygons[i].setMap(null);
            this.polygons.splice(i, 1);
            GMaps.fire('polygon_removed', polygon, this);
            break
          }
        }
      };
      GMaps.prototype.removePolygons = function () {
        for (var i = 0, item; item = this.polygons[i]; i++) {
          item.setMap(null)
        }
        this.polygons = []
      };
      GMaps.prototype.getFromFusionTables = function (options) {
        var events = options.events;
        delete options.events;
        var fusion_tables_options = options, layer = new google.maps.FusionTablesLayer(fusion_tables_options);
        for (var ev in events) {
          (function (object, name) {
            google.maps.event.addListener(object, name, function (e) {
              events[name].apply(this, [e])
            })
          }(layer, ev))
        }
        this.layers.push(layer);
        return layer
      };
      GMaps.prototype.loadFromFusionTables = function (options) {
        var layer = this.getFromFusionTables(options);
        layer.setMap(this.map);
        return layer
      };
      GMaps.prototype.getFromKML = function (options) {
        var url = options.url, events = options.events;
        delete options.url;
        delete options.events;
        var kml_options = options, layer = new google.maps.KmlLayer(url, kml_options);
        for (var ev in events) {
          (function (object, name) {
            google.maps.event.addListener(object, name, function (e) {
              events[name].apply(this, [e])
            })
          }(layer, ev))
        }
        this.layers.push(layer);
        return layer
      };
      GMaps.prototype.loadFromKML = function (options) {
        var layer = this.getFromKML(options);
        layer.setMap(this.map);
        return layer
      };
      GMaps.prototype.addLayer = function (layerName, options) {
        //var default_layers = ['weather', 'clouds', 'traffic', 'transit', 'bicycling', 'panoramio', 'places'];
        options = options || {};
        var layer;
        switch (layerName) {
        case 'weather':
          this.singleLayers.weather = layer = new google.maps.weather.WeatherLayer;
          break;
        case 'clouds':
          this.singleLayers.clouds = layer = new google.maps.weather.CloudLayer;
          break;
        case 'traffic':
          this.singleLayers.traffic = layer = new google.maps.TrafficLayer;
          break;
        case 'transit':
          this.singleLayers.transit = layer = new google.maps.TransitLayer;
          break;
        case 'bicycling':
          this.singleLayers.bicycling = layer = new google.maps.BicyclingLayer;
          break;
        case 'panoramio':
          this.singleLayers.panoramio = layer = new google.maps.panoramio.PanoramioLayer;
          layer.setTag(options.filter);
          delete options.filter;
          //click event
          if (options.click) {
            google.maps.event.addListener(layer, 'click', function (event) {
              options.click(event);
              delete options.click
            })
          }
          break;
        case 'places':
          this.singleLayers.places = layer = new google.maps.places.PlacesService(this.map);
          //search, nearbySearch, radarSearch callback, Both are the same
          if (options.search || options.nearbySearch || options.radarSearch) {
            var placeSearchRequest = {
              bounds: options.bounds || null,
              keyword: options.keyword || null,
              location: options.location || null,
              name: options.name || null,
              radius: options.radius || null,
              rankBy: options.rankBy || null,
              types: options.types || null
            };
            if (options.radarSearch) {
              layer.radarSearch(placeSearchRequest, options.radarSearch)
            }
            if (options.search) {
              layer.search(placeSearchRequest, options.search)
            }
            if (options.nearbySearch) {
              layer.nearbySearch(placeSearchRequest, options.nearbySearch)
            }
          }
          //textSearch callback
          if (options.textSearch) {
            var textSearchRequest = {
              bounds: options.bounds || null,
              location: options.location || null,
              query: options.query || null,
              radius: options.radius || null
            };
            layer.textSearch(textSearchRequest, options.textSearch)
          }
          break
        }
        if (layer !== undefined) {
          if (typeof layer.setOptions == 'function') {
            layer.setOptions(options)
          }
          if (typeof layer.setMap == 'function') {
            layer.setMap(this.map)
          }
          return layer
        }
      };
      GMaps.prototype.removeLayer = function (layer) {
        if (typeof layer == 'string' && this.singleLayers[layer] !== undefined) {
          this.singleLayers[layer].setMap(null);
          delete this.singleLayers[layer]
        } else {
          for (var i = 0; i < this.layers.length; i++) {
            if (this.layers[i] === layer) {
              this.layers[i].setMap(null);
              this.layers.splice(i, 1);
              break
            }
          }
        }
      };
      var travelMode, unitSystem;
      GMaps.prototype.getRoutes = function (options) {
        switch (options.travelMode) {
        case 'bicycling':
          travelMode = google.maps.TravelMode.BICYCLING;
          break;
        case 'transit':
          travelMode = google.maps.TravelMode.TRANSIT;
          break;
        case 'driving':
          travelMode = google.maps.TravelMode.DRIVING;
          break;
        default:
          travelMode = google.maps.TravelMode.WALKING;
          break
        }
        if (options.unitSystem === 'imperial') {
          unitSystem = google.maps.UnitSystem.IMPERIAL
        } else {
          unitSystem = google.maps.UnitSystem.METRIC
        }
        var base_options = {
            avoidHighways: false,
            avoidTolls: false,
            optimizeWaypoints: false,
            waypoints: []
          }, request_options = extend_object(base_options, options);
        request_options.origin = /string/.test(typeof options.origin) ? options.origin : new google.maps.LatLng(options.origin[0], options.origin[1]);
        request_options.destination = /string/.test(typeof options.destination) ? options.destination : new google.maps.LatLng(options.destination[0], options.destination[1]);
        request_options.travelMode = travelMode;
        request_options.unitSystem = unitSystem;
        delete request_options.callback;
        delete request_options.error;
        var self = this, routes = [], service = new google.maps.DirectionsService;
        service.route(request_options, function (result, status) {
          if (status === google.maps.DirectionsStatus.OK) {
            for (var r in result.routes) {
              if (result.routes.hasOwnProperty(r)) {
                routes.push(result.routes[r])
              }
            }
            if (options.callback) {
              options.callback(routes, result, status)
            }
          } else {
            if (options.error) {
              options.error(result, status)
            }
          }
        })
      };
      GMaps.prototype.removeRoutes = function () {
        this.routes.length = 0
      };
      GMaps.prototype.getElevations = function (options) {
        options = extend_object({
          locations: [],
          path: false,
          samples: 256
        }, options);
        if (options.locations.length > 0) {
          if (options.locations[0].length > 0) {
            options.locations = array_flat(array_map([options.locations], arrayToLatLng, false))
          }
        }
        var callback = options.callback;
        delete options.callback;
        var service = new google.maps.ElevationService;
        //location request
        if (!options.path) {
          delete options.path;
          delete options.samples;
          service.getElevationForLocations(options, function (result, status) {
            if (callback && typeof callback === 'function') {
              callback(result, status)
            }
          })  //path request
        } else {
          var pathRequest = {
            path: options.locations,
            samples: options.samples
          };
          service.getElevationAlongPath(pathRequest, function (result, status) {
            if (callback && typeof callback === 'function') {
              callback(result, status)
            }
          })
        }
      };
      GMaps.prototype.cleanRoute = GMaps.prototype.removePolylines;
      GMaps.prototype.renderRoute = function (options, renderOptions) {
        var self = this, panel = typeof renderOptions.panel === 'string' ? document.getElementById(renderOptions.panel.replace('#', '')) : renderOptions.panel, display;
        renderOptions.panel = panel;
        renderOptions = extend_object({ map: this.map }, renderOptions);
        display = new google.maps.DirectionsRenderer(renderOptions);
        this.getRoutes({
          origin: options.origin,
          destination: options.destination,
          travelMode: options.travelMode,
          waypoints: options.waypoints,
          unitSystem: options.unitSystem,
          error: options.error,
          avoidHighways: options.avoidHighways,
          avoidTolls: options.avoidTolls,
          optimizeWaypoints: options.optimizeWaypoints,
          callback: function (routes, response, status) {
            if (status === google.maps.DirectionsStatus.OK) {
              display.setDirections(response)
            }
          }
        })
      };
      GMaps.prototype.drawRoute = function (options) {
        var self = this;
        this.getRoutes({
          origin: options.origin,
          destination: options.destination,
          travelMode: options.travelMode,
          waypoints: options.waypoints,
          unitSystem: options.unitSystem,
          error: options.error,
          avoidHighways: options.avoidHighways,
          avoidTolls: options.avoidTolls,
          optimizeWaypoints: options.optimizeWaypoints,
          callback: function (routes) {
            if (routes.length > 0) {
              var polyline_options = {
                path: routes[routes.length - 1].overview_path,
                strokeColor: options.strokeColor,
                strokeOpacity: options.strokeOpacity,
                strokeWeight: options.strokeWeight
              };
              if (options.hasOwnProperty('icons')) {
                polyline_options.icons = options.icons
              }
              self.drawPolyline(polyline_options);
              if (options.callback) {
                options.callback(routes[routes.length - 1])
              }
            }
          }
        })
      };
      GMaps.prototype.travelRoute = function (options) {
        if (options.origin && options.destination) {
          this.getRoutes({
            origin: options.origin,
            destination: options.destination,
            travelMode: options.travelMode,
            waypoints: options.waypoints,
            unitSystem: options.unitSystem,
            error: options.error,
            callback: function (e) {
              //start callback
              if (e.length > 0 && options.start) {
                options.start(e[e.length - 1])
              }
              //step callback
              if (e.length > 0 && options.step) {
                var route = e[e.length - 1];
                if (route.legs.length > 0) {
                  var steps = route.legs[0].steps;
                  for (var i = 0, step; step = steps[i]; i++) {
                    step.step_number = i;
                    options.step(step, route.legs[0].steps.length - 1)
                  }
                }
              }
              //end callback
              if (e.length > 0 && options.end) {
                options.end(e[e.length - 1])
              }
            }
          })
        } else if (options.route) {
          if (options.route.legs.length > 0) {
            var steps = options.route.legs[0].steps;
            for (var i = 0, step; step = steps[i]; i++) {
              step.step_number = i;
              options.step(step)
            }
          }
        }
      };
      GMaps.prototype.drawSteppedRoute = function (options) {
        var self = this;
        if (options.origin && options.destination) {
          this.getRoutes({
            origin: options.origin,
            destination: options.destination,
            travelMode: options.travelMode,
            waypoints: options.waypoints,
            error: options.error,
            callback: function (e) {
              //start callback
              if (e.length > 0 && options.start) {
                options.start(e[e.length - 1])
              }
              //step callback
              if (e.length > 0 && options.step) {
                var route = e[e.length - 1];
                if (route.legs.length > 0) {
                  var steps = route.legs[0].steps;
                  for (var i = 0, step; step = steps[i]; i++) {
                    step.step_number = i;
                    var polyline_options = {
                      path: step.path,
                      strokeColor: options.strokeColor,
                      strokeOpacity: options.strokeOpacity,
                      strokeWeight: options.strokeWeight
                    };
                    if (options.hasOwnProperty('icons')) {
                      polyline_options.icons = options.icons
                    }
                    self.drawPolyline(polyline_options);
                    options.step(step, route.legs[0].steps.length - 1)
                  }
                }
              }
              //end callback
              if (e.length > 0 && options.end) {
                options.end(e[e.length - 1])
              }
            }
          })
        } else if (options.route) {
          if (options.route.legs.length > 0) {
            var steps = options.route.legs[0].steps;
            for (var i = 0, step; step = steps[i]; i++) {
              step.step_number = i;
              var polyline_options = {
                path: step.path,
                strokeColor: options.strokeColor,
                strokeOpacity: options.strokeOpacity,
                strokeWeight: options.strokeWeight
              };
              if (options.hasOwnProperty('icons')) {
                polyline_options.icons = options.icons
              }
              self.drawPolyline(polyline_options);
              options.step(step)
            }
          }
        }
      };
      GMaps.Route = function (options) {
        this.origin = options.origin;
        this.destination = options.destination;
        this.waypoints = options.waypoints;
        this.map = options.map;
        this.route = options.route;
        this.step_count = 0;
        this.steps = this.route.legs[0].steps;
        this.steps_length = this.steps.length;
        var polyline_options = {
          path: new google.maps.MVCArray,
          strokeColor: options.strokeColor,
          strokeOpacity: options.strokeOpacity,
          strokeWeight: options.strokeWeight
        };
        if (options.hasOwnProperty('icons')) {
          polyline_options.icons = options.icons
        }
        this.polyline = this.map.drawPolyline(polyline_options).getPath()
      };
      GMaps.Route.prototype.getRoute = function (options) {
        var self = this;
        this.map.getRoutes({
          origin: this.origin,
          destination: this.destination,
          travelMode: options.travelMode,
          waypoints: this.waypoints || [],
          error: options.error,
          callback: function () {
            self.route = e[0];
            if (options.callback) {
              options.callback.call(self)
            }
          }
        })
      };
      GMaps.Route.prototype.back = function () {
        if (this.step_count > 0) {
          this.step_count--;
          var path = this.route.legs[0].steps[this.step_count].path;
          for (var p in path) {
            if (path.hasOwnProperty(p)) {
              this.polyline.pop()
            }
          }
        }
      };
      GMaps.Route.prototype.forward = function () {
        if (this.step_count < this.steps_length) {
          var path = this.route.legs[0].steps[this.step_count].path;
          for (var p in path) {
            if (path.hasOwnProperty(p)) {
              this.polyline.push(path[p])
            }
          }
          this.step_count++
        }
      };
      GMaps.prototype.checkGeofence = function (lat, lng, fence) {
        return fence.containsLatLng(new google.maps.LatLng(lat, lng))
      };
      GMaps.prototype.checkMarkerGeofence = function (marker, outside_callback) {
        if (marker.fences) {
          for (var i = 0, fence; fence = marker.fences[i]; i++) {
            var pos = marker.getPosition();
            if (!this.checkGeofence(pos.lat(), pos.lng(), fence)) {
              outside_callback(marker, fence)
            }
          }
        }
      };
      GMaps.prototype.toImage = function (options) {
        var options = options || {}, static_map_options = {};
        static_map_options['size'] = options['size'] || [
          this.el.clientWidth,
          this.el.clientHeight
        ];
        static_map_options['lat'] = this.getCenter().lat();
        static_map_options['lng'] = this.getCenter().lng();
        if (this.markers.length > 0) {
          static_map_options['markers'] = [];
          for (var i = 0; i < this.markers.length; i++) {
            static_map_options['markers'].push({
              lat: this.markers[i].getPosition().lat(),
              lng: this.markers[i].getPosition().lng()
            })
          }
        }
        if (this.polylines.length > 0) {
          var polyline = this.polylines[0];
          static_map_options['polyline'] = {};
          static_map_options['polyline']['path'] = google.maps.geometry.encoding.encodePath(polyline.getPath());
          static_map_options['polyline']['strokeColor'] = polyline.strokeColor;
          static_map_options['polyline']['strokeOpacity'] = polyline.strokeOpacity;
          static_map_options['polyline']['strokeWeight'] = polyline.strokeWeight
        }
        return GMaps.staticMapURL(static_map_options)
      };
      GMaps.staticMapURL = function (options) {
        var parameters = [], data, static_root = (location.protocol === 'file:' ? 'http:' : location.protocol) + '//maps.googleapis.com/maps/api/staticmap';
        if (options.url) {
          static_root = options.url;
          delete options.url
        }
        static_root += '?';
        var markers = options.markers;
        delete options.markers;
        if (!markers && options.marker) {
          markers = [options.marker];
          delete options.marker
        }
        var styles = options.styles;
        delete options.styles;
        var polyline = options.polyline;
        delete options.polyline;
        /** Map options **/
        if (options.center) {
          parameters.push('center=' + options.center);
          delete options.center
        } else if (options.address) {
          parameters.push('center=' + options.address);
          delete options.address
        } else if (options.lat) {
          parameters.push([
            'center=',
            options.lat,
            ',',
            options.lng
          ].join(''));
          delete options.lat;
          delete options.lng
        } else if (options.visible) {
          var visible = encodeURI(options.visible.join('|'));
          parameters.push('visible=' + visible)
        }
        var size = options.size;
        if (size) {
          if (size.join) {
            size = size.join('x')
          }
          delete options.size
        } else {
          size = '630x300'
        }
        parameters.push('size=' + size);
        if (!options.zoom && options.zoom !== false) {
          options.zoom = 15
        }
        var sensor = options.hasOwnProperty('sensor') ? !!options.sensor : true;
        delete options.sensor;
        parameters.push('sensor=' + sensor);
        for (var param in options) {
          if (options.hasOwnProperty(param)) {
            parameters.push(param + '=' + options[param])
          }
        }
        /** Markers **/
        if (markers) {
          var marker, loc;
          for (var i = 0; data = markers[i]; i++) {
            marker = [];
            if (data.size && data.size !== 'normal') {
              marker.push('size:' + data.size);
              delete data.size
            } else if (data.icon) {
              marker.push('icon:' + encodeURI(data.icon));
              delete data.icon
            }
            if (data.color) {
              marker.push('color:' + data.color.replace('#', '0x'));
              delete data.color
            }
            if (data.label) {
              marker.push('label:' + data.label[0].toUpperCase());
              delete data.label
            }
            loc = data.address ? data.address : data.lat + ',' + data.lng;
            delete data.address;
            delete data.lat;
            delete data.lng;
            for (var param in data) {
              if (data.hasOwnProperty(param)) {
                marker.push(param + ':' + data[param])
              }
            }
            if (marker.length || i === 0) {
              marker.push(loc);
              marker = marker.join('|');
              parameters.push('markers=' + encodeURI(marker))
            }  // New marker without styles
            else {
              marker = parameters.pop() + encodeURI('|' + loc);
              parameters.push(marker)
            }
          }
        }
        /** Map Styles **/
        if (styles) {
          for (var i = 0; i < styles.length; i++) {
            var styleRule = [];
            if (styles[i].featureType) {
              styleRule.push('feature:' + styles[i].featureType.toLowerCase())
            }
            if (styles[i].elementType) {
              styleRule.push('element:' + styles[i].elementType.toLowerCase())
            }
            for (var j = 0; j < styles[i].stylers.length; j++) {
              for (var p in styles[i].stylers[j]) {
                var ruleArg = styles[i].stylers[j][p];
                if (p == 'hue' || p == 'color') {
                  ruleArg = '0x' + ruleArg.substring(1)
                }
                styleRule.push(p + ':' + ruleArg)
              }
            }
            var rule = styleRule.join('|');
            if (rule != '') {
              parameters.push('style=' + rule)
            }
          }
        }
        /** Polylines **/
        function parseColor(color, opacity) {
          if (color[0] === '#') {
            color = color.replace('#', '0x');
            if (opacity) {
              opacity = parseFloat(opacity);
              opacity = Math.min(1, Math.max(opacity, 0));
              if (opacity === 0) {
                return '0x00000000'
              }
              opacity = (opacity * 255).toString(16);
              if (opacity.length === 1) {
                opacity += opacity
              }
              color = color.slice(0, 8) + opacity
            }
          }
          return color
        }
        if (polyline) {
          data = polyline;
          polyline = [];
          if (data.strokeWeight) {
            polyline.push('weight:' + parseInt(data.strokeWeight, 10))
          }
          if (data.strokeColor) {
            var color = parseColor(data.strokeColor, data.strokeOpacity);
            polyline.push('color:' + color)
          }
          if (data.fillColor) {
            var fillcolor = parseColor(data.fillColor, data.fillOpacity);
            polyline.push('fillcolor:' + fillcolor)
          }
          var path = data.path;
          if (path.join) {
            for (var j = 0, pos; pos = path[j]; j++) {
              polyline.push(pos.join(','))
            }
          } else {
            polyline.push('enc:' + path)
          }
          polyline = polyline.join('|');
          parameters.push('path=' + encodeURI(polyline))
        }
        /** Retina support **/
        var dpi = window.devicePixelRatio || 1;
        parameters.push('scale=' + dpi);
        parameters = parameters.join('&');
        return static_root + parameters
      };
      GMaps.prototype.addMapType = function (mapTypeId, options) {
        if (options.hasOwnProperty('getTileUrl') && typeof options['getTileUrl'] == 'function') {
          options.tileSize = options.tileSize || new google.maps.Size(256, 256);
          var mapType = new google.maps.ImageMapType(options);
          this.map.mapTypes.set(mapTypeId, mapType)
        } else {
          throw "'getTileUrl' function required."
        }
      };
      GMaps.prototype.addOverlayMapType = function (options) {
        if (options.hasOwnProperty('getTile') && typeof options['getTile'] == 'function') {
          var overlayMapTypeIndex = options.index;
          delete options.index;
          this.map.overlayMapTypes.insertAt(overlayMapTypeIndex, options)
        } else {
          throw "'getTile' function required."
        }
      };
      GMaps.prototype.removeOverlayMapType = function (overlayMapTypeIndex) {
        this.map.overlayMapTypes.removeAt(overlayMapTypeIndex)
      };
      GMaps.prototype.addStyle = function (options) {
        var styledMapType = new google.maps.StyledMapType(options.styles, { name: options.styledMapName });
        this.map.mapTypes.set(options.mapTypeId, styledMapType)
      };
      GMaps.prototype.setStyle = function (mapTypeId) {
        this.map.setMapTypeId(mapTypeId)
      };
      GMaps.prototype.createPanorama = function (streetview_options) {
        if (!streetview_options.hasOwnProperty('lat') || !streetview_options.hasOwnProperty('lng')) {
          streetview_options.lat = this.getCenter().lat();
          streetview_options.lng = this.getCenter().lng()
        }
        this.panorama = GMaps.createPanorama(streetview_options);
        this.map.setStreetView(this.panorama);
        return this.panorama
      };
      GMaps.createPanorama = function (options) {
        var el = getElementById(options.el, options.context);
        options.position = new google.maps.LatLng(options.lat, options.lng);
        delete options.el;
        delete options.context;
        delete options.lat;
        delete options.lng;
        var streetview_events = [
            'closeclick',
            'links_changed',
            'pano_changed',
            'position_changed',
            'pov_changed',
            'resize',
            'visible_changed'
          ], streetview_options = extend_object({ visible: true }, options);
        for (var i = 0; i < streetview_events.length; i++) {
          delete streetview_options[streetview_events[i]]
        }
        var panorama = new google.maps.StreetViewPanorama(el, streetview_options);
        for (var i = 0; i < streetview_events.length; i++) {
          (function (object, name) {
            if (options[name]) {
              google.maps.event.addListener(object, name, function () {
                options[name].apply(this)
              })
            }
          }(panorama, streetview_events[i]))
        }
        return panorama
      };
      GMaps.prototype.on = function (event_name, handler) {
        return GMaps.on(event_name, this, handler)
      };
      GMaps.prototype.off = function (event_name) {
        GMaps.off(event_name, this)
      };
      GMaps.prototype.once = function (event_name, handler) {
        return GMaps.once(event_name, this, handler)
      };
      GMaps.custom_events = [
        'marker_added',
        'marker_removed',
        'polyline_added',
        'polyline_removed',
        'polygon_added',
        'polygon_removed',
        'geolocated',
        'geolocation_failed'
      ];
      GMaps.on = function (event_name, object, handler) {
        if (GMaps.custom_events.indexOf(event_name) == -1) {
          if (object instanceof GMaps)
            object = object.map;
          return google.maps.event.addListener(object, event_name, handler)
        } else {
          var registered_event = {
            handler: handler,
            eventName: event_name
          };
          object.registered_events[event_name] = object.registered_events[event_name] || [];
          object.registered_events[event_name].push(registered_event);
          return registered_event
        }
      };
      GMaps.off = function (event_name, object) {
        if (GMaps.custom_events.indexOf(event_name) == -1) {
          if (object instanceof GMaps)
            object = object.map;
          google.maps.event.clearListeners(object, event_name)
        } else {
          object.registered_events[event_name] = []
        }
      };
      GMaps.once = function (event_name, object, handler) {
        if (GMaps.custom_events.indexOf(event_name) == -1) {
          if (object instanceof GMaps)
            object = object.map;
          return google.maps.event.addListenerOnce(object, event_name, handler)
        }
      };
      GMaps.fire = function (event_name, object, scope) {
        if (GMaps.custom_events.indexOf(event_name) == -1) {
          google.maps.event.trigger(object, event_name, Array.prototype.slice.apply(arguments).slice(2))
        } else {
          if (event_name in scope.registered_events) {
            var firing_events = scope.registered_events[event_name];
            for (var i = 0; i < firing_events.length; i++) {
              (function (handler, scope, object) {
                handler.apply(scope, [object])
              }(firing_events[i]['handler'], scope, object))
            }
          }
        }
      };
      GMaps.geolocate = function (options) {
        var complete_callback = options.always || options.complete;
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(function (position) {
            options.success(position);
            if (complete_callback) {
              complete_callback()
            }
          }, function (error) {
            options.error(error);
            if (complete_callback) {
              complete_callback()
            }
          }, options.options)
        } else {
          options.not_supported();
          if (complete_callback) {
            complete_callback()
          }
        }
      };
      GMaps.geocode = function (options) {
        this.geocoder = new google.maps.Geocoder;
        var callback = options.callback;
        if (options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) {
          options.latLng = new google.maps.LatLng(options.lat, options.lng)
        }
        delete options.lat;
        delete options.lng;
        delete options.callback;
        this.geocoder.geocode(options, function (results, status) {
          callback(results, status)
        })
      };
      if (typeof window.google === 'object' && window.google.maps) {
        //==========================
        // Polygon containsLatLng
        // https://github.com/tparkin/Google-Maps-Point-in-Polygon
        // Poygon getBounds extension - google-maps-extensions
        // http://code.google.com/p/google-maps-extensions/source/browse/google.maps.Polygon.getBounds.js
        if (!google.maps.Polygon.prototype.getBounds) {
          google.maps.Polygon.prototype.getBounds = function (latLng) {
            var bounds = new google.maps.LatLngBounds;
            var paths = this.getPaths();
            var path;
            for (var p = 0; p < paths.getLength(); p++) {
              path = paths.getAt(p);
              for (var i = 0; i < path.getLength(); i++) {
                bounds.extend(path.getAt(i))
              }
            }
            return bounds
          }
        }
        if (!google.maps.Polygon.prototype.containsLatLng) {
          // Polygon containsLatLng - method to determine if a latLng is within a polygon
          google.maps.Polygon.prototype.containsLatLng = function (latLng) {
            // Exclude points outside of bounds as there is no way they are in the poly
            var bounds = this.getBounds();
            if (bounds !== null && !bounds.contains(latLng)) {
              return false
            }
            // Raycast point in polygon method
            var inPoly = false;
            var numPaths = this.getPaths().getLength();
            for (var p = 0; p < numPaths; p++) {
              var path = this.getPaths().getAt(p);
              var numPoints = path.getLength();
              var j = numPoints - 1;
              for (var i = 0; i < numPoints; i++) {
                var vertex1 = path.getAt(i);
                var vertex2 = path.getAt(j);
                if (vertex1.lng() < latLng.lng() && vertex2.lng() >= latLng.lng() || vertex2.lng() < latLng.lng() && vertex1.lng() >= latLng.lng()) {
                  if (vertex1.lat() + (latLng.lng() - vertex1.lng()) / (vertex2.lng() - vertex1.lng()) * (vertex2.lat() - vertex1.lat()) < latLng.lat()) {
                    inPoly = !inPoly
                  }
                }
                j = i
              }
            }
            return inPoly
          }
        }
        if (!google.maps.Circle.prototype.containsLatLng) {
          google.maps.Circle.prototype.containsLatLng = function (latLng) {
            if (google.maps.geometry) {
              return google.maps.geometry.spherical.computeDistanceBetween(this.getCenter(), latLng) <= this.getRadius()
            } else {
              return true
            }
          }
        }
        google.maps.Rectangle.prototype.containsLatLng = function (latLng) {
          return this.getBounds().contains(latLng)
        };
        google.maps.LatLngBounds.prototype.containsLatLng = function (latLng) {
          return this.contains(latLng)
        };
        google.maps.Marker.prototype.setFences = function (fences) {
          this.fences = fences
        };
        google.maps.Marker.prototype.addFence = function (fence) {
          this.fences.push(fence)
        };
        google.maps.Marker.prototype.getId = function () {
          return this['__gm_id']
        }
      }
      //==========================
      // Array indexOf
      // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf
      if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement) {
          'use strict';
          if (this == null) {
            throw new TypeError
          }
          var t = Object(this);
          var len = t.length >>> 0;
          if (len === 0) {
            return -1
          }
          var n = 0;
          if (arguments.length > 1) {
            n = Number(arguments[1]);
            if (n != n) {
              // shortcut for verifying if it's NaN
              n = 0
            } else if (n != 0 && n != Infinity && n != -Infinity) {
              n = (n > 0 || -1) * Math.floor(Math.abs(n))
            }
          }
          if (n >= len) {
            return -1
          }
          var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
          for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
              return k
            }
          }
          return -1
        }
      }
      return GMaps
    }))
  });
  // source: assets/js/dash/widget/listing/index.coffee
  rqzt.define('./widget/listing', function (module, exports, __dirname, __filename, process) {
    var Api, BasicTableView, Events, ListingWidget, View, _, crowdcontrol, input, table, util, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    util = rqzt('./util');
    table = rqzt('./table');
    input = rqzt('./form/input');
    Api = crowdcontrol.data.Api;
    View = crowdcontrol.view.View;
    BasicTableView = table.BasicTableView;
    ListingWidget = function (superClass) {
      var obj;
      extend(ListingWidget, superClass);
      function ListingWidget() {
        return ListingWidget.__super__.constructor.apply(this, arguments)
      }
      ListingWidget.prototype.tag = 'listing-widget';
      ListingWidget.prototype.html = rqzt('./templates/dash/widget/listing/template');
      ListingWidget.prototype.events = (obj = {}, obj['' + Events.Form.Prefill] = function (model) {
        this.model = model;
        if (this.model.listing == null) {
          this.model.listing = {}
        }
        return this.reset()
      }, obj);
      ListingWidget.prototype.js = function (opts) {
        var api;
        ListingWidget.__super__.js.apply(this, arguments);
        this.util = util;
        this.api = api = Api.get('crowdstart');
        return api.get('product').then(function (_this) {
          return function (res) {
            if (res.status !== 200) {
              throw new Error('Reference Products failed to load')
            }
            _this.products = res.responseText.models;
            return _this.reset()
          }
        }(this))['catch'](function (e) {
          return console.log(e.stack)
        })
      };
      ListingWidget.prototype.reset = function () {
        var j, len, listing, matched, product, productId, ref, ref1, ref2, ref3, ref4, ref5;
        this.listings = [];
        if (this.products != null) {
          ref = this.products;
          for (j = 0, len = ref.length; j < len; j++) {
            product = ref[j];
            matched = false;
            if (((ref1 = this.model) != null ? ref1.listings : void 0) != null) {
              ref2 = this.model.listings;
              for (productId in ref2) {
                listing = ref2[productId];
                if (productId === product.id) {
                  this.listings.unshift({
                    productId: product.id,
                    slug: product.slug,
                    price: (ref3 = listing.price) != null ? ref3 : product.price,
                    listPrice: (ref4 = listing.listPrice) != null ? ref4 : product.listPrice,
                    available: (ref5 = listing.available) != null ? ref5 : product.available,
                    show: true
                  });
                  matched = true;
                  break
                }
              }
            }
            if (!matched) {
              this.listings.push({
                productId: product.id,
                slug: product.slug,
                price: product.price,
                listPrice: product.listPrice,
                available: false,
                show: false
              })
            }
          }
          return this.updateModel()
        }
      };
      ListingWidget.prototype.updateModel = function () {
        var j, len, listing, listings, ref;
        this.model.listings = listings = {};
        ref = this.listings;
        for (j = 0, len = ref.length; j < len; j++) {
          listing = ref[j];
          if (listing.show) {
            listings[listing.productId] = listing
          }
        }
        return riot.update()
      };
      ListingWidget.prototype.currency = function () {
        return this.model.currency
      };
      ListingWidget.prototype.changePrice = function (i) {
        return function (_this) {
          return function (event) {
            var val;
            val = $(event.target).val();
            return _this.listings[i].price = util.currency.renderJSONCurrencyFromUI(_this.currency(), val)
          }
        }(this)
      };
      ListingWidget.prototype.changeListPrice = function (i) {
        return function (_this) {
          return function (event) {
            var val;
            val = $(event.target).val();
            return _this.listings[i].listPrice = util.currency.renderJSONCurrencyFromUI(_this.currency(), val)
          }
        }(this)
      };
      ListingWidget.prototype.changeAvailable = function (i) {
        return function (_this) {
          return function (event) {
            var val;
            val = event.target.checked;
            _this.listings[i].available = val;
            if (val) {
              return _this.changeShow(i)(event)
            }
          }
        }(this)
      };
      ListingWidget.prototype.changeShow = function (i) {
        return function (_this) {
          return function (event) {
            var val;
            val = event.target.checked;
            _this.listings[i].show = val;
            if (!val) {
              _this.changeAvailable(i)(event)
            }
            return _this.updateModel()
          }
        }(this)
      };
      return ListingWidget
    }(View);
    ListingWidget.register()
  });
  // source: assets/js/dash/templates/dash/widget/listing/template.html
  rqzt.define('./templates/dash/widget/listing/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="table-viewport mb20">\n  <table class="table table-striped table-responsive table-hover">\n    <thead>\n      <tr>\n        <th>Product&nbsp;</th>\n        <th>Store List Price&nbsp;</th>\n        <th>Store Price&nbsp;</th>\n        <th>In Stock&nbsp;</th>\n        <th>Include in Store*&nbsp;</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr class="animated fadeIn" each="{listing, i in listings}">\n        <td>{listing.slug}</td>\n        <td>\n          <input onchange="{this.parent.changeListPrice(i)}" onblur="{this.parent.changeListPrice(i)}" value="{this.parent.util.currency.renderUICurrencyFromJSON(this.parent.currency(), listing.listPrice)}"></input>\n        </td>\n        <td>\n          <input onchange="{this.parent.changePrice(i)}" onblur="{this.parent.changePrice(i)}" value="{this.parent.util.currency.renderUICurrencyFromJSON(this.parent.currency(), listing.price)}"></input>\n        </td>\n        <td class="text-center">\n          <div class="checkbox-custom checkbox-primary mb5">\n            <input id="available{ i }" name="available{ i }" type="checkbox" onchange="{this.parent.changeAvailable(i)}" onblur="{this.parent.changeShow(i)}" __checked ="{ listing.available }"></input>\n            <label for="available{ i }">&nbsp;</label>\n          </div>\n        </td>\n        <td class="text-center">\n          <div class="checkbox-custom checkbox-primary mb5">\n            <input id="show{ i }" name="show{ i }" type="checkbox" onchange="{this.parent.changeShow(i)}" onblur="{this.parent.changeShow(i)}" __checked ="{ listing.show }"></input>\n            <label for="show{ i }">&nbsp;</label>\n          </div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n<span>*Your changes will be lost if a product is not included in this store, use \'In Stock\' to toggle visibility of a product in this store.</span>\n'
  });
  // source: assets/js/dash/widget/dnd/index.coffee
  rqzt.define('./widget/dnd', function (module, exports, __dirname, __filename, process) {
    var Drag, Drop, Events, View, crowdcontrol, riot, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    riot = rqzt('riot/riot');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    View = crowdcontrol.view.View;
    Drag = function (superClass) {
      extend(Drag, superClass);
      function Drag() {
        return Drag.__super__.constructor.apply(this, arguments)
      }
      Drag.prototype.tag = 'drag';
      Drag.prototype.html = '<div draggable="true"\n  ondragstart="{dragstart}"\n  ondragend="{dragend}"\n  ondrag="{drag}">\n  <yield></yield>\n</div>';
      Drag.prototype.dragstart = function (e) {
        this.obs.trigger('dragstart', e, this.model);
        e.dataTransfer.setData('application/node type', e.target);
        return true
      };
      Drag.prototype.dragend = function (e) {
        this.obs.trigger('dragend', e, this.model);
        return true
      };
      Drag.prototype.drag = function (e) {
        this.obs.trigger('drag', e, this.model);
        return true
      };
      return Drag
    }(View);
    Drag.register();
    Drop = function (superClass) {
      extend(Drop, superClass);
      function Drop() {
        return Drop.__super__.constructor.apply(this, arguments)
      }
      Drop.prototype.tag = 'drop';
      Drop.prototype.html = '<div\n  ondrop="{drop}"\n  ondragover="{dragover}"\n  ondragenter="{dragenter}"\n  ondragleave="{dragleave}">\n  <yield></yield>\n</div>';
      Drop.prototype.drop = function (e) {
        this.obs.trigger('drop', e);
        return true
      };
      Drop.prototype.dragover = function (e) {
        this.obs.trigger('dragover', e);
        e.preventDefault();
        return false
      };
      Drop.prototype.dragenter = function (e) {
        this.obs.trigger('dragenter', e);
        return true
      };
      Drop.prototype.dragleave = function (e) {
        this.obs.trigger('dragleave', e);
        return true
      };
      return Drop
    }(View);
    Drop.register();
    module['export'] = {
      Drag: Drag,
      Drop: Drop
    }
  });
  // source: assets/js/dash/visual/index.coffee
  rqzt.define('./visual', function (module, exports, __dirname, __filename, process) {
    rqzt('./visual/events');
    module.exports = {
      Panel: rqzt('./visual/panel'),
      Chart: rqzt('./visual/chart')
    }
  });
  // source: assets/js/dash/visual/events.coffee
  rqzt.define('./visual/events', function (module, exports, __dirname, __filename, process) {
    var Events, crowdcontrol;
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    Events.Visual = {
      NewData: 'visual-new-data',
      NewDescription: 'visual-new-description',
      NewLabel: 'visual-new-label'
    }
  });
  // source: assets/js/dash/visual/panel/index.coffee
  rqzt.define('./visual/panel', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      NumberPanel: rqzt('./visual/panel/number'),
      MoneyPanel: rqzt('./visual/panel/money')
    }
  });
  // source: assets/js/dash/visual/panel/number.coffee
  rqzt.define('./visual/panel/number', function (module, exports, __dirname, __filename, process) {
    var BasicPanelView, NumberPanel, _, humanize, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    humanize = rqzt('humanize/humanize');
    BasicPanelView = rqzt('./visual/panel/basic');
    NumberPanel = function (superClass) {
      extend(NumberPanel, superClass);
      function NumberPanel() {
        return NumberPanel.__super__.constructor.apply(this, arguments)
      }
      NumberPanel.prototype.tag = 'number-panel';
      NumberPanel.prototype.decimals = 0;
      NumberPanel.prototype.js = function (opts) {
        NumberPanel.__super__.js.apply(this, arguments);
        return this.decimals = opts.decimals || this.decimals || 0
      };
      NumberPanel.prototype.render = function (val) {
        if (!_.isNumber(val)) {
          return 0
        }
        return humanize.numberFormat(val, this.decimals)
      };
      return NumberPanel
    }(BasicPanelView);
    NumberPanel.register();
    module.exports = NumberPanel
  });
  // source: assets/js/dash/visual/panel/basic.coffee
  rqzt.define('./visual/panel/basic', function (module, exports, __dirname, __filename, process) {
    var BasicPanelView, Events, View, crowdcontrol, humanize, spinFrames, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    View = crowdcontrol.view.View;
    humanize = rqzt('humanize/humanize');
    spinFrames = 10;
    BasicPanelView = function (superClass) {
      var obj;
      extend(BasicPanelView, superClass);
      function BasicPanelView() {
        return BasicPanelView.__super__.constructor.apply(this, arguments)
      }
      BasicPanelView.prototype.tag = 'basic-panel';
      BasicPanelView.prototype.label = '';
      BasicPanelView.prototype.description = 'Description';
      BasicPanelView.prototype.html = rqzt('./templates/dash/visual/panel/template');
      BasicPanelView.prototype.events = (obj = {}, obj['' + Events.Visual.NewData] = function () {
        this.loadData.apply(this, arguments);
        return this.update()
      }, obj['' + Events.Visual.NewDescription] = function (description) {
        this.description = description;
        return this.update()
      }, obj['' + Events.Visual.NewLabel] = function (label) {
        this.label = label;
        return this.update()
      }, obj);
      BasicPanelView.prototype.js = function (opts) {
        var ref, ref1;
        this.model = 0;
        this.label = (ref = opts.label) != null ? ref : this.label;
        this.description = (ref1 = opts.description) != null ? ref1 : this.description;
        return this.loadData(this.model, opts.compareModel)
      };
      BasicPanelView.prototype.canCompare = function () {
        return this.compareModel !== 0 && !isNaN(this.compareModel)
      };
      BasicPanelView.prototype.loadData = function (model, compareModel) {
        var deltaSpin, frames, spin, spinActualNumber;
        this.model = model != null ? model : 0;
        this.compareModel = compareModel != null ? compareModel : 0 / 0;
        if (this.canCompare()) {
          this.comparePercent = ((this.model - this.compareModel) / this.compareModel * 100).toFixed(1)
        }
        this.spinNumber = 0;
        if (this.model === 0) {
          this.update();
          return
        }
        spinActualNumber = 0;
        deltaSpin = this.model / spinFrames;
        frames = spinFrames;
        spin = function (_this) {
          return function () {
            return requestAnimationFrame(function () {
              spinActualNumber += deltaSpin;
              _this.spinNumber = parseInt(spinActualNumber, 10);
              _this.update();
              if (frames > 1) {
                frames--;
                return spin()
              }
            })
          }
        }(this);
        return spin()
      };
      BasicPanelView.prototype.render = function (val) {
        return humanize.numberFormat(val)
      };
      return BasicPanelView
    }(View);
    module.exports = BasicPanelView
  });
  // source: assets/js/dash/templates/dash/visual/panel/template.html
  rqzt.define('./templates/dash/visual/panel/template', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel panel-tile text-center br-a br-grey">\n  <div class="panel-body">\n    <h1 class="fs30 mt5 mbn">{ render(spinNumber) }</h1>\n    <h6 class="text-system">{ description }</h6>\n  </div>\n  <div class="panel-footer br-t p12">\n    <span class="fs11 text-info" if="{ canCompare() && comparePercent >= 0 }">\n      <i class="fa fa-arrow-up pr5"></i> { comparePercent }% INCREASE\n      <b>{ label }</b>\n    </span>\n    <span class="fs11 text-danger" if="{ canCompare() && comparePercent < 0 }">\n      <i class="fa fa-arrow-down pr5"></i> { -comparePercent }% DECREASE\n      <b>{ label }</b>\n    </span>\n    <span class="fs11" if="{ !canCompare() }">\n      <b>{ label }</b>\n    </span>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/visual/panel/money.coffee
  rqzt.define('./visual/panel/money', function (module, exports, __dirname, __filename, process) {
    var BasicPanelView, MoneyPanel, _, util, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    BasicPanelView = rqzt('./visual/panel/basic');
    util = rqzt('./util');
    MoneyPanel = function (superClass) {
      extend(MoneyPanel, superClass);
      function MoneyPanel() {
        return MoneyPanel.__super__.constructor.apply(this, arguments)
      }
      MoneyPanel.prototype.tag = 'money-panel';
      MoneyPanel.prototype.html = rqzt('./templates/dash/visual/panel/money');
      MoneyPanel.prototype.decimals = 0;
      MoneyPanel.prototype.loadData = function (model, compareModel, currency) {
        this.currency = currency;
        return MoneyPanel.__super__.loadData.call(this, model, compareModel)
      };
      MoneyPanel.prototype.js = function (opts) {
        MoneyPanel.__super__.js.apply(this, arguments);
        return this.decimals = opts.decimals || this.decimals || 0
      };
      MoneyPanel.prototype.render = function (val) {
        var v;
        v = util.currency.renderUpdatedUICurrency(this.currency, val);
        return v = v.substring(0, v.indexOf('.'))
      };
      return MoneyPanel
    }(BasicPanelView);
    MoneyPanel.register();
    module.exports = MoneyPanel
  });
  // source: assets/js/dash/templates/dash/visual/panel/money.html
  rqzt.define('./templates/dash/visual/panel/money', function (module, exports, __dirname, __filename, process) {
    module.exports = '<div class="panel panel-tile text-center br-a br-grey">\n  <div class="panel-body">\n    <h1 class="fs30 mt5 mbn">{ render(spinNumber) }</h1>\n    <h6 class="text-system">{ description } ({ currency.toUpperCase() })</h6>\n  </div>\n  <div class="panel-footer br-t p12">\n    <span class="fs11 text-info" if="{ canCompare() && comparePercent >= 0 }">\n      <i class="fa fa-arrow-up pr5"></i> { comparePercent }% INCREASE\n      <b>{ label }</b>\n    </span>\n    <span class="fs11 text-danger" if="{ canCompare() && comparePercent < 0 }">\n      <i class="fa fa-arrow-down pr5"></i> { -comparePercent }% DECREASE\n      <b>{ label }</b>\n    </span>\n    <span class="fs11" if="{ !canCompare() }">\n      <b>{ label }</b>\n    </span>\n  </div>\n</div>\n'
  });
  // source: assets/js/dash/visual/chart/index.coffee
  rqzt.define('./visual/chart', function (module, exports, __dirname, __filename, process) {
    module.exports = { Chart: rqzt('./visual/chart/chart') }
  });
  // source: assets/js/dash/visual/chart/chart.coffee
  rqzt.define('./visual/chart/chart', function (module, exports, __dirname, __filename, process) {
    var Chart, ChartJS, Events, View, _, crowdcontrol, extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key]
        }
        function ctor() {
          this.constructor = child
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
        child.__super__ = parent.prototype;
        return child
      }, hasProp = {}.hasOwnProperty;
    _ = rqzt('underscore/underscore');
    ChartJS = rqzt('chart.js/src/chart');
    crowdcontrol = rqzt('crowdcontrol/lib');
    Events = crowdcontrol.Events;
    View = crowdcontrol.view.View;
    Chart = function (superClass) {
      var obj;
      extend(Chart, superClass);
      function Chart() {
        return Chart.__super__.constructor.apply(this, arguments)
      }
      Chart.prototype.tag = 'chart';
      Chart.prototype.title = '';
      Chart.prototype.subtitle = '';
      Chart.prototype.html = '<canvas id="myChart" width="100%" height="400"></canvas>';
      Chart.prototype.model = null;
      /* model looks like:
    xAxis: [{ ...high chart options... }]
    yAxis: [{ ...high chart options... }]
    series: [{
      name: 'name'
      type: 'style'
      data: [ ...data points... ]
      ... other options ...
    }]
   */
      Chart.prototype.events = (obj = {}, obj['' + Events.Visual.NewData] = function (model) {
        this.model = model;
        return this.update()
      }, obj);
      Chart.prototype.js = function (opts) {
        this.title = opts.title || this.title;
        this.subtitle = opts.subtitle || this.subtitle;
        return this.on('update', function (_this) {
          return function () {
            _this.root.children[0].width = $('#content').width() - 80;
            _this.root.children[0].height = 400;
            return _this.refresh()
          }
        }(this))
      };
      Chart.prototype.refresh = function () {
        return this.chart = new ChartJS(this.root.children[0], this.model)
      };
      return Chart
    }(View);
    Chart.register();
    module.exports = Chart
  });
  // source: node_modules/chart.js/src/chart.js
  rqzt.define('chart.js/src/chart', function (module, exports, __dirname, __filename, process) {
    /**
 * @namespace Chart
 */
    var Chart = rqzt('chart.js/src/core/core')();
    rqzt('chart.js/src/core/core.helpers')(Chart);
    rqzt('chart.js/src/core/core.canvasHelpers')(Chart);
    rqzt('chart.js/src/core/core.element')(Chart);
    rqzt('chart.js/src/core/core.animation')(Chart);
    rqzt('chart.js/src/core/core.controller')(Chart);
    rqzt('chart.js/src/core/core.datasetController')(Chart);
    rqzt('chart.js/src/core/core.layoutService')(Chart);
    rqzt('chart.js/src/core/core.scaleService')(Chart);
    rqzt('chart.js/src/core/core.plugin')(Chart);
    rqzt('chart.js/src/core/core.ticks')(Chart);
    rqzt('chart.js/src/core/core.scale')(Chart);
    rqzt('chart.js/src/core/core.title')(Chart);
    rqzt('chart.js/src/core/core.legend')(Chart);
    rqzt('chart.js/src/core/core.interaction')(Chart);
    rqzt('chart.js/src/core/core.tooltip')(Chart);
    rqzt('chart.js/src/elements/element.arc')(Chart);
    rqzt('chart.js/src/elements/element.line')(Chart);
    rqzt('chart.js/src/elements/element.point')(Chart);
    rqzt('chart.js/src/elements/element.rectangle')(Chart);
    rqzt('chart.js/src/scales/scale.linearbase')(Chart);
    rqzt('chart.js/src/scales/scale.category')(Chart);
    rqzt('chart.js/src/scales/scale.linear')(Chart);
    rqzt('chart.js/src/scales/scale.logarithmic')(Chart);
    rqzt('chart.js/src/scales/scale.radialLinear')(Chart);
    rqzt('chart.js/src/scales/scale.time')(Chart);
    // Controllers must be loaded after elements
    // See Chart.core.datasetController.dataElementType
    rqzt('chart.js/src/controllers/controller.bar')(Chart);
    rqzt('chart.js/src/controllers/controller.bubble')(Chart);
    rqzt('chart.js/src/controllers/controller.doughnut')(Chart);
    rqzt('chart.js/src/controllers/controller.line')(Chart);
    rqzt('chart.js/src/controllers/controller.polarArea')(Chart);
    rqzt('chart.js/src/controllers/controller.radar')(Chart);
    rqzt('chart.js/src/charts/Chart.Bar')(Chart);
    rqzt('chart.js/src/charts/Chart.Bubble')(Chart);
    rqzt('chart.js/src/charts/Chart.Doughnut')(Chart);
    rqzt('chart.js/src/charts/Chart.Line')(Chart);
    rqzt('chart.js/src/charts/Chart.PolarArea')(Chart);
    rqzt('chart.js/src/charts/Chart.Radar')(Chart);
    rqzt('chart.js/src/charts/Chart.Scatter')(Chart);
    window.Chart = module.exports = Chart
  });
  // source: node_modules/chart.js/src/core/core.js
  rqzt.define('chart.js/src/core/core', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function () {
      // Occupy the global variable of Chart, and create a simple base class
      var Chart = function (item, config) {
        this.controller = new Chart.Controller(item, config, this);
        return this.controller
      };
      // Globally expose the defaults to allow for user updating/changing
      Chart.defaults = {
        global: {
          responsive: true,
          responsiveAnimationDuration: 0,
          maintainAspectRatio: true,
          events: [
            'mousemove',
            'mouseout',
            'click',
            'touchstart',
            'touchmove'
          ],
          hover: {
            onHover: null,
            mode: 'nearest',
            intersect: true,
            animationDuration: 400
          },
          onClick: null,
          defaultColor: 'rgba(0,0,0,0.1)',
          defaultFontColor: '#666',
          defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          defaultFontSize: 12,
          defaultFontStyle: 'normal',
          showLines: true,
          // Element defaults defined in element extensions
          elements: {},
          // Legend callback string
          legendCallback: function (chart) {
            var text = [];
            text.push('<ul class="' + chart.id + '-legend">');
            for (var i = 0; i < chart.data.datasets.length; i++) {
              text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
              if (chart.data.datasets[i].label) {
                text.push(chart.data.datasets[i].label)
              }
              text.push('</li>')
            }
            text.push('</ul>');
            return text.join('')
          }
        }
      };
      Chart.Chart = Chart;
      return Chart
    }
  });
  // source: node_modules/chart.js/src/core/core.helpers.js
  rqzt.define('chart.js/src/core/core.helpers', function (module, exports, __dirname, __filename, process) {
    /* global window: false */
    /* global document: false */
    'use strict';
    var color = rqzt('chartjs-color');
    module.exports = function (Chart) {
      // Global Chart helpers object for utility methods and classes
      var helpers = Chart.helpers = {};
      // -- Basic js utility methods
      helpers.each = function (loopable, callback, self, reverse) {
        // Check to see if null or undefined firstly.
        var i, len;
        if (helpers.isArray(loopable)) {
          len = loopable.length;
          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              callback.call(self, loopable[i], i)
            }
          } else {
            for (i = 0; i < len; i++) {
              callback.call(self, loopable[i], i)
            }
          }
        } else if (typeof loopable === 'object') {
          var keys = Object.keys(loopable);
          len = keys.length;
          for (i = 0; i < len; i++) {
            callback.call(self, loopable[keys[i]], keys[i])
          }
        }
      };
      helpers.clone = function (obj) {
        var objClone = {};
        helpers.each(obj, function (value, key) {
          if (helpers.isArray(value)) {
            objClone[key] = value.slice(0)
          } else if (typeof value === 'object' && value !== null) {
            objClone[key] = helpers.clone(value)
          } else {
            objClone[key] = value
          }
        });
        return objClone
      };
      helpers.extend = function (base) {
        var setFn = function (value, key) {
          base[key] = value
        };
        for (var i = 1, ilen = arguments.length; i < ilen; i++) {
          helpers.each(arguments[i], setFn)
        }
        return base
      };
      // Need a special merge function to chart configs since they are now grouped
      helpers.configMerge = function (_base) {
        var base = helpers.clone(_base);
        helpers.each(Array.prototype.slice.call(arguments, 1), function (extension) {
          helpers.each(extension, function (value, key) {
            var baseHasProperty = base.hasOwnProperty(key);
            var baseVal = baseHasProperty ? base[key] : {};
            if (key === 'scales') {
              // Scale config merging is complex. Add our own function here for that
              base[key] = helpers.scaleMerge(baseVal, value)
            } else if (key === 'scale') {
              // Used in polar area & radar charts since there is only one scale
              base[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value)
            } else if (baseHasProperty && typeof baseVal === 'object' && !helpers.isArray(baseVal) && baseVal !== null && typeof value === 'object' && !helpers.isArray(value)) {
              // If we are overwriting an object with an object, do a merge of the properties.
              base[key] = helpers.configMerge(baseVal, value)
            } else {
              // can just overwrite the value in this case
              base[key] = value
            }
          })
        });
        return base
      };
      helpers.scaleMerge = function (_base, extension) {
        var base = helpers.clone(_base);
        helpers.each(extension, function (value, key) {
          if (key === 'xAxes' || key === 'yAxes') {
            // These properties are arrays of items
            if (base.hasOwnProperty(key)) {
              helpers.each(value, function (valueObj, index) {
                var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
                var axisDefaults = Chart.scaleService.getScaleDefaults(axisType);
                if (index >= base[key].length || !base[key][index].type) {
                  base[key].push(helpers.configMerge(axisDefaults, valueObj))
                } else if (valueObj.type && valueObj.type !== base[key][index].type) {
                  // Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults
                  base[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj)
                } else {
                  // Type is the same
                  base[key][index] = helpers.configMerge(base[key][index], valueObj)
                }
              })
            } else {
              base[key] = [];
              helpers.each(value, function (valueObj) {
                var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
                base[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj))
              })
            }
          } else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {
            // If we are overwriting an object with an object, do a merge of the properties.
            base[key] = helpers.configMerge(base[key], value)
          } else {
            // can just overwrite the value in this case
            base[key] = value
          }
        });
        return base
      };
      helpers.getValueAtIndexOrDefault = function (value, index, defaultValue) {
        if (value === undefined || value === null) {
          return defaultValue
        }
        if (helpers.isArray(value)) {
          return index < value.length ? value[index] : defaultValue
        }
        return value
      };
      helpers.getValueOrDefault = function (value, defaultValue) {
        return value === undefined ? defaultValue : value
      };
      helpers.indexOf = Array.prototype.indexOf ? function (array, item) {
        return array.indexOf(item)
      } : function (array, item) {
        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (array[i] === item) {
            return i
          }
        }
        return -1
      };
      helpers.where = function (collection, filterCallback) {
        if (helpers.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback)
        }
        var filtered = [];
        helpers.each(collection, function (item) {
          if (filterCallback(item)) {
            filtered.push(item)
          }
        });
        return filtered
      };
      helpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
        return array.findIndex(callback, scope)
      } : function (array, callback, scope) {
        scope = scope === undefined ? array : scope;
        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i
          }
        }
        return -1
      };
      helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to start of the array
        if (startIndex === undefined || startIndex === null) {
          startIndex = -1
        }
        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];
          if (filterCallback(currentItem)) {
            return currentItem
          }
        }
      };
      helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to end of the array
        if (startIndex === undefined || startIndex === null) {
          startIndex = arrayToSearch.length
        }
        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];
          if (filterCallback(currentItem)) {
            return currentItem
          }
        }
      };
      helpers.inherits = function (extensions) {
        // Basic javascript inheritance based on the model created in Backbone.js
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
          return me.apply(this, arguments)
        };
        var Surrogate = function () {
          this.constructor = ChartElement
        };
        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate;
        ChartElement.extend = helpers.inherits;
        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions)
        }
        ChartElement.__super__ = me.prototype;
        return ChartElement
      };
      helpers.noop = function () {
      };
      helpers.uid = function () {
        var id = 0;
        return function () {
          return id++
        }
      }();
      // -- Math methods
      helpers.isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n)
      };
      helpers.almostEquals = function (x, y, epsilon) {
        return Math.abs(x - y) < epsilon
      };
      helpers.max = function (array) {
        return array.reduce(function (max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value)
          }
          return max
        }, Number.NEGATIVE_INFINITY)
      };
      helpers.min = function (array) {
        return array.reduce(function (min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value)
          }
          return min
        }, Number.POSITIVE_INFINITY)
      };
      helpers.sign = Math.sign ? function (x) {
        return Math.sign(x)
      } : function (x) {
        x = +x;
        // convert to a number
        if (x === 0 || isNaN(x)) {
          return x
        }
        return x > 0 ? 1 : -1
      };
      helpers.log10 = Math.log10 ? function (x) {
        return Math.log10(x)
      } : function (x) {
        return Math.log(x) / Math.LN10
      };
      helpers.toRadians = function (degrees) {
        return degrees * (Math.PI / 180)
      };
      helpers.toDegrees = function (radians) {
        return radians * (180 / Math.PI)
      };
      // Gets the angle from vertical upright to the point about a centre.
      helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x, distanceFromYCenter = anglePoint.y - centrePoint.y, radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
        if (angle < -0.5 * Math.PI) {
          angle += 2 * Math.PI  // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }
        return {
          angle: angle,
          distance: radialDistanceFromCenter
        }
      };
      helpers.distanceBetweenPoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2))
      };
      helpers.aliasPixel = function (pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5
      };
      helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        var previous = firstPoint.skip ? middlePoint : firstPoint, current = middlePoint, next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12);
        // If all points are the same, s01 & s02 will be inf
        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01;
        // scaling factor for triangle Ta
        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        }
      };
      helpers.EPSILON = Number.EPSILON || 1e-14;
      helpers.splineCurveMonotone = function (points) {
        // This function calculates Bézier control points in a similar way than |splineCurve|,
        // but preserves monotonicity of the provided data and ensures no local extremums are added
        // between the dataset discrete points due to the interpolation.
        // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
        var pointsWithTangents = (points || []).map(function (point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          }
        });
        // Calculate slopes (deltaK) and initialize tangents (mK)
        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;
        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];
          if (pointCurrent.model.skip) {
            continue
          }
          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
          if (pointAfter && !pointAfter.model.skip) {
            pointCurrent.deltaK = (pointAfter.model.y - pointCurrent.model.y) / (pointAfter.model.x - pointCurrent.model.x)
          }
          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2
          }
        }
        // Adjust tangents to ensure monotonic properties
        var alphaK, betaK, tauK, squaredMagnitude;
        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];
          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue
          }
          if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue
          }
          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
          if (squaredMagnitude <= 9) {
            continue
          }
          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK
        }
        // Compute control points
        var deltaX;
        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];
          if (pointCurrent.model.skip) {
            continue
          }
          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK
          }
          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK
          }
        }
      };
      helpers.nextItem = function (collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1]
        }
        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1]
      };
      helpers.previousItem = function (collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1]
        }
        return index <= 0 ? collection[0] : collection[index - 1]
      };
      // Implementation of the nice number algorithm used in determining where axis labels will go
      helpers.niceNum = function (range, round) {
        var exponent = Math.floor(helpers.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;
        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1
          } else if (fraction < 3) {
            niceFraction = 2
          } else if (fraction < 7) {
            niceFraction = 5
          } else {
            niceFraction = 10
          }
        } else if (fraction <= 1) {
          niceFraction = 1
        } else if (fraction <= 2) {
          niceFraction = 2
        } else if (fraction <= 5) {
          niceFraction = 5
        } else {
          niceFraction = 10
        }
        return niceFraction * Math.pow(10, exponent)
      };
      // Easing functions adapted from Robert Penner's easing equations
      // http://www.robertpenner.com/easing/
      var easingEffects = helpers.easingEffects = {
        linear: function (t) {
          return t
        },
        easeInQuad: function (t) {
          return t * t
        },
        easeOutQuad: function (t) {
          return -1 * t * (t - 2)
        },
        easeInOutQuad: function (t) {
          if ((t /= 1 / 2) < 1) {
            return 1 / 2 * t * t
          }
          return -1 / 2 * (--t * (t - 2) - 1)
        },
        easeInCubic: function (t) {
          return t * t * t
        },
        easeOutCubic: function (t) {
          return 1 * ((t = t / 1 - 1) * t * t + 1)
        },
        easeInOutCubic: function (t) {
          if ((t /= 1 / 2) < 1) {
            return 1 / 2 * t * t * t
          }
          return 1 / 2 * ((t -= 2) * t * t + 2)
        },
        easeInQuart: function (t) {
          return t * t * t * t
        },
        easeOutQuart: function (t) {
          return -1 * ((t = t / 1 - 1) * t * t * t - 1)
        },
        easeInOutQuart: function (t) {
          if ((t /= 1 / 2) < 1) {
            return 1 / 2 * t * t * t * t
          }
          return -1 / 2 * ((t -= 2) * t * t * t - 2)
        },
        easeInQuint: function (t) {
          return 1 * (t /= 1) * t * t * t * t
        },
        easeOutQuint: function (t) {
          return 1 * ((t = t / 1 - 1) * t * t * t * t + 1)
        },
        easeInOutQuint: function (t) {
          if ((t /= 1 / 2) < 1) {
            return 1 / 2 * t * t * t * t * t
          }
          return 1 / 2 * ((t -= 2) * t * t * t * t + 2)
        },
        easeInSine: function (t) {
          return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1
        },
        easeOutSine: function (t) {
          return 1 * Math.sin(t / 1 * (Math.PI / 2))
        },
        easeInOutSine: function (t) {
          return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1)
        },
        easeInExpo: function (t) {
          return t === 0 ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1))
        },
        easeOutExpo: function (t) {
          return t === 1 ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1)
        },
        easeInOutExpo: function (t) {
          if (t === 0) {
            return 0
          }
          if (t === 1) {
            return 1
          }
          if ((t /= 1 / 2) < 1) {
            return 1 / 2 * Math.pow(2, 10 * (t - 1))
          }
          return 1 / 2 * (-Math.pow(2, -10 * --t) + 2)
        },
        easeInCirc: function (t) {
          if (t >= 1) {
            return t
          }
          return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1)
        },
        easeOutCirc: function (t) {
          return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t)
        },
        easeInOutCirc: function (t) {
          if ((t /= 1 / 2) < 1) {
            return -1 / 2 * (Math.sqrt(1 - t * t) - 1)
          }
          return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1)
        },
        easeInElastic: function (t) {
          var s = 1.70158;
          var p = 0;
          var a = 1;
          if (t === 0) {
            return 0
          }
          if ((t /= 1) === 1) {
            return 1
          }
          if (!p) {
            p = 1 * 0.3
          }
          if (a < Math.abs(1)) {
            a = 1;
            s = p / 4
          } else {
            s = p / (2 * Math.PI) * Math.asin(1 / a)
          }
          return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p))
        },
        easeOutElastic: function (t) {
          var s = 1.70158;
          var p = 0;
          var a = 1;
          if (t === 0) {
            return 0
          }
          if ((t /= 1) === 1) {
            return 1
          }
          if (!p) {
            p = 1 * 0.3
          }
          if (a < Math.abs(1)) {
            a = 1;
            s = p / 4
          } else {
            s = p / (2 * Math.PI) * Math.asin(1 / a)
          }
          return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1
        },
        easeInOutElastic: function (t) {
          var s = 1.70158;
          var p = 0;
          var a = 1;
          if (t === 0) {
            return 0
          }
          if ((t /= 1 / 2) === 2) {
            return 1
          }
          if (!p) {
            p = 1 * (0.3 * 1.5)
          }
          if (a < Math.abs(1)) {
            a = 1;
            s = p / 4
          } else {
            s = p / (2 * Math.PI) * Math.asin(1 / a)
          }
          if (t < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p))
          }
          return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1
        },
        easeInBack: function (t) {
          var s = 1.70158;
          return 1 * (t /= 1) * t * ((s + 1) * t - s)
        },
        easeOutBack: function (t) {
          var s = 1.70158;
          return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1)
        },
        easeInOutBack: function (t) {
          var s = 1.70158;
          if ((t /= 1 / 2) < 1) {
            return 1 / 2 * (t * t * (((s *= 1.525) + 1) * t - s))
          }
          return 1 / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2)
        },
        easeInBounce: function (t) {
          return 1 - easingEffects.easeOutBounce(1 - t)
        },
        easeOutBounce: function (t) {
          if ((t /= 1) < 1 / 2.75) {
            return 1 * (7.5625 * t * t)
          } else if (t < 2 / 2.75) {
            return 1 * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75)
          } else if (t < 2.5 / 2.75) {
            return 1 * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375)
          }
          return 1 * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375)
        },
        easeInOutBounce: function (t) {
          if (t < 1 / 2) {
            return easingEffects.easeInBounce(t * 2) * 0.5
          }
          return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5
        }
      };
      // Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
      helpers.requestAnimFrame = function () {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
          return window.setTimeout(callback, 1000 / 60)
        }
      }();
      helpers.cancelAnimFrame = function () {
        return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (callback) {
          return window.clearTimeout(callback, 1000 / 60)
        }
      }();
      // -- DOM methods
      helpers.getRelativePosition = function (evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt, canvas = evt.currentTarget || evt.srcElement, boundingRect = canvas.getBoundingClientRect();
        var touches = e.touches;
        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY
        }
        // Scale mouse coordinates into canvas coordinates
        // by following the pattern laid out by 'jerryj' in the comments of
        // http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
        var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
        var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
        var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
        var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
        // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
        // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        }
      };
      helpers.addEvent = function (node, eventType, method) {
        if (node.addEventListener) {
          node.addEventListener(eventType, method)
        } else if (node.attachEvent) {
          node.attachEvent('on' + eventType, method)
        } else {
          node['on' + eventType] = method
        }
      };
      helpers.removeEvent = function (node, eventType, handler) {
        if (node.removeEventListener) {
          node.removeEventListener(eventType, handler, false)
        } else if (node.detachEvent) {
          node.detachEvent('on' + eventType, handler)
        } else {
          node['on' + eventType] = helpers.noop
        }
      };
      helpers.bindEvents = function (chartInstance, arrayOfEvents, handler) {
        // Create the events object if it's not already present
        var events = chartInstance.events = chartInstance.events || {};
        helpers.each(arrayOfEvents, function (eventName) {
          events[eventName] = function () {
            handler.apply(chartInstance, arguments)
          };
          helpers.addEvent(chartInstance.chart.canvas, eventName, events[eventName])
        })
      };
      helpers.unbindEvents = function (chartInstance, arrayOfEvents) {
        var canvas = chartInstance.chart.canvas;
        helpers.each(arrayOfEvents, function (handler, eventName) {
          helpers.removeEvent(canvas, eventName, handler)
        })
      };
      // Private helper function to convert max-width/max-height values that may be percentages into a number
      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;
        if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);
          if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty]
          }
        } else {
          valueInPixels = styleValue
        }
        return valueInPixels
      }
      /**
	 * Returns if the given value contains an effective constraint.
	 * @private
	 */
      function isConstrainedValue(value) {
        return value !== undefined && value !== null && value !== 'none'
      }
      // Private helper to get a constraint dimension
      // @param domNode : the node to check the constraint on
      // @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
      // @param percentageProperty : property of parent to use when calculating width as a percentage
      // @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;
        var parentNode = domNode.parentNode;
        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;
        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity)
        }
        return 'none'
      }
      // returns Number or undefined if no constraint
      helpers.getConstraintWidth = function (domNode) {
        return getConstraintDimension(domNode, 'max-width', 'clientWidth')
      };
      // returns Number or undefined if no constraint
      helpers.getConstraintHeight = function (domNode) {
        return getConstraintDimension(domNode, 'max-height', 'clientHeight')
      };
      helpers.getMaximumWidth = function (domNode) {
        var container = domNode.parentNode;
        var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
        var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
        var w = container.clientWidth - paddingLeft - paddingRight;
        var cw = helpers.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw)
      };
      helpers.getMaximumHeight = function (domNode) {
        var container = domNode.parentNode;
        var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
        var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
        var h = container.clientHeight - paddingTop - paddingBottom;
        var ch = helpers.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch)
      };
      helpers.getStyle = function (el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property)
      };
      helpers.retinaScale = function (chart) {
        var pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;
        if (pixelRatio === 1) {
          return
        }
        var canvas = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas.height = height * pixelRatio;
        canvas.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio);
        // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575
        canvas.style.height = height + 'px';
        canvas.style.width = width + 'px'
      };
      // -- Canvas methods
      helpers.clear = function (chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height)
      };
      helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily
      };
      helpers.longestText = function (ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];
        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font
        }
        ctx.font = font;
        var longest = 0;
        helpers.each(arrayOfThings, function (thing) {
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
            longest = helpers.measureText(ctx, data, gc, longest, thing)
          } else if (helpers.isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            helpers.each(thing, function (nestedThing) {
              // Undefined strings and arrays should not be measured
              if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
                longest = helpers.measureText(ctx, data, gc, longest, nestedThing)
              }
            })
          }
        });
        var gcLen = gc.length / 2;
        if (gcLen > arrayOfThings.length) {
          for (var i = 0; i < gcLen; i++) {
            delete data[gc[i]]
          }
          gc.splice(0, gcLen)
        }
        return longest
      };
      helpers.measureText = function (ctx, data, gc, longest, string) {
        var textWidth = data[string];
        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string)
        }
        if (textWidth > longest) {
          longest = textWidth
        }
        return longest
      };
      helpers.numberOfLabelLines = function (arrayOfThings) {
        var numberOfLines = 1;
        helpers.each(arrayOfThings, function (thing) {
          if (helpers.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length
            }
          }
        });
        return numberOfLines
      };
      helpers.drawRoundedRectangle = function (ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath()
      };
      helpers.color = function (c) {
        if (!color) {
          console.error('Color.js not found!');
          return c
        }
        /* global CanvasGradient */
        if (c instanceof CanvasGradient) {
          return color(Chart.defaults.global.defaultColor)
        }
        return color(c)
      };
      helpers.addResizeListener = function (node, callback) {
        var iframe = document.createElement('iframe');
        iframe.className = 'chartjs-hidden-iframe';
        iframe.style.cssText = 'display:block;' + 'overflow:hidden;' + 'border:0;' + 'margin:0;' + 'top:0;' + 'left:0;' + 'bottom:0;' + 'right:0;' + 'height:100%;' + 'width:100%;' + 'position:absolute;' + 'pointer-events:none;' + 'z-index:-1;';
        // Prevent the iframe to gain focus on tab.
        // https://github.com/chartjs/Chart.js/issues/3090
        iframe.tabIndex = -1;
        // Let's keep track of this added iframe and thus avoid DOM query when removing it.
        var stub = node._chartjs = {
          resizer: iframe,
          ticking: false
        };
        // Throttle the callback notification until the next animation frame.
        var notify = function () {
          if (!stub.ticking) {
            stub.ticking = true;
            helpers.requestAnimFrame.call(window, function () {
              if (stub.resizer) {
                stub.ticking = false;
                return callback()
              }
            })
          }
        };
        // If the iframe is re-attached to the DOM, the resize listener is removed because the
        // content is reloaded, so make sure to install the handler after the iframe is loaded.
        // https://github.com/chartjs/Chart.js/issues/3521
        helpers.addEvent(iframe, 'load', function () {
          helpers.addEvent(iframe.contentWindow || iframe, 'resize', notify);
          // The iframe size might have changed while loading, which can also
          // happen if the size has been changed while detached from the DOM.
          notify()
        });
        node.insertBefore(iframe, node.firstChild)
      };
      helpers.removeResizeListener = function (node) {
        if (!node || !node._chartjs) {
          return
        }
        var iframe = node._chartjs.resizer;
        if (iframe) {
          iframe.parentNode.removeChild(iframe);
          node._chartjs.resizer = null
        }
        delete node._chartjs
      };
      helpers.isArray = Array.isArray ? function (obj) {
        return Array.isArray(obj)
      } : function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]'
      };
      // ! @see http://stackoverflow.com/a/14853974
      helpers.arrayEquals = function (a0, a1) {
        var i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) {
          return false
        }
        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];
          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false
            }
          } else if (v0 !== v1) {
            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
            return false
          }
        }
        return true
      };
      helpers.callCallback = function (fn, args, _tArg) {
        if (fn && typeof fn.call === 'function') {
          fn.apply(_tArg, args)
        }
      };
      helpers.getHoverColor = function (colorValue) {
        /* global CanvasPattern */
        return colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString()
      }
    }
  });
  // source: node_modules/chartjs-color/index.js
  rqzt.define('chartjs-color', function (module, exports, __dirname, __filename, process) {
    /* MIT license */
    var convert = rqzt('color-convert');
    var string = rqzt('chartjs-color-string/color-string');
    var Color = function (obj) {
      if (obj instanceof Color) {
        return obj
      }
      if (!(this instanceof Color)) {
        return new Color(obj)
      }
      this.values = {
        rgb: [
          0,
          0,
          0
        ],
        hsl: [
          0,
          0,
          0
        ],
        hsv: [
          0,
          0,
          0
        ],
        hwb: [
          0,
          0,
          0
        ],
        cmyk: [
          0,
          0,
          0,
          0
        ],
        alpha: 1
      };
      // parse Color() argument
      var vals;
      if (typeof obj === 'string') {
        vals = string.getRgba(obj);
        if (vals) {
          this.setValues('rgb', vals)
        } else if (vals = string.getHsla(obj)) {
          this.setValues('hsl', vals)
        } else if (vals = string.getHwb(obj)) {
          this.setValues('hwb', vals)
        } else {
          throw new Error('Unable to parse color from string "' + obj + '"')
        }
      } else if (typeof obj === 'object') {
        vals = obj;
        if (vals.r !== undefined || vals.red !== undefined) {
          this.setValues('rgb', vals)
        } else if (vals.l !== undefined || vals.lightness !== undefined) {
          this.setValues('hsl', vals)
        } else if (vals.v !== undefined || vals.value !== undefined) {
          this.setValues('hsv', vals)
        } else if (vals.w !== undefined || vals.whiteness !== undefined) {
          this.setValues('hwb', vals)
        } else if (vals.c !== undefined || vals.cyan !== undefined) {
          this.setValues('cmyk', vals)
        } else {
          throw new Error('Unable to parse color from object ' + JSON.stringify(obj))
        }
      }
    };
    Color.prototype = {
      rgb: function () {
        return this.setSpace('rgb', arguments)
      },
      hsl: function () {
        return this.setSpace('hsl', arguments)
      },
      hsv: function () {
        return this.setSpace('hsv', arguments)
      },
      hwb: function () {
        return this.setSpace('hwb', arguments)
      },
      cmyk: function () {
        return this.setSpace('cmyk', arguments)
      },
      rgbArray: function () {
        return this.values.rgb
      },
      hslArray: function () {
        return this.values.hsl
      },
      hsvArray: function () {
        return this.values.hsv
      },
      hwbArray: function () {
        var values = this.values;
        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha])
        }
        return values.hwb
      },
      cmykArray: function () {
        return this.values.cmyk
      },
      rgbaArray: function () {
        var values = this.values;
        return values.rgb.concat([values.alpha])
      },
      hslaArray: function () {
        var values = this.values;
        return values.hsl.concat([values.alpha])
      },
      alpha: function (val) {
        if (val === undefined) {
          return this.values.alpha
        }
        this.setValues('alpha', val);
        return this
      },
      red: function (val) {
        return this.setChannel('rgb', 0, val)
      },
      green: function (val) {
        return this.setChannel('rgb', 1, val)
      },
      blue: function (val) {
        return this.setChannel('rgb', 2, val)
      },
      hue: function (val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val
        }
        return this.setChannel('hsl', 0, val)
      },
      saturation: function (val) {
        return this.setChannel('hsl', 1, val)
      },
      lightness: function (val) {
        return this.setChannel('hsl', 2, val)
      },
      saturationv: function (val) {
        return this.setChannel('hsv', 1, val)
      },
      whiteness: function (val) {
        return this.setChannel('hwb', 1, val)
      },
      blackness: function (val) {
        return this.setChannel('hwb', 2, val)
      },
      value: function (val) {
        return this.setChannel('hsv', 2, val)
      },
      cyan: function (val) {
        return this.setChannel('cmyk', 0, val)
      },
      magenta: function (val) {
        return this.setChannel('cmyk', 1, val)
      },
      yellow: function (val) {
        return this.setChannel('cmyk', 2, val)
      },
      black: function (val) {
        return this.setChannel('cmyk', 3, val)
      },
      hexString: function () {
        return string.hexString(this.values.rgb)
      },
      rgbString: function () {
        return string.rgbString(this.values.rgb, this.values.alpha)
      },
      rgbaString: function () {
        return string.rgbaString(this.values.rgb, this.values.alpha)
      },
      percentString: function () {
        return string.percentString(this.values.rgb, this.values.alpha)
      },
      hslString: function () {
        return string.hslString(this.values.hsl, this.values.alpha)
      },
      hslaString: function () {
        return string.hslaString(this.values.hsl, this.values.alpha)
      },
      hwbString: function () {
        return string.hwbString(this.values.hwb, this.values.alpha)
      },
      keyword: function () {
        return string.keyword(this.values.rgb, this.values.alpha)
      },
      rgbNumber: function () {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2]
      },
      luminosity: function () {
        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
        var rgb = this.values.rgb;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4)
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2]
      },
      contrast: function (color2) {
        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05)
        }
        return (lum2 + 0.05) / (lum1 + 0.05)
      },
      level: function (color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return 'AAA'
        }
        return contrastRatio >= 4.5 ? 'AA' : ''
      },
      dark: function () {
        // YIQ equation from http://24ways.org/2010/calculating-color-contrast
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        return yiq < 128
      },
      light: function () {
        return !this.dark()
      },
      negate: function () {
        var rgb = [];
        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i]
        }
        this.setValues('rgb', rgb);
        return this
      },
      lighten: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this
      },
      darken: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this
      },
      saturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this
      },
      desaturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this
      },
      whiten: function (ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues('hwb', hwb);
        return this
      },
      blacken: function (ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues('hwb', hwb);
        return this
      },
      greyscale: function () {
        var rgb = this.values.rgb;
        // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues('rgb', [
          val,
          val,
          val
        ]);
        return this
      },
      clearer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha - alpha * ratio);
        return this
      },
      opaquer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha + alpha * ratio);
        return this
      },
      rotate: function (degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues('hsl', hsl);
        return this
      },
      /**
	 * Ported from sass implementation in C
	 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
	 */
      mix: function (mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === undefined ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p))
      },
      toJSON: function () {
        return this.rgb()
      },
      clone: function () {
        // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
        // making the final build way to big to embed in Chart.js. So let's do it manually,
        // assuming that values to clone are 1 dimension arrays containing only numbers,
        // except 'alpha' which is a number.
        var result = new Color;
        var source = this.values;
        var target = result.values;
        var value, type;
        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);
            if (type === '[object Array]') {
              target[prop] = value.slice(0)
            } else if (type === '[object Number]') {
              target[prop] = value
            } else {
              console.error('unexpected color value:', value)
            }
          }
        }
        return result
      }
    };
    Color.prototype.spaces = {
      rgb: [
        'red',
        'green',
        'blue'
      ],
      hsl: [
        'hue',
        'saturation',
        'lightness'
      ],
      hsv: [
        'hue',
        'saturation',
        'value'
      ],
      hwb: [
        'hue',
        'whiteness',
        'blackness'
      ],
      cmyk: [
        'cyan',
        'magenta',
        'yellow',
        'black'
      ]
    };
    Color.prototype.maxes = {
      rgb: [
        255,
        255,
        255
      ],
      hsl: [
        360,
        100,
        100
      ],
      hsv: [
        360,
        100,
        100
      ],
      hwb: [
        360,
        100,
        100
      ],
      cmyk: [
        100,
        100,
        100,
        100
      ]
    };
    Color.prototype.getValues = function (space) {
      var values = this.values;
      var vals = {};
      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i]
      }
      if (values.alpha !== 1) {
        vals.a = values.alpha
      }
      // {r: 255, g: 255, b: 255, a: 0.4}
      return vals
    };
    Color.prototype.setValues = function (space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      if (space === 'alpha') {
        alpha = vals
      } else if (vals.length) {
        // [10, 10, 10]
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length]
      } else if (vals[space.charAt(0)] !== undefined) {
        // {r: 10, g: 10, b: 10}
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)]
        }
        alpha = vals.a
      } else if (vals[spaces[space][0]] !== undefined) {
        // {red: 10, green: 10, blue: 10}
        var chans = spaces[space];
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]]
        }
        alpha = vals.alpha
      }
      values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));
      if (space === 'alpha') {
        return false
      }
      var capped;
      // cap values of the space prior converting all values
      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped)
      }
      // convert to all the other color spaces
      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = convert[space][sname](values[space])
        }
      }
      return true
    };
    Color.prototype.setSpace = function (space, args) {
      var vals = args[0];
      if (vals === undefined) {
        // color.rgb()
        return this.getValues(space)
      }
      // color.rgb(10, 10, 10)
      if (typeof vals === 'number') {
        vals = Array.prototype.slice.call(args)
      }
      this.setValues(space, vals);
      return this
    };
    Color.prototype.setChannel = function (space, index, val) {
      var svalues = this.values[space];
      if (val === undefined) {
        // color.red()
        return svalues[index]
      } else if (val === svalues[index]) {
        // color.red(color.red())
        return this
      }
      // color.red(100)
      svalues[index] = val;
      this.setValues(space, svalues);
      return this
    };
    if (typeof window !== 'undefined') {
      window.Color = Color
    }
    module.exports = Color
  });
  // source: node_modules/color-convert/index.js
  rqzt.define('color-convert', function (module, exports, __dirname, __filename, process) {
    var conversions = rqzt('color-convert/conversions');
    var convert = function () {
      return new Converter
    };
    for (var func in conversions) {
      // export Raw versions
      convert[func + 'Raw'] = function (func) {
        // accept array or plain args
        return function (arg) {
          if (typeof arg == 'number')
            arg = Array.prototype.slice.call(arguments);
          return conversions[func](arg)
        }
      }(func);
      var pair = /(\w+)2(\w+)/.exec(func), from = pair[1], to = pair[2];
      // export rgb2hsl and ["rgb"]["hsl"]
      convert[from] = convert[from] || {};
      convert[from][to] = convert[func] = function (func) {
        return function (arg) {
          if (typeof arg == 'number')
            arg = Array.prototype.slice.call(arguments);
          var val = conversions[func](arg);
          if (typeof val == 'string' || val === undefined)
            return val;
          // keyword
          for (var i = 0; i < val.length; i++)
            val[i] = Math.round(val[i]);
          return val
        }
      }(func)
    }
    /* Converter does lazy conversion and caching */
    var Converter = function () {
      this.convs = {}
    };
    /* Either get the values for a space or
  set the values for a space, depending on args */
    Converter.prototype.routeSpace = function (space, args) {
      var values = args[0];
      if (values === undefined) {
        // color.rgb()
        return this.getValues(space)
      }
      // color.rgb(10, 10, 10)
      if (typeof values == 'number') {
        values = Array.prototype.slice.call(args)
      }
      return this.setValues(space, values)
    };
    /* Set the values for a space, invalidating cache */
    Converter.prototype.setValues = function (space, values) {
      this.space = space;
      this.convs = {};
      this.convs[space] = values;
      return this
    };
    /* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
    Converter.prototype.getValues = function (space) {
      var vals = this.convs[space];
      if (!vals) {
        var fspace = this.space, from = this.convs[fspace];
        vals = convert[fspace][space](from);
        this.convs[space] = vals
      }
      return vals
    };
    [
      'rgb',
      'hsl',
      'hsv',
      'cmyk',
      'keyword'
    ].forEach(function (space) {
      Converter.prototype[space] = function (vals) {
        return this.routeSpace(space, arguments)
      }
    });
    module.exports = convert
  });
  // source: node_modules/color-convert/conversions.js
  rqzt.define('color-convert/conversions', function (module, exports, __dirname, __filename, process) {
    /* MIT license */
    module.exports = {
      rgb2hsl: rgb2hsl,
      rgb2hsv: rgb2hsv,
      rgb2hwb: rgb2hwb,
      rgb2cmyk: rgb2cmyk,
      rgb2keyword: rgb2keyword,
      rgb2xyz: rgb2xyz,
      rgb2lab: rgb2lab,
      rgb2lch: rgb2lch,
      hsl2rgb: hsl2rgb,
      hsl2hsv: hsl2hsv,
      hsl2hwb: hsl2hwb,
      hsl2cmyk: hsl2cmyk,
      hsl2keyword: hsl2keyword,
      hsv2rgb: hsv2rgb,
      hsv2hsl: hsv2hsl,
      hsv2hwb: hsv2hwb,
      hsv2cmyk: hsv2cmyk,
      hsv2keyword: hsv2keyword,
      hwb2rgb: hwb2rgb,
      hwb2hsl: hwb2hsl,
      hwb2hsv: hwb2hsv,
      hwb2cmyk: hwb2cmyk,
      hwb2keyword: hwb2keyword,
      cmyk2rgb: cmyk2rgb,
      cmyk2hsl: cmyk2hsl,
      cmyk2hsv: cmyk2hsv,
      cmyk2hwb: cmyk2hwb,
      cmyk2keyword: cmyk2keyword,
      keyword2rgb: keyword2rgb,
      keyword2hsl: keyword2hsl,
      keyword2hsv: keyword2hsv,
      keyword2hwb: keyword2hwb,
      keyword2cmyk: keyword2cmyk,
      keyword2lab: keyword2lab,
      keyword2xyz: keyword2xyz,
      xyz2rgb: xyz2rgb,
      xyz2lab: xyz2lab,
      xyz2lch: xyz2lch,
      lab2xyz: lab2xyz,
      lab2rgb: lab2rgb,
      lab2lch: lab2lch,
      lch2lab: lch2lab,
      lch2xyz: lch2xyz,
      lch2rgb: lch2rgb
    };
    function rgb2hsl(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
      if (max == min)
        h = 0;
      else if (r == max)
        h = (g - b) / delta;
      else if (g == max)
        h = 2 + (b - r) / delta;
      else if (b == max)
        h = 4 + (r - g) / delta;
      h = Math.min(h * 60, 360);
      if (h < 0)
        h += 360;
      l = (min + max) / 2;
      if (max == min)
        s = 0;
      else if (l <= 0.5)
        s = delta / (max + min);
      else
        s = delta / (2 - max - min);
      return [
        h,
        s * 100,
        l * 100
      ]
    }
    function rgb2hsv(rgb) {
      var r = rgb[0], g = rgb[1], b = rgb[2], min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, v;
      if (max == 0)
        s = 0;
      else
        s = delta / max * 1000 / 10;
      if (max == min)
        h = 0;
      else if (r == max)
        h = (g - b) / delta;
      else if (g == max)
        h = 2 + (b - r) / delta;
      else if (b == max)
        h = 4 + (r - g) / delta;
      h = Math.min(h * 60, 360);
      if (h < 0)
        h += 360;
      v = max / 255 * 1000 / 10;
      return [
        h,
        s,
        v
      ]
    }
    function rgb2hwb(rgb) {
      var r = rgb[0], g = rgb[1], b = rgb[2], h = rgb2hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b)), b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [
        h,
        w * 100,
        b * 100
      ]
    }
    function rgb2cmyk(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, c, m, y, k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [
        c * 100,
        m * 100,
        y * 100,
        k * 100
      ]
    }
    function rgb2keyword(rgb) {
      return reverseKeywords[JSON.stringify(rgb)]
    }
    function rgb2xyz(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      // assume sRGB
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [
        x * 100,
        y * 100,
        z * 100
      ]
    }
    function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb), x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [
        l,
        a,
        b
      ]
    }
    function rgb2lch(args) {
      return lab2lch(rgb2lab(args))
    }
    function hsl2rgb(hsl) {
      var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val;
      if (s == 0) {
        val = l * 255;
        return [
          val,
          val,
          val
        ]
      }
      if (l < 0.5)
        t2 = l * (1 + s);
      else
        t2 = l + s - l * s;
      t1 = 2 * l - t2;
      rgb = [
        0,
        0,
        0
      ];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;
        if (6 * t3 < 1)
          val = t1 + (t2 - t1) * 6 * t3;
        else if (2 * t3 < 1)
          val = t2;
        else if (3 * t3 < 2)
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        else
          val = t1;
        rgb[i] = val * 255
      }
      return rgb
    }
    function hsl2hsv(hsl) {
      var h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, sv, v;
      if (l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [
          0,
          0,
          0
        ]
      }
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [
        h,
        sv * 100,
        v * 100
      ]
    }
    function hsl2hwb(args) {
      return rgb2hwb(hsl2rgb(args))
    }
    function hsl2cmyk(args) {
      return rgb2cmyk(hsl2rgb(args))
    }
    function hsl2keyword(args) {
      return rgb2keyword(hsl2rgb(args))
    }
    function hsv2rgb(hsv) {
      var h = hsv[0] / 60, s = hsv[1] / 100, v = hsv[2] / 100, hi = Math.floor(h) % 6;
      var f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f)), v = 255 * v;
      switch (hi) {
      case 0:
        return [
          v,
          t,
          p
        ];
      case 1:
        return [
          q,
          v,
          p
        ];
      case 2:
        return [
          p,
          v,
          t
        ];
      case 3:
        return [
          p,
          q,
          v
        ];
      case 4:
        return [
          t,
          p,
          v
        ];
      case 5:
        return [
          v,
          p,
          q
        ]
      }
    }
    function hsv2hsl(hsv) {
      var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, sl, l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [
        h,
        sl * 100,
        l * 100
      ]
    }
    function hsv2hwb(args) {
      return rgb2hwb(hsv2rgb(args))
    }
    function hsv2cmyk(args) {
      return rgb2cmyk(hsv2rgb(args))
    }
    function hsv2keyword(args) {
      return rgb2keyword(hsv2rgb(args))
    }
    // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
    function hwb2rgb(hwb) {
      var h = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, i, v, f, n;
      // wh + bl cant be > 1
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) != 0) {
        f = 1 - f
      }
      n = wh + f * (v - wh);
      // linear interpolation
      switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break
      }
      return [
        r * 255,
        g * 255,
        b * 255
      ]
    }
    function hwb2hsl(args) {
      return rgb2hsl(hwb2rgb(args))
    }
    function hwb2hsv(args) {
      return rgb2hsv(hwb2rgb(args))
    }
    function hwb2cmyk(args) {
      return rgb2cmyk(hwb2rgb(args))
    }
    function hwb2keyword(args) {
      return rgb2keyword(hwb2rgb(args))
    }
    function cmyk2rgb(cmyk) {
      var c = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100, r, g, b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [
        r * 255,
        g * 255,
        b * 255
      ]
    }
    function cmyk2hsl(args) {
      return rgb2hsl(cmyk2rgb(args))
    }
    function cmyk2hsv(args) {
      return rgb2hsv(cmyk2rgb(args))
    }
    function cmyk2hwb(args) {
      return rgb2hwb(cmyk2rgb(args))
    }
    function cmyk2keyword(args) {
      return rgb2keyword(cmyk2rgb(args))
    }
    function xyz2rgb(xyz) {
      var x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100, r, g, b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      // assume sRGB
      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [
        r * 255,
        g * 255,
        b * 255
      ]
    }
    function xyz2lab(xyz) {
      var x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [
        l,
        a,
        b
      ]
    }
    function xyz2lch(args) {
      return lab2lch(xyz2lab(args))
    }
    function lab2xyz(lab) {
      var l = lab[0], a = lab[1], b = lab[2], x, y, z, y2;
      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3)
      }
      x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [
        x,
        y,
        z
      ]
    }
    function lab2lch(lab) {
      var l = lab[0], a = lab[1], b = lab[2], hr, h, c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360
      }
      c = Math.sqrt(a * a + b * b);
      return [
        l,
        c,
        h
      ]
    }
    function lab2rgb(args) {
      return xyz2rgb(lab2xyz(args))
    }
    function lch2lab(lch) {
      var l = lch[0], c = lch[1], h = lch[2], a, b, hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [
        l,
        a,
        b
      ]
    }
    function lch2xyz(args) {
      return lab2xyz(lch2lab(args))
    }
    function lch2rgb(args) {
      return lab2rgb(lch2lab(args))
    }
    function keyword2rgb(keyword) {
      return cssKeywords[keyword]
    }
    function keyword2hsl(args) {
      return rgb2hsl(keyword2rgb(args))
    }
    function keyword2hsv(args) {
      return rgb2hsv(keyword2rgb(args))
    }
    function keyword2hwb(args) {
      return rgb2hwb(keyword2rgb(args))
    }
    function keyword2cmyk(args) {
      return rgb2cmyk(keyword2rgb(args))
    }
    function keyword2lab(args) {
      return rgb2lab(keyword2rgb(args))
    }
    function keyword2xyz(args) {
      return rgb2xyz(keyword2rgb(args))
    }
    var cssKeywords = {
      aliceblue: [
        240,
        248,
        255
      ],
      antiquewhite: [
        250,
        235,
        215
      ],
      aqua: [
        0,
        255,
        255
      ],
      aquamarine: [
        127,
        255,
        212
      ],
      azure: [
        240,
        255,
        255
      ],
      beige: [
        245,
        245,
        220
      ],
      bisque: [
        255,
        228,
        196
      ],
      black: [
        0,
        0,
        0
      ],
      blanchedalmond: [
        255,
        235,
        205
      ],
      blue: [
        0,
        0,
        255
      ],
      blueviolet: [
        138,
        43,
        226
      ],
      brown: [
        165,
        42,
        42
      ],
      burlywood: [
        222,
        184,
        135
      ],
      cadetblue: [
        95,
        158,
        160
      ],
      chartreuse: [
        127,
        255,
        0
      ],
      chocolate: [
        210,
        105,
        30
      ],
      coral: [
        255,
        127,
        80
      ],
      cornflowerblue: [
        100,
        149,
        237
      ],
      cornsilk: [
        255,
        248,
        220
      ],
      crimson: [
        220,
        20,
        60
      ],
      cyan: [
        0,
        255,
        255
      ],
      darkblue: [
        0,
        0,
        139
      ],
      darkcyan: [
        0,
        139,
        139
      ],
      darkgoldenrod: [
        184,
        134,
        11
      ],
      darkgray: [
        169,
        169,
        169
      ],
      darkgreen: [
        0,
        100,
        0
      ],
      darkgrey: [
        169,
        169,
        169
      ],
      darkkhaki: [
        189,
        183,
        107
      ],
      darkmagenta: [
        139,
        0,
        139
      ],
      darkolivegreen: [
        85,
        107,
        47
      ],
      darkorange: [
        255,
        140,
        0
      ],
      darkorchid: [
        153,
        50,
        204
      ],
      darkred: [
        139,
        0,
        0
      ],
      darksalmon: [
        233,
        150,
        122
      ],
      darkseagreen: [
        143,
        188,
        143
      ],
      darkslateblue: [
        72,
        61,
        139
      ],
      darkslategray: [
        47,
        79,
        79
      ],
      darkslategrey: [
        47,
        79,
        79
      ],
      darkturquoise: [
        0,
        206,
        209
      ],
      darkviolet: [
        148,
        0,
        211
      ],
      deeppink: [
        255,
        20,
        147
      ],
      deepskyblue: [
        0,
        191,
        255
      ],
      dimgray: [
        105,
        105,
        105
      ],
      dimgrey: [
        105,
        105,
        105
      ],
      dodgerblue: [
        30,
        144,
        255
      ],
      firebrick: [
        178,
        34,
        34
      ],
      floralwhite: [
        255,
        250,
        240
      ],
      forestgreen: [
        34,
        139,
        34
      ],
      fuchsia: [
        255,
        0,
        255
      ],
      gainsboro: [
        220,
        220,
        220
      ],
      ghostwhite: [
        248,
        248,
        255
      ],
      gold: [
        255,
        215,
        0
      ],
      goldenrod: [
        218,
        165,
        32
      ],
      gray: [
        128,
        128,
        128
      ],
      green: [
        0,
        128,
        0
      ],
      greenyellow: [
        173,
        255,
        47
      ],
      grey: [
        128,
        128,
        128
      ],
      honeydew: [
        240,
        255,
        240
      ],
      hotpink: [
        255,
        105,
        180
      ],
      indianred: [
        205,
        92,
        92
      ],
      indigo: [
        75,
        0,
        130
      ],
      ivory: [
        255,
        255,
        240
      ],
      khaki: [
        240,
        230,
        140
      ],
      lavender: [
        230,
        230,
        250
      ],
      lavenderblush: [
        255,
        240,
        245
      ],
      lawngreen: [
        124,
        252,
        0
      ],
      lemonchiffon: [
        255,
        250,
        205
      ],
      lightblue: [
        173,
        216,
        230
      ],
      lightcoral: [
        240,
        128,
        128
      ],
      lightcyan: [
        224,
        255,
        255
      ],
      lightgoldenrodyellow: [
        250,
        250,
        210
      ],
      lightgray: [
        211,
        211,
        211
      ],
      lightgreen: [
        144,
        238,
        144
      ],
      lightgrey: [
        211,
        211,
        211
      ],
      lightpink: [
        255,
        182,
        193
      ],
      lightsalmon: [
        255,
        160,
        122
      ],
      lightseagreen: [
        32,
        178,
        170
      ],
      lightskyblue: [
        135,
        206,
        250
      ],
      lightslategray: [
        119,
        136,
        153
      ],
      lightslategrey: [
        119,
        136,
        153
      ],
      lightsteelblue: [
        176,
        196,
        222
      ],
      lightyellow: [
        255,
        255,
        224
      ],
      lime: [
        0,
        255,
        0
      ],
      limegreen: [
        50,
        205,
        50
      ],
      linen: [
        250,
        240,
        230
      ],
      magenta: [
        255,
        0,
        255
      ],
      maroon: [
        128,
        0,
        0
      ],
      mediumaquamarine: [
        102,
        205,
        170
      ],
      mediumblue: [
        0,
        0,
        205
      ],
      mediumorchid: [
        186,
        85,
        211
      ],
      mediumpurple: [
        147,
        112,
        219
      ],
      mediumseagreen: [
        60,
        179,
        113
      ],
      mediumslateblue: [
        123,
        104,
        238
      ],
      mediumspringgreen: [
        0,
        250,
        154
      ],
      mediumturquoise: [
        72,
        209,
        204
      ],
      mediumvioletred: [
        199,
        21,
        133
      ],
      midnightblue: [
        25,
        25,
        112
      ],
      mintcream: [
        245,
        255,
        250
      ],
      mistyrose: [
        255,
        228,
        225
      ],
      moccasin: [
        255,
        228,
        181
      ],
      navajowhite: [
        255,
        222,
        173
      ],
      navy: [
        0,
        0,
        128
      ],
      oldlace: [
        253,
        245,
        230
      ],
      olive: [
        128,
        128,
        0
      ],
      olivedrab: [
        107,
        142,
        35
      ],
      orange: [
        255,
        165,
        0
      ],
      orangered: [
        255,
        69,
        0
      ],
      orchid: [
        218,
        112,
        214
      ],
      palegoldenrod: [
        238,
        232,
        170
      ],
      palegreen: [
        152,
        251,
        152
      ],
      paleturquoise: [
        175,
        238,
        238
      ],
      palevioletred: [
        219,
        112,
        147
      ],
      papayawhip: [
        255,
        239,
        213
      ],
      peachpuff: [
        255,
        218,
        185
      ],
      peru: [
        205,
        133,
        63
      ],
      pink: [
        255,
        192,
        203
      ],
      plum: [
        221,
        160,
        221
      ],
      powderblue: [
        176,
        224,
        230
      ],
      purple: [
        128,
        0,
        128
      ],
      rebeccapurple: [
        102,
        51,
        153
      ],
      red: [
        255,
        0,
        0
      ],
      rosybrown: [
        188,
        143,
        143
      ],
      royalblue: [
        65,
        105,
        225
      ],
      saddlebrown: [
        139,
        69,
        19
      ],
      salmon: [
        250,
        128,
        114
      ],
      sandybrown: [
        244,
        164,
        96
      ],
      seagreen: [
        46,
        139,
        87
      ],
      seashell: [
        255,
        245,
        238
      ],
      sienna: [
        160,
        82,
        45
      ],
      silver: [
        192,
        192,
        192
      ],
      skyblue: [
        135,
        206,
        235
      ],
      slateblue: [
        106,
        90,
        205
      ],
      slategray: [
        112,
        128,
        144
      ],
      slategrey: [
        112,
        128,
        144
      ],
      snow: [
        255,
        250,
        250
      ],
      springgreen: [
        0,
        255,
        127
      ],
      steelblue: [
        70,
        130,
        180
      ],
      tan: [
        210,
        180,
        140
      ],
      teal: [
        0,
        128,
        128
      ],
      thistle: [
        216,
        191,
        216
      ],
      tomato: [
        255,
        99,
        71
      ],
      turquoise: [
        64,
        224,
        208
      ],
      violet: [
        238,
        130,
        238
      ],
      wheat: [
        245,
        222,
        179
      ],
      white: [
        255,
        255,
        255
      ],
      whitesmoke: [
        245,
        245,
        245
      ],
      yellow: [
        255,
        255,
        0
      ],
      yellowgreen: [
        154,
        205,
        50
      ]
    };
    var reverseKeywords = {};
    for (var key in cssKeywords) {
      reverseKeywords[JSON.stringify(cssKeywords[key])] = key
    }
  });
  // source: node_modules/chartjs-color-string/color-string.js
  rqzt.define('chartjs-color-string/color-string', function (module, exports, __dirname, __filename, process) {
    /* MIT license */
    var colorNames = rqzt('color-name');
    module.exports = {
      getRgba: getRgba,
      getHsla: getHsla,
      getRgb: getRgb,
      getHsl: getHsl,
      getHwb: getHwb,
      getAlpha: getAlpha,
      hexString: hexString,
      rgbString: rgbString,
      rgbaString: rgbaString,
      percentString: percentString,
      percentaString: percentaString,
      hslString: hslString,
      hslaString: hslaString,
      hwbString: hwbString,
      keyword: keyword
    };
    function getRgba(string) {
      if (!string) {
        return
      }
      var abbr = /^#([a-fA-F0-9]{3})$/, hex = /^#([a-fA-F0-9]{6})$/, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/, keyword = /(\w+)/;
      var rgb = [
          0,
          0,
          0
        ], a = 1, match = string.match(abbr);
      if (match) {
        match = match[1];
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16)
        }
      } else if (match = string.match(hex)) {
        match = match[1];
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16)
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1])
        }
        a = parseFloat(match[4])
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55)
        }
        a = parseFloat(match[4])
      } else if (match = string.match(keyword)) {
        if (match[1] == 'transparent') {
          return [
            0,
            0,
            0,
            0
          ]
        }
        rgb = colorNames[match[1]];
        if (!rgb) {
          return
        }
      }
      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255)
      }
      if (!a && a != 0) {
        a = 1
      } else {
        a = scale(a, 0, 1)
      }
      rgb[3] = a;
      return rgb
    }
    function getHsla(string) {
      if (!string) {
        return
      }
      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360), s = scale(parseFloat(match[2]), 0, 100), l = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [
          h,
          s,
          l,
          a
        ]
      }
    }
    function getHwb(string) {
      if (!string) {
        return
      }
      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360), w = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [
          h,
          w,
          b,
          a
        ]
      }
    }
    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3)
    }
    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3)
    }
    function getAlpha(string) {
      var vals = getRgba(string);
      if (vals) {
        return vals[3]
      } else if (vals = getHsla(string)) {
        return vals[3]
      } else if (vals = getHwb(string)) {
        return vals[3]
      }
    }
    // generators
    function hexString(rgb) {
      return '#' + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2])
    }
    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha)
      }
      return 'rgb(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ')'
    }
    function rgbaString(rgba, alpha) {
      if (alpha === undefined) {
        alpha = rgba[3] !== undefined ? rgba[3] : 1
      }
      return 'rgba(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ', ' + alpha + ')'
    }
    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha)
      }
      var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
      return 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
    }
    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
      return 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + (alpha || rgba[3] || 1) + ')'
    }
    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha)
      }
      return 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
    }
    function hslaString(hsla, alpha) {
      if (alpha === undefined) {
        alpha = hsla[3] !== undefined ? hsla[3] : 1
      }
      return 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + alpha + ')'
    }
    // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)
    function hwbString(hwb, alpha) {
      if (alpha === undefined) {
        alpha = hwb[3] !== undefined ? hwb[3] : 1
      }
      return 'hwb(' + hwb[0] + ', ' + hwb[1] + '%, ' + hwb[2] + '%' + (alpha !== undefined && alpha !== 1 ? ', ' + alpha : '') + ')'
    }
    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)]
    }
    // helpers
    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max)
    }
    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? '0' + str : str
    }
    //create a list of reverse color names
    var reverseNames = {};
    for (var name in colorNames) {
      reverseNames[colorNames[name]] = name
    }
  });
  // source: node_modules/color-name/index.js
  rqzt.define('color-name', function (module, exports, __dirname, __filename, process) {
    module.exports = {
      'aliceblue': [
        240,
        248,
        255
      ],
      'antiquewhite': [
        250,
        235,
        215
      ],
      'aqua': [
        0,
        255,
        255
      ],
      'aquamarine': [
        127,
        255,
        212
      ],
      'azure': [
        240,
        255,
        255
      ],
      'beige': [
        245,
        245,
        220
      ],
      'bisque': [
        255,
        228,
        196
      ],
      'black': [
        0,
        0,
        0
      ],
      'blanchedalmond': [
        255,
        235,
        205
      ],
      'blue': [
        0,
        0,
        255
      ],
      'blueviolet': [
        138,
        43,
        226
      ],
      'brown': [
        165,
        42,
        42
      ],
      'burlywood': [
        222,
        184,
        135
      ],
      'cadetblue': [
        95,
        158,
        160
      ],
      'chartreuse': [
        127,
        255,
        0
      ],
      'chocolate': [
        210,
        105,
        30
      ],
      'coral': [
        255,
        127,
        80
      ],
      'cornflowerblue': [
        100,
        149,
        237
      ],
      'cornsilk': [
        255,
        248,
        220
      ],
      'crimson': [
        220,
        20,
        60
      ],
      'cyan': [
        0,
        255,
        255
      ],
      'darkblue': [
        0,
        0,
        139
      ],
      'darkcyan': [
        0,
        139,
        139
      ],
      'darkgoldenrod': [
        184,
        134,
        11
      ],
      'darkgray': [
        169,
        169,
        169
      ],
      'darkgreen': [
        0,
        100,
        0
      ],
      'darkgrey': [
        169,
        169,
        169
      ],
      'darkkhaki': [
        189,
        183,
        107
      ],
      'darkmagenta': [
        139,
        0,
        139
      ],
      'darkolivegreen': [
        85,
        107,
        47
      ],
      'darkorange': [
        255,
        140,
        0
      ],
      'darkorchid': [
        153,
        50,
        204
      ],
      'darkred': [
        139,
        0,
        0
      ],
      'darksalmon': [
        233,
        150,
        122
      ],
      'darkseagreen': [
        143,
        188,
        143
      ],
      'darkslateblue': [
        72,
        61,
        139
      ],
      'darkslategray': [
        47,
        79,
        79
      ],
      'darkslategrey': [
        47,
        79,
        79
      ],
      'darkturquoise': [
        0,
        206,
        209
      ],
      'darkviolet': [
        148,
        0,
        211
      ],
      'deeppink': [
        255,
        20,
        147
      ],
      'deepskyblue': [
        0,
        191,
        255
      ],
      'dimgray': [
        105,
        105,
        105
      ],
      'dimgrey': [
        105,
        105,
        105
      ],
      'dodgerblue': [
        30,
        144,
        255
      ],
      'firebrick': [
        178,
        34,
        34
      ],
      'floralwhite': [
        255,
        250,
        240
      ],
      'forestgreen': [
        34,
        139,
        34
      ],
      'fuchsia': [
        255,
        0,
        255
      ],
      'gainsboro': [
        220,
        220,
        220
      ],
      'ghostwhite': [
        248,
        248,
        255
      ],
      'gold': [
        255,
        215,
        0
      ],
      'goldenrod': [
        218,
        165,
        32
      ],
      'gray': [
        128,
        128,
        128
      ],
      'green': [
        0,
        128,
        0
      ],
      'greenyellow': [
        173,
        255,
        47
      ],
      'grey': [
        128,
        128,
        128
      ],
      'honeydew': [
        240,
        255,
        240
      ],
      'hotpink': [
        255,
        105,
        180
      ],
      'indianred': [
        205,
        92,
        92
      ],
      'indigo': [
        75,
        0,
        130
      ],
      'ivory': [
        255,
        255,
        240
      ],
      'khaki': [
        240,
        230,
        140
      ],
      'lavender': [
        230,
        230,
        250
      ],
      'lavenderblush': [
        255,
        240,
        245
      ],
      'lawngreen': [
        124,
        252,
        0
      ],
      'lemonchiffon': [
        255,
        250,
        205
      ],
      'lightblue': [
        173,
        216,
        230
      ],
      'lightcoral': [
        240,
        128,
        128
      ],
      'lightcyan': [
        224,
        255,
        255
      ],
      'lightgoldenrodyellow': [
        250,
        250,
        210
      ],
      'lightgray': [
        211,
        211,
        211
      ],
      'lightgreen': [
        144,
        238,
        144
      ],
      'lightgrey': [
        211,
        211,
        211
      ],
      'lightpink': [
        255,
        182,
        193
      ],
      'lightsalmon': [
        255,
        160,
        122
      ],
      'lightseagreen': [
        32,
        178,
        170
      ],
      'lightskyblue': [
        135,
        206,
        250
      ],
      'lightslategray': [
        119,
        136,
        153
      ],
      'lightslategrey': [
        119,
        136,
        153
      ],
      'lightsteelblue': [
        176,
        196,
        222
      ],
      'lightyellow': [
        255,
        255,
        224
      ],
      'lime': [
        0,
        255,
        0
      ],
      'limegreen': [
        50,
        205,
        50
      ],
      'linen': [
        250,
        240,
        230
      ],
      'magenta': [
        255,
        0,
        255
      ],
      'maroon': [
        128,
        0,
        0
      ],
      'mediumaquamarine': [
        102,
        205,
        170
      ],
      'mediumblue': [
        0,
        0,
        205
      ],
      'mediumorchid': [
        186,
        85,
        211
      ],
      'mediumpurple': [
        147,
        112,
        219
      ],
      'mediumseagreen': [
        60,
        179,
        113
      ],
      'mediumslateblue': [
        123,
        104,
        238
      ],
      'mediumspringgreen': [
        0,
        250,
        154
      ],
      'mediumturquoise': [
        72,
        209,
        204
      ],
      'mediumvioletred': [
        199,
        21,
        133
      ],
      'midnightblue': [
        25,
        25,
        112
      ],
      'mintcream': [
        245,
        255,
        250
      ],
      'mistyrose': [
        255,
        228,
        225
      ],
      'moccasin': [
        255,
        228,
        181
      ],
      'navajowhite': [
        255,
        222,
        173
      ],
      'navy': [
        0,
        0,
        128
      ],
      'oldlace': [
        253,
        245,
        230
      ],
      'olive': [
        128,
        128,
        0
      ],
      'olivedrab': [
        107,
        142,
        35
      ],
      'orange': [
        255,
        165,
        0
      ],
      'orangered': [
        255,
        69,
        0
      ],
      'orchid': [
        218,
        112,
        214
      ],
      'palegoldenrod': [
        238,
        232,
        170
      ],
      'palegreen': [
        152,
        251,
        152
      ],
      'paleturquoise': [
        175,
        238,
        238
      ],
      'palevioletred': [
        219,
        112,
        147
      ],
      'papayawhip': [
        255,
        239,
        213
      ],
      'peachpuff': [
        255,
        218,
        185
      ],
      'peru': [
        205,
        133,
        63
      ],
      'pink': [
        255,
        192,
        203
      ],
      'plum': [
        221,
        160,
        221
      ],
      'powderblue': [
        176,
        224,
        230
      ],
      'purple': [
        128,
        0,
        128
      ],
      'rebeccapurple': [
        102,
        51,
        153
      ],
      'red': [
        255,
        0,
        0
      ],
      'rosybrown': [
        188,
        143,
        143
      ],
      'royalblue': [
        65,
        105,
        225
      ],
      'saddlebrown': [
        139,
        69,
        19
      ],
      'salmon': [
        250,
        128,
        114
      ],
      'sandybrown': [
        244,
        164,
        96
      ],
      'seagreen': [
        46,
        139,
        87
      ],
      'seashell': [
        255,
        245,
        238
      ],
      'sienna': [
        160,
        82,
        45
      ],
      'silver': [
        192,
        192,
        192
      ],
      'skyblue': [
        135,
        206,
        235
      ],
      'slateblue': [
        106,
        90,
        205
      ],
      'slategray': [
        112,
        128,
        144
      ],
      'slategrey': [
        112,
        128,
        144
      ],
      'snow': [
        255,
        250,
        250
      ],
      'springgreen': [
        0,
        255,
        127
      ],
      'steelblue': [
        70,
        130,
        180
      ],
      'tan': [
        210,
        180,
        140
      ],
      'teal': [
        0,
        128,
        128
      ],
      'thistle': [
        216,
        191,
        216
      ],
      'tomato': [
        255,
        99,
        71
      ],
      'turquoise': [
        64,
        224,
        208
      ],
      'violet': [
        238,
        130,
        238
      ],
      'wheat': [
        245,
        222,
        179
      ],
      'white': [
        255,
        255,
        255
      ],
      'whitesmoke': [
        245,
        245,
        245
      ],
      'yellow': [
        255,
        255,
        0
      ],
      'yellowgreen': [
        154,
        205,
        50
      ]
    }
  });
  // source: node_modules/chart.js/src/core/core.canvasHelpers.js
  rqzt.define('chart.js/src/core/core.canvasHelpers', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      // Global Chart canvas helpers object for drawing items to canvas
      var helpers = Chart.canvasHelpers = {};
      helpers.drawPoint = function (ctx, pointStyle, radius, x, y) {
        var type, edgeLength, xOffset, yOffset, height, size;
        if (typeof pointStyle === 'object') {
          type = pointStyle.toString();
          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);
            return
          }
        }
        if (isNaN(radius) || radius <= 0) {
          return
        }
        switch (pointStyle) {
        // Default includes circle
        default:
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.closePath();
          ctx.fill();
          break;
        case 'triangle':
          ctx.beginPath();
          edgeLength = 3 * radius / Math.sqrt(3);
          height = edgeLength * Math.sqrt(3) / 2;
          ctx.moveTo(x - edgeLength / 2, y + height / 3);
          ctx.lineTo(x + edgeLength / 2, y + height / 3);
          ctx.lineTo(x, y - 2 * height / 3);
          ctx.closePath();
          ctx.fill();
          break;
        case 'rect':
          size = 1 / Math.SQRT2 * radius;
          ctx.beginPath();
          ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
          ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
          break;
        case 'rectRot':
          size = 1 / Math.SQRT2 * radius;
          ctx.beginPath();
          ctx.moveTo(x - size, y);
          ctx.lineTo(x, y + size);
          ctx.lineTo(x + size, y);
          ctx.lineTo(x, y - size);
          ctx.closePath();
          ctx.fill();
          break;
        case 'cross':
          ctx.beginPath();
          ctx.moveTo(x, y + radius);
          ctx.lineTo(x, y - radius);
          ctx.moveTo(x - radius, y);
          ctx.lineTo(x + radius, y);
          ctx.closePath();
          break;
        case 'crossRot':
          ctx.beginPath();
          xOffset = Math.cos(Math.PI / 4) * radius;
          yOffset = Math.sin(Math.PI / 4) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x - xOffset, y + yOffset);
          ctx.lineTo(x + xOffset, y - yOffset);
          ctx.closePath();
          break;
        case 'star':
          ctx.beginPath();
          ctx.moveTo(x, y + radius);
          ctx.lineTo(x, y - radius);
          ctx.moveTo(x - radius, y);
          ctx.lineTo(x + radius, y);
          xOffset = Math.cos(Math.PI / 4) * radius;
          yOffset = Math.sin(Math.PI / 4) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x - xOffset, y + yOffset);
          ctx.lineTo(x + xOffset, y - yOffset);
          ctx.closePath();
          break;
        case 'line':
          ctx.beginPath();
          ctx.moveTo(x - radius, y);
          ctx.lineTo(x + radius, y);
          ctx.closePath();
          break;
        case 'dash':
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + radius, y);
          ctx.closePath();
          break
        }
        ctx.stroke()
      }
    }
  });
  // source: node_modules/chart.js/src/core/core.element.js
  rqzt.define('chart.js/src/core/core.element', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.elements = {};
      Chart.Element = function (configuration) {
        helpers.extend(this, configuration);
        this.initialize.apply(this, arguments)
      };
      helpers.extend(Chart.Element.prototype, {
        initialize: function () {
          this.hidden = false
        },
        pivot: function () {
          var me = this;
          if (!me._view) {
            me._view = helpers.clone(me._model)
          }
          me._start = helpers.clone(me._view);
          return me
        },
        transition: function (ease) {
          var me = this;
          if (!me._view) {
            me._view = helpers.clone(me._model)
          }
          // No animation -> No Transition
          if (ease === 1) {
            me._view = me._model;
            me._start = null;
            return me
          }
          if (!me._start) {
            me.pivot()
          }
          helpers.each(me._model, function (value, key) {
            if (key[0] === '_') {
            } else if (!me._view.hasOwnProperty(key)) {
              if (typeof value === 'number' && !isNaN(me._view[key])) {
                me._view[key] = value * ease
              } else {
                me._view[key] = value
              }  // No unnecessary computations
            } else if (value === me._view[key]) {
            } else if (typeof value === 'string') {
              try {
                var color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);
                me._view[key] = color.rgbString()
              } catch (err) {
                me._view[key] = value
              }  // Number transitions
            } else if (typeof value === 'number') {
              var startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;
              me._view[key] = (me._model[key] - startVal) * ease + startVal  // Everything else
            } else {
              me._view[key] = value
            }
          }, me);
          return me
        },
        tooltipPosition: function () {
          return {
            x: this._model.x,
            y: this._model.y
          }
        },
        hasValue: function () {
          return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y)
        }
      });
      Chart.Element.extend = helpers.inherits
    }
  });
  // source: node_modules/chart.js/src/core/core.animation.js
  rqzt.define('chart.js/src/core/core.animation', function (module, exports, __dirname, __filename, process) {
    /* global window: false */
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.defaults.global.animation = {
        duration: 1000,
        easing: 'easeOutQuart',
        onProgress: helpers.noop,
        onComplete: helpers.noop
      };
      Chart.Animation = Chart.Element.extend({
        currentStep: null,
        // the current animation step
        numSteps: 60,
        // default number of steps
        easing: '',
        // the easing to use for this animation
        render: null,
        // render function used by the animation service
        onAnimationProgress: null,
        // user specified callback to fire on each step of the animation
        onAnimationComplete: null  // user specified callback to fire when the animation finishes
      });
      Chart.animationService = {
        frameDuration: 17,
        animations: [],
        dropFrames: 0,
        request: null,
        /**
		 * @function Chart.animationService.addAnimation
		 * @param chartInstance {ChartController} the chart to animate
		 * @param animationObject {IAnimation} the animation that we will animate
		 * @param duration {Number} length of animation in ms
		 * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions
		 */
        addAnimation: function (chartInstance, animationObject, duration, lazy) {
          var me = this;
          if (!lazy) {
            chartInstance.animating = true
          }
          for (var index = 0; index < me.animations.length; ++index) {
            if (me.animations[index].chartInstance === chartInstance) {
              // replacing an in progress animation
              me.animations[index].animationObject = animationObject;
              return
            }
          }
          me.animations.push({
            chartInstance: chartInstance,
            animationObject: animationObject
          });
          // If there are no animations queued, manually kickstart a digest, for lack of a better word
          if (me.animations.length === 1) {
            me.requestAnimationFrame()
          }
        },
        // Cancel the animation for a given chart instance
        cancelAnimation: function (chartInstance) {
          var index = helpers.findIndex(this.animations, function (animationWrapper) {
            return animationWrapper.chartInstance === chartInstance
          });
          if (index !== -1) {
            this.animations.splice(index, 1);
            chartInstance.animating = false
          }
        },
        requestAnimationFrame: function () {
          var me = this;
          if (me.request === null) {
            // Skip animation frame requests until the active one is executed.
            // This can happen when processing mouse events, e.g. 'mousemove'
            // and 'mouseout' events will trigger multiple renders.
            me.request = helpers.requestAnimFrame.call(window, function () {
              me.request = null;
              me.startDigest()
            })
          }
        },
        startDigest: function () {
          var me = this;
          var startTime = Date.now();
          var framesToDrop = 0;
          if (me.dropFrames > 1) {
            framesToDrop = Math.floor(me.dropFrames);
            me.dropFrames = me.dropFrames % 1
          }
          var i = 0;
          while (i < me.animations.length) {
            if (me.animations[i].animationObject.currentStep === null) {
              me.animations[i].animationObject.currentStep = 0
            }
            me.animations[i].animationObject.currentStep += 1 + framesToDrop;
            if (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {
              me.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps
            }
            me.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);
            if (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {
              me.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i])
            }
            if (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {
              if (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {
                me.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i])
              }
              // executed the last frame. Remove the animation.
              me.animations[i].chartInstance.animating = false;
              me.animations.splice(i, 1)
            } else {
              ++i
            }
          }
          var endTime = Date.now();
          var dropFrames = (endTime - startTime) / me.frameDuration;
          me.dropFrames += dropFrames;
          // Do we have more stuff to animate?
          if (me.animations.length > 0) {
            me.requestAnimationFrame()
          }
        }
      }
    }
  });
  // source: node_modules/chart.js/src/core/core.controller.js
  rqzt.define('chart.js/src/core/core.controller', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      // Create a dictionary of chart types, to allow for extension of existing types
      Chart.types = {};
      // Store a reference to each instance - allowing us to globally resize chart instances on window resize.
      // Destroy method on the chart will remove the instance of the chart from this reference.
      Chart.instances = {};
      // Controllers available for dataset visualization eg. bar, line, slice, etc.
      Chart.controllers = {};
      /**
	 * The "used" size is the final value of a dimension property after all calculations have
	 * been performed. This method uses the computed style of `element` but returns undefined
	 * if the computed style is not expressed in pixels. That can happen in some cases where
	 * `element` has a size relative to its parent and this last one is not yet displayed,
	 * for example because of `display: none` on a parent node.
	 * TODO(SB) Move this method in the upcoming core.platform class.
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
	 * @returns {Number} Size in pixels or undefined if unknown.
	 */
      function readUsedSize(element, property) {
        var value = helpers.getStyle(element, property);
        var matches = value && value.match(/(\d+)px/);
        return matches ? Number(matches[1]) : undefined
      }
      /**
	 * Initializes the canvas style and render size without modifying the canvas display size,
	 * since responsiveness is handled by the controller.resize() method. The config is used
	 * to determine the aspect ratio to apply in case no explicit height has been specified.
	 * TODO(SB) Move this method in the upcoming core.platform class.
	 */
      function initCanvas(canvas, config) {
        var style = canvas.style;
        // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
        // returns null or '' if no explicit value has been set to the canvas attribute.
        var renderHeight = canvas.getAttribute('height');
        var renderWidth = canvas.getAttribute('width');
        // Chart.js modifies some canvas values that we want to restore on destroy
        canvas._chartjs = {
          initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
              display: style.display,
              height: style.height,
              width: style.width
            }
          }
        };
        // Force canvas to display as block to avoid extra space caused by inline
        // elements, which would interfere with the responsive resize process.
        // https://github.com/chartjs/Chart.js/issues/2538
        style.display = style.display || 'block';
        if (renderWidth === null || renderWidth === '') {
          var displayWidth = readUsedSize(canvas, 'width');
          if (displayWidth !== undefined) {
            canvas.width = displayWidth
          }
        }
        if (renderHeight === null || renderHeight === '') {
          if (canvas.style.height === '') {
            // If no explicit render height and style height, let's apply the aspect ratio,
            // which one can be specified by the user but also by charts as default option
            // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
            canvas.height = canvas.width / (config.options.aspectRatio || 2)
          } else {
            var displayHeight = readUsedSize(canvas, 'height');
            if (displayWidth !== undefined) {
              canvas.height = displayHeight
            }
          }
        }
        return canvas
      }
      /**
	 * Restores the canvas initial state, such as render/display sizes and style.
	 * TODO(SB) Move this method in the upcoming core.platform class.
	 */
      function releaseCanvas(canvas) {
        if (!canvas._chartjs) {
          return
        }
        var initial = canvas._chartjs.initial;
        [
          'height',
          'width'
        ].forEach(function (prop) {
          var value = initial[prop];
          if (value === undefined || value === null) {
            canvas.removeAttribute(prop)
          } else {
            canvas.setAttribute(prop, value)
          }
        });
        helpers.each(initial.style || {}, function (value, key) {
          canvas.style[key] = value
        });
        // The canvas render size might have been changed (and thus the state stack discarded),
        // we can't use save() and restore() to restore the initial state. So make sure that at
        // least the canvas context is reset to the default state by setting the canvas width.
        // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
        canvas.width = canvas.width;
        delete canvas._chartjs
      }
      /**
	 * TODO(SB) Move this method in the upcoming core.platform class.
	 */
      function acquireContext(item, config) {
        if (typeof item === 'string') {
          item = document.getElementById(item)
        } else if (item.length) {
          // Support for array based queries (such as jQuery)
          item = item[0]
        }
        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas
        }
        if (item instanceof HTMLCanvasElement) {
          // To prevent canvas fingerprinting, some add-ons undefine the getContext
          // method, for example: https://github.com/kkapsner/CanvasBlocker
          // https://github.com/chartjs/Chart.js/issues/2807
          var context = item.getContext && item.getContext('2d');
          if (context instanceof CanvasRenderingContext2D) {
            initCanvas(item, config);
            return context
          }
        }
        return null
      }
      /**
	 * Initializes the given config with global and chart default values.
	 */
      function initConfig(config) {
        config = config || {};
        // Do NOT use configMerge() for the data object because this method merges arrays
        // and so would change references to labels and datasets, preventing data updates.
        var data = config.data = config.data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        config.options = helpers.configMerge(Chart.defaults.global, Chart.defaults[config.type], config.options || {});
        return config
      }
      /**
	 * @class Chart.Controller
	 * The main controller of a chart.
	 */
      Chart.Controller = function (item, config, instance) {
        var me = this;
        config = initConfig(config);
        var context = acquireContext(item, config);
        var canvas = context && context.canvas;
        var height = canvas && canvas.height;
        var width = canvas && canvas.width;
        instance.ctx = context;
        instance.canvas = canvas;
        instance.config = config;
        instance.width = width;
        instance.height = height;
        instance.aspectRatio = height ? width / height : null;
        me.id = helpers.uid();
        me.chart = instance;
        me.config = config;
        me.options = config.options;
        me._bufferedRender = false;
        // Add the chart instance to the global namespace
        Chart.instances[me.id] = me;
        Object.defineProperty(me, 'data', {
          get: function () {
            return me.config.data
          }
        });
        if (!context || !canvas) {
          // The given item is not a compatible context2d element, let's return before finalizing
          // the chart initialization but after setting basic chart / controller properties that
          // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
          // https://github.com/chartjs/Chart.js/issues/2807
          console.error("Failed to create chart: can't acquire context from the given item");
          return me
        }
        helpers.retinaScale(instance);
        // Responsiveness is currently based on the use of an iframe, however this method causes
        // performance issues and could be troublesome when used with ad blockers. So make sure
        // that the user is still able to create a chart without iframe when responsive is false.
        // See https://github.com/chartjs/Chart.js/issues/2210
        if (me.options.responsive) {
          helpers.addResizeListener(canvas.parentNode, function () {
            me.resize()
          });
          // Initial resize before chart draws (must be silent to preserve initial animations).
          me.resize(true)
        }
        me.initialize();
        return me
      };
      helpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller */
      {
        initialize: function () {
          var me = this;
          // Before init plugin notification
          Chart.plugins.notify('beforeInit', [me]);
          me.bindEvents();
          // Make sure controllers are built first so that each dataset is bound to an axis before the scales
          // are built
          me.ensureScalesHaveIDs();
          me.buildOrUpdateControllers();
          me.buildScales();
          me.updateLayout();
          me.resetElements();
          me.initToolTip();
          me.update();
          // After init plugin notification
          Chart.plugins.notify('afterInit', [me]);
          return me
        },
        clear: function () {
          helpers.clear(this.chart);
          return this
        },
        stop: function () {
          // Stops any current animation loop occurring
          Chart.animationService.cancelAnimation(this);
          return this
        },
        resize: function (silent) {
          var me = this;
          var chart = me.chart;
          var options = me.options;
          var canvas = chart.canvas;
          var aspectRatio = options.maintainAspectRatio && chart.aspectRatio || null;
          // the canvas render width and height will be casted to integers so make sure that
          // the canvas display style uses the same integer values to avoid blurring effect.
          var newWidth = Math.floor(helpers.getMaximumWidth(canvas));
          var newHeight = Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));
          if (chart.width === newWidth && chart.height === newHeight) {
            return
          }
          canvas.width = chart.width = newWidth;
          canvas.height = chart.height = newHeight;
          canvas.style.width = newWidth + 'px';
          canvas.style.height = newHeight + 'px';
          helpers.retinaScale(chart);
          // Notify any plugins about the resize
          var newSize = {
            width: newWidth,
            height: newHeight
          };
          Chart.plugins.notify('resize', [
            me,
            newSize
          ]);
          // Notify of resize
          if (me.options.onResize) {
            me.options.onResize(me, newSize)
          }
          if (!silent) {
            me.stop();
            me.update(me.options.responsiveAnimationDuration)
          }
        },
        ensureScalesHaveIDs: function () {
          var options = this.options;
          var scalesOptions = options.scales || {};
          var scaleOptions = options.scale;
          helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {
            xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index
          });
          helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {
            yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index
          });
          if (scaleOptions) {
            scaleOptions.id = scaleOptions.id || 'scale'
          }
        },
        /**
		 * Builds a map of scale ID to scale object for future lookup.
		 */
        buildScales: function () {
          var me = this;
          var options = me.options;
          var scales = me.scales = {};
          var items = [];
          if (options.scales) {
            items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
              return {
                options: xAxisOptions,
                dtype: 'category'
              }
            }), (options.scales.yAxes || []).map(function (yAxisOptions) {
              return {
                options: yAxisOptions,
                dtype: 'linear'
              }
            }))
          }
          if (options.scale) {
            items.push({
              options: options.scale,
              dtype: 'radialLinear',
              isDefault: true
            })
          }
          helpers.each(items, function (item) {
            var scaleOptions = item.options;
            var scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);
            var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
            if (!scaleClass) {
              return
            }
            var scale = new scaleClass({
              id: scaleOptions.id,
              options: scaleOptions,
              ctx: me.chart.ctx,
              chart: me
            });
            scales[scale.id] = scale;
            // TODO(SB): I think we should be able to remove this custom case (options.scale)
            // and consider it as a regular scale part of the "scales"" map only! This would
            // make the logic easier and remove some useless? custom code.
            if (item.isDefault) {
              me.scale = scale
            }
          });
          Chart.scaleService.addScalesToLayout(this)
        },
        updateLayout: function () {
          Chart.layoutService.update(this, this.chart.width, this.chart.height)
        },
        buildOrUpdateControllers: function () {
          var me = this;
          var types = [];
          var newControllers = [];
          helpers.each(me.data.datasets, function (dataset, datasetIndex) {
            var meta = me.getDatasetMeta(datasetIndex);
            if (!meta.type) {
              meta.type = dataset.type || me.config.type
            }
            types.push(meta.type);
            if (meta.controller) {
              meta.controller.updateIndex(datasetIndex)
            } else {
              meta.controller = new Chart.controllers[meta.type](me, datasetIndex);
              newControllers.push(meta.controller)
            }
          }, me);
          if (types.length > 1) {
            for (var i = 1; i < types.length; i++) {
              if (types[i] !== types[i - 1]) {
                me.isCombo = true;
                break
              }
            }
          }
          return newControllers
        },
        /**
		 * Reset the elements of all datasets
		 * @method resetElements
		 * @private
		 */
        resetElements: function () {
          var me = this;
          helpers.each(me.data.datasets, function (dataset, datasetIndex) {
            me.getDatasetMeta(datasetIndex).controller.reset()
          }, me)
        },
        /**
		* Resets the chart back to it's state before the initial animation
		* @method reset
		*/
        reset: function () {
          this.resetElements();
          this.tooltip.initialize()
        },
        update: function (animationDuration, lazy) {
          var me = this;
          Chart.plugins.notify('beforeUpdate', [me]);
          // In case the entire data object changed
          me.tooltip._data = me.data;
          // Make sure dataset controllers are updated and new controllers are reset
          var newControllers = me.buildOrUpdateControllers();
          // Make sure all dataset controllers have correct meta data counts
          helpers.each(me.data.datasets, function (dataset, datasetIndex) {
            me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements()
          }, me);
          Chart.layoutService.update(me, me.chart.width, me.chart.height);
          // Apply changes to the datasets that require the scales to have been calculated i.e BorderColor changes
          Chart.plugins.notify('afterScaleUpdate', [me]);
          // Can only reset the new controllers after the scales have been updated
          helpers.each(newControllers, function (controller) {
            controller.reset()
          });
          me.updateDatasets();
          // Do this before render so that any plugins that need final scale updates can use it
          Chart.plugins.notify('afterUpdate', [me]);
          if (me._bufferedRender) {
            me._bufferedRequest = {
              lazy: lazy,
              duration: animationDuration
            }
          } else {
            me.render(animationDuration, lazy)
          }
        },
        /**
		 * @method beforeDatasetsUpdate
		 * @description Called before all datasets are updated. If a plugin returns false,
		 * the datasets update will be cancelled until another chart update is triggered.
		 * @param {Object} instance the chart instance being updated.
		 * @returns {Boolean} false to cancel the datasets update.
		 * @memberof Chart.PluginBase
		 * @since version 2.1.5
		 * @instance
		 */
        /**
		 * @method afterDatasetsUpdate
		 * @description Called after all datasets have been updated. Note that this
		 * extension will not be called if the datasets update has been cancelled.
		 * @param {Object} instance the chart instance being updated.
		 * @memberof Chart.PluginBase
		 * @since version 2.1.5
		 * @instance
		 */
        /**
		 * Updates all datasets unless a plugin returns false to the beforeDatasetsUpdate
		 * extension, in which case no datasets will be updated and the afterDatasetsUpdate
		 * notification will be skipped.
		 * @protected
		 * @instance
		 */
        updateDatasets: function () {
          var me = this;
          var i, ilen;
          if (Chart.plugins.notify('beforeDatasetsUpdate', [me])) {
            for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
              me.getDatasetMeta(i).controller.update()
            }
            Chart.plugins.notify('afterDatasetsUpdate', [me])
          }
        },
        render: function (duration, lazy) {
          var me = this;
          Chart.plugins.notify('beforeRender', [me]);
          var animationOptions = me.options.animation;
          if (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {
            var animation = new Chart.Animation;
            animation.numSteps = (duration || animationOptions.duration) / 16.66;
            // 60 fps
            animation.easing = animationOptions.easing;
            // render function
            animation.render = function (chartInstance, animationObject) {
              var easingFunction = helpers.easingEffects[animationObject.easing];
              var stepDecimal = animationObject.currentStep / animationObject.numSteps;
              var easeDecimal = easingFunction(stepDecimal);
              chartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep)
            };
            // user events
            animation.onAnimationProgress = animationOptions.onProgress;
            animation.onAnimationComplete = animationOptions.onComplete;
            Chart.animationService.addAnimation(me, animation, duration, lazy)
          } else {
            me.draw();
            if (animationOptions && animationOptions.onComplete && animationOptions.onComplete.call) {
              animationOptions.onComplete.call(me)
            }
          }
          return me
        },
        draw: function (ease) {
          var me = this;
          var easingDecimal = ease || 1;
          me.clear();
          Chart.plugins.notify('beforeDraw', [
            me,
            easingDecimal
          ]);
          // Draw all the scales
          helpers.each(me.boxes, function (box) {
            box.draw(me.chartArea)
          }, me);
          if (me.scale) {
            me.scale.draw()
          }
          Chart.plugins.notify('beforeDatasetsDraw', [
            me,
            easingDecimal
          ]);
          // Draw each dataset via its respective controller (reversed to support proper line stacking)
          helpers.each(me.data.datasets, function (dataset, datasetIndex) {
            if (me.isDatasetVisible(datasetIndex)) {
              me.getDatasetMeta(datasetIndex).controller.draw(ease)
            }
          }, me, true);
          Chart.plugins.notify('afterDatasetsDraw', [
            me,
            easingDecimal
          ]);
          // Finally draw the tooltip
          me.tooltip.transition(easingDecimal).draw();
          Chart.plugins.notify('afterDraw', [
            me,
            easingDecimal
          ])
        },
        // Get the single element that was clicked on
        // @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
        getElementAtEvent: function (e) {
          return Chart.Interaction.modes.single(this, e)
        },
        getElementsAtEvent: function (e) {
          return Chart.Interaction.modes.label(this, e, { intersect: true })
        },
        getElementsAtXAxis: function (e) {
          return Chart.Interaction.modes['x-axis'](this, e, { intersect: true })
        },
        getElementsAtEventForMode: function (e, mode, options) {
          var method = Chart.Interaction.modes[mode];
          if (typeof method === 'function') {
            return method(this, e, options)
          }
          return []
        },
        getDatasetAtEvent: function (e) {
          return Chart.Interaction.modes.dataset(this, e)
        },
        getDatasetMeta: function (datasetIndex) {
          var me = this;
          var dataset = me.data.datasets[datasetIndex];
          if (!dataset._meta) {
            dataset._meta = {}
          }
          var meta = dataset._meta[me.id];
          if (!meta) {
            meta = dataset._meta[me.id] = {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              // See isDatasetVisible() comment
              xAxisID: null,
              yAxisID: null
            }
          }
          return meta
        },
        getVisibleDatasetCount: function () {
          var count = 0;
          for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            if (this.isDatasetVisible(i)) {
              count++
            }
          }
          return count
        },
        isDatasetVisible: function (datasetIndex) {
          var meta = this.getDatasetMeta(datasetIndex);
          // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
          // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
          return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden
        },
        generateLegend: function () {
          return this.options.legendCallback(this)
        },
        destroy: function () {
          var me = this;
          var canvas = me.chart.canvas;
          var meta, i, ilen;
          me.stop();
          // dataset controllers need to cleanup associated data
          for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            meta = me.getDatasetMeta(i);
            if (meta.controller) {
              meta.controller.destroy();
              meta.controller = null
            }
          }
          if (canvas) {
            helpers.unbindEvents(me, me.events);
            helpers.removeResizeListener(canvas.parentNode);
            helpers.clear(me.chart);
            releaseCanvas(canvas);
            me.chart.canvas = null;
            me.chart.ctx = null
          }
          Chart.plugins.notify('destroy', [me]);
          delete Chart.instances[me.id]
        },
        toBase64Image: function () {
          return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments)
        },
        initToolTip: function () {
          var me = this;
          me.tooltip = new Chart.Tooltip({
            _chart: me.chart,
            _chartInstance: me,
            _data: me.data,
            _options: me.options.tooltips
          }, me);
          me.tooltip.initialize()
        },
        bindEvents: function () {
          var me = this;
          helpers.bindEvents(me, me.options.events, function (evt) {
            me.eventHandler(evt)
          })
        },
        updateHoverStyle: function (elements, mode, enabled) {
          var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
          var element, i, ilen;
          for (i = 0, ilen = elements.length; i < ilen; ++i) {
            element = elements[i];
            if (element) {
              this.getDatasetMeta(element._datasetIndex).controller[method](element)
            }
          }
        },
        eventHandler: function (e) {
          var me = this;
          var legend = me.legend;
          var tooltip = me.tooltip;
          var hoverOptions = me.options.hover;
          // Buffer any update calls so that renders do not occur
          me._bufferedRender = true;
          me._bufferedRequest = null;
          var changed = me.handleEvent(e);
          changed |= legend && legend.handleEvent(e);
          changed |= tooltip && tooltip.handleEvent(e);
          var bufferedRequest = me._bufferedRequest;
          if (bufferedRequest) {
            // If we have an update that was triggered, we need to do a normal render
            me.render(bufferedRequest.duration, bufferedRequest.lazy)
          } else if (changed && !me.animating) {
            // If entering, leaving, or changing elements, animate the change via pivot
            me.stop();
            // We only need to render at this point. Updating will cause scales to be
            // recomputed generating flicker & using more memory than necessary.
            me.render(hoverOptions.animationDuration, true)
          }
          me._bufferedRender = false;
          me._bufferedRequest = null;
          return me
        },
        /**
		 * Handle an event
		 * @private
		 * param e {Event} the event to handle
		 * @return {Boolean} true if the chart needs to re-render
		 */
        handleEvent: function (e) {
          var me = this;
          var options = me.options || {};
          var hoverOptions = options.hover;
          var changed = false;
          me.lastActive = me.lastActive || [];
          // Find Active Elements for hover and tooltips
          if (e.type === 'mouseout') {
            me.active = []
          } else {
            me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions)
          }
          // On Hover hook
          if (hoverOptions.onHover) {
            hoverOptions.onHover.call(me, me.active)
          }
          if (e.type === 'mouseup' || e.type === 'click') {
            if (options.onClick) {
              options.onClick.call(me, e, me.active)
            }
          }
          // Remove styling for last active (even if it may still be active)
          if (me.lastActive.length) {
            me.updateHoverStyle(me.lastActive, hoverOptions.mode, false)
          }
          // Built in hover styling
          if (me.active.length && hoverOptions.mode) {
            me.updateHoverStyle(me.active, hoverOptions.mode, true)
          }
          changed = !helpers.arrayEquals(me.active, me.lastActive);
          // Remember Last Actives
          me.lastActive = me.active;
          return changed
        }
      })
    }
  });
  // source: node_modules/chart.js/src/core/core.datasetController.js
  rqzt.define('chart.js/src/core/core.datasetController', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      var arrayEvents = [
        'push',
        'pop',
        'shift',
        'splice',
        'unshift'
      ];
      /**
	 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
	 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
	 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
	 */
      function listenArrayEvents(array, listener) {
        if (array._chartjs) {
          array._chartjs.listeners.push(listener);
          return
        }
        Object.defineProperty(array, '_chartjs', {
          configurable: true,
          enumerable: false,
          value: { listeners: [listener] }
        });
        arrayEvents.forEach(function (key) {
          var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
          var base = array[key];
          Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value: function () {
              var args = Array.prototype.slice.call(arguments);
              var res = base.apply(this, args);
              helpers.each(array._chartjs.listeners, function (object) {
                if (typeof object[method] === 'function') {
                  object[method].apply(object, args)
                }
              });
              return res
            }
          })
        })
      }
      /**
	 * Removes the given array event listener and cleanup extra attached properties (such as
	 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
	 */
      function unlistenArrayEvents(array, listener) {
        var stub = array._chartjs;
        if (!stub) {
          return
        }
        var listeners = stub.listeners;
        var index = listeners.indexOf(listener);
        if (index !== -1) {
          listeners.splice(index, 1)
        }
        if (listeners.length > 0) {
          return
        }
        arrayEvents.forEach(function (key) {
          delete array[key]
        });
        delete array._chartjs
      }
      // Base class for all dataset controllers (line, bar, etc)
      Chart.DatasetController = function (chart, datasetIndex) {
        this.initialize(chart, datasetIndex)
      };
      helpers.extend(Chart.DatasetController.prototype, {
        /**
		 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
		 * @type {Chart.core.element}
		 */
        datasetElementType: null,
        /**
		 * Element type used to generate a meta data (e.g. Chart.element.Point).
		 * @type {Chart.core.element}
		 */
        dataElementType: null,
        initialize: function (chart, datasetIndex) {
          var me = this;
          me.chart = chart;
          me.index = datasetIndex;
          me.linkScales();
          me.addElements()
        },
        updateIndex: function (datasetIndex) {
          this.index = datasetIndex
        },
        linkScales: function () {
          var me = this;
          var meta = me.getMeta();
          var dataset = me.getDataset();
          if (meta.xAxisID === null) {
            meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id
          }
          if (meta.yAxisID === null) {
            meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id
          }
        },
        getDataset: function () {
          return this.chart.data.datasets[this.index]
        },
        getMeta: function () {
          return this.chart.getDatasetMeta(this.index)
        },
        getScaleForId: function (scaleID) {
          return this.chart.scales[scaleID]
        },
        reset: function () {
          this.update(true)
        },
        /**
		 * @private
		 */
        destroy: function () {
          if (this._data) {
            unlistenArrayEvents(this._data, this)
          }
        },
        createMetaDataset: function () {
          var me = this;
          var type = me.datasetElementType;
          return type && new type({
            _chart: me.chart.chart,
            _datasetIndex: me.index
          })
        },
        createMetaData: function (index) {
          var me = this;
          var type = me.dataElementType;
          return type && new type({
            _chart: me.chart.chart,
            _datasetIndex: me.index,
            _index: index
          })
        },
        addElements: function () {
          var me = this;
          var meta = me.getMeta();
          var data = me.getDataset().data || [];
          var metaData = meta.data;
          var i, ilen;
          for (i = 0, ilen = data.length; i < ilen; ++i) {
            metaData[i] = metaData[i] || me.createMetaData(i)
          }
          meta.dataset = meta.dataset || me.createMetaDataset()
        },
        addElementAndReset: function (index) {
          var element = this.createMetaData(index);
          this.getMeta().data.splice(index, 0, element);
          this.updateElement(element, index, true)
        },
        buildOrUpdateElements: function () {
          var me = this;
          var dataset = me.getDataset();
          var data = dataset.data || (dataset.data = []);
          // In order to correctly handle data addition/deletion animation (an thus simulate
          // real-time charts), we need to monitor these data modifications and synchronize
          // the internal meta data accordingly.
          if (me._data !== data) {
            if (me._data) {
              // This case happens when the user replaced the data array instance.
              unlistenArrayEvents(me._data, me)
            }
            listenArrayEvents(data, me);
            me._data = data
          }
          // Re-sync meta data in case the user replaced the data array or if we missed
          // any updates and so make sure that we handle number of datapoints changing.
          me.resyncElements()
        },
        update: helpers.noop,
        draw: function (ease) {
          var easingDecimal = ease || 1;
          var i, len;
          var metaData = this.getMeta().data;
          for (i = 0, len = metaData.length; i < len; ++i) {
            metaData[i].transition(easingDecimal).draw()
          }
        },
        removeHoverStyle: function (element, elementOpts) {
          var dataset = this.chart.data.datasets[element._datasetIndex], index = element._index, custom = element.custom || {}, valueOrDefault = helpers.getValueAtIndexOrDefault, model = element._model;
          model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
          model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
          model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth)
        },
        setHoverStyle: function (element) {
          var dataset = this.chart.data.datasets[element._datasetIndex], index = element._index, custom = element.custom || {}, valueOrDefault = helpers.getValueAtIndexOrDefault, getHoverColor = helpers.getHoverColor, model = element._model;
          model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
          model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
          model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth)
        },
        /**
		 * @private
		 */
        resyncElements: function () {
          var me = this;
          var meta = me.getMeta();
          var data = me.getDataset().data;
          var numMeta = meta.data.length;
          var numData = data.length;
          if (numData < numMeta) {
            meta.data.splice(numData, numMeta - numData)
          } else if (numData > numMeta) {
            me.insertElements(numMeta, numData - numMeta)
          }
        },
        /**
		 * @private
		 */
        insertElements: function (start, count) {
          for (var i = 0; i < count; ++i) {
            this.addElementAndReset(start + i)
          }
        },
        /**
		 * @private
		 */
        onDataPush: function () {
          this.insertElements(this.getDataset().data.length - 1, arguments.length)
        },
        /**
		 * @private
		 */
        onDataPop: function () {
          this.getMeta().data.pop()
        },
        /**
		 * @private
		 */
        onDataShift: function () {
          this.getMeta().data.shift()
        },
        /**
		 * @private
		 */
        onDataSplice: function (start, count) {
          this.getMeta().data.splice(start, count);
          this.insertElements(start, arguments.length - 2)
        },
        /**
		 * @private
		 */
        onDataUnshift: function () {
          this.insertElements(0, arguments.length)
        }
      });
      Chart.DatasetController.extend = helpers.inherits
    }
  });
  // source: node_modules/chart.js/src/core/core.layoutService.js
  rqzt.define('chart.js/src/core/core.layoutService', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      // The layout service is very self explanatory.  It's responsible for the layout within a chart.
      // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
      // It is this service's responsibility of carrying out that layout.
      Chart.layoutService = {
        defaults: {},
        // Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.
        addBox: function (chartInstance, box) {
          if (!chartInstance.boxes) {
            chartInstance.boxes = []
          }
          chartInstance.boxes.push(box)
        },
        removeBox: function (chartInstance, box) {
          if (!chartInstance.boxes) {
            return
          }
          chartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1)
        },
        // The most important function
        update: function (chartInstance, width, height) {
          if (!chartInstance) {
            return
          }
          var layoutOptions = chartInstance.options.layout;
          var padding = layoutOptions ? layoutOptions.padding : null;
          var leftPadding = 0;
          var rightPadding = 0;
          var topPadding = 0;
          var bottomPadding = 0;
          if (!isNaN(padding)) {
            // options.layout.padding is a number. assign to all
            leftPadding = padding;
            rightPadding = padding;
            topPadding = padding;
            bottomPadding = padding
          } else {
            leftPadding = padding.left || 0;
            rightPadding = padding.right || 0;
            topPadding = padding.top || 0;
            bottomPadding = padding.bottom || 0
          }
          var leftBoxes = helpers.where(chartInstance.boxes, function (box) {
            return box.options.position === 'left'
          });
          var rightBoxes = helpers.where(chartInstance.boxes, function (box) {
            return box.options.position === 'right'
          });
          var topBoxes = helpers.where(chartInstance.boxes, function (box) {
            return box.options.position === 'top'
          });
          var bottomBoxes = helpers.where(chartInstance.boxes, function (box) {
            return box.options.position === 'bottom'
          });
          // Boxes that overlay the chartarea such as the radialLinear scale
          var chartAreaBoxes = helpers.where(chartInstance.boxes, function (box) {
            return box.options.position === 'chartArea'
          });
          // Ensure that full width boxes are at the very top / bottom
          topBoxes.sort(function (a, b) {
            return (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0)
          });
          bottomBoxes.sort(function (a, b) {
            return (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0)
          });
          // Essentially we now have any number of boxes on each of the 4 sides.
          // Our canvas looks like the following.
          // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
          // B1 is the bottom axis
          // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
          // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
          // an error will be thrown.
          //
          // |----------------------------------------------------|
          // |                  T1 (Full Width)                   |
          // |----------------------------------------------------|
          // |    |    |                 T2                  |    |
          // |    |----|-------------------------------------|----|
          // |    |    | C1 |                           | C2 |    |
          // |    |    |----|                           |----|    |
          // |    |    |                                     |    |
          // | L1 | L2 |           ChartArea (C0)            | R1 |
          // |    |    |                                     |    |
          // |    |    |----|                           |----|    |
          // |    |    | C3 |                           | C4 |    |
          // |    |----|-------------------------------------|----|
          // |    |    |                 B1                  |    |
          // |----------------------------------------------------|
          // |                  B2 (Full Width)                   |
          // |----------------------------------------------------|
          //
          // What we do to find the best sizing, we do the following
          // 1. Determine the minimum size of the chart area.
          // 2. Split the remaining width equally between each vertical axis
          // 3. Split the remaining height equally between each horizontal axis
          // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
          // 5. Adjust the sizes of each axis based on it's minimum reported size.
          // 6. Refit each axis
          // 7. Position each axis in the final location
          // 8. Tell the chart the final location of the chart area
          // 9. Tell any axes that overlay the chart area the positions of the chart area
          // Step 1
          var chartWidth = width - leftPadding - rightPadding;
          var chartHeight = height - topPadding - bottomPadding;
          var chartAreaWidth = chartWidth / 2;
          // min 50%
          var chartAreaHeight = chartHeight / 2;
          // min 50%
          // Step 2
          var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);
          // Step 3
          var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);
          // Step 4
          var maxChartAreaWidth = chartWidth;
          var maxChartAreaHeight = chartHeight;
          var minBoxSizes = [];
          function getMinimumBoxSize(box) {
            var minSize;
            var isHorizontal = box.isHorizontal();
            if (isHorizontal) {
              minSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
              maxChartAreaHeight -= minSize.height
            } else {
              minSize = box.update(verticalBoxWidth, chartAreaHeight);
              maxChartAreaWidth -= minSize.width
            }
            minBoxSizes.push({
              horizontal: isHorizontal,
              minSize: minSize,
              box: box
            })
          }
          helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);
          // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
          // be if the axes are drawn at their minimum sizes.
          // Steps 5 & 6
          var totalLeftBoxesWidth = leftPadding;
          var totalRightBoxesWidth = rightPadding;
          var totalTopBoxesHeight = topPadding;
          var totalBottomBoxesHeight = bottomPadding;
          // Function to fit a box
          function fitBox(box) {
            var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {
              return minBox.box === box
            });
            if (minBoxSize) {
              if (box.isHorizontal()) {
                var scaleMargin = {
                  left: totalLeftBoxesWidth,
                  right: totalRightBoxesWidth,
                  top: 0,
                  bottom: 0
                };
                // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
                // on the margin. Sometimes they need to increase in size slightly
                box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin)
              } else {
                box.update(minBoxSize.minSize.width, maxChartAreaHeight)
              }
            }
          }
          // Update, and calculate the left and right margins for the horizontal boxes
          helpers.each(leftBoxes.concat(rightBoxes), fitBox);
          helpers.each(leftBoxes, function (box) {
            totalLeftBoxesWidth += box.width
          });
          helpers.each(rightBoxes, function (box) {
            totalRightBoxesWidth += box.width
          });
          // Set the Left and Right margins for the horizontal boxes
          helpers.each(topBoxes.concat(bottomBoxes), fitBox);
          // Figure out how much margin is on the top and bottom of the vertical boxes
          helpers.each(topBoxes, function (box) {
            totalTopBoxesHeight += box.height
          });
          helpers.each(bottomBoxes, function (box) {
            totalBottomBoxesHeight += box.height
          });
          function finalFitVerticalBox(box) {
            var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {
              return minSize.box === box
            });
            var scaleMargin = {
              left: 0,
              right: 0,
              top: totalTopBoxesHeight,
              bottom: totalBottomBoxesHeight
            };
            if (minBoxSize) {
              box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin)
            }
          }
          // Let the left layout know the final margin
          helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);
          // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
          totalLeftBoxesWidth = leftPadding;
          totalRightBoxesWidth = rightPadding;
          totalTopBoxesHeight = topPadding;
          totalBottomBoxesHeight = bottomPadding;
          helpers.each(leftBoxes, function (box) {
            totalLeftBoxesWidth += box.width
          });
          helpers.each(rightBoxes, function (box) {
            totalRightBoxesWidth += box.width
          });
          helpers.each(topBoxes, function (box) {
            totalTopBoxesHeight += box.height
          });
          helpers.each(bottomBoxes, function (box) {
            totalBottomBoxesHeight += box.height
          });
          // Figure out if our chart area changed. This would occur if the dataset layout label rotation
          // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
          // without calling `fit` again
          var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
          var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;
          if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
            helpers.each(leftBoxes, function (box) {
              box.height = newMaxChartAreaHeight
            });
            helpers.each(rightBoxes, function (box) {
              box.height = newMaxChartAreaHeight
            });
            helpers.each(topBoxes, function (box) {
              if (!box.options.fullWidth) {
                box.width = newMaxChartAreaWidth
              }
            });
            helpers.each(bottomBoxes, function (box) {
              if (!box.options.fullWidth) {
                box.width = newMaxChartAreaWidth
              }
            });
            maxChartAreaHeight = newMaxChartAreaHeight;
            maxChartAreaWidth = newMaxChartAreaWidth
          }
          // Step 7 - Position the boxes
          var left = leftPadding;
          var top = topPadding;
          function placeBox(box) {
            if (box.isHorizontal()) {
              box.left = box.options.fullWidth ? leftPadding : totalLeftBoxesWidth;
              box.right = box.options.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
              box.top = top;
              box.bottom = top + box.height;
              // Move to next point
              top = box.bottom
            } else {
              box.left = left;
              box.right = left + box.width;
              box.top = totalTopBoxesHeight;
              box.bottom = totalTopBoxesHeight + maxChartAreaHeight;
              // Move to next point
              left = box.right
            }
          }
          helpers.each(leftBoxes.concat(topBoxes), placeBox);
          // Account for chart width and height
          left += maxChartAreaWidth;
          top += maxChartAreaHeight;
          helpers.each(rightBoxes, placeBox);
          helpers.each(bottomBoxes, placeBox);
          // Step 8
          chartInstance.chartArea = {
            left: totalLeftBoxesWidth,
            top: totalTopBoxesHeight,
            right: totalLeftBoxesWidth + maxChartAreaWidth,
            bottom: totalTopBoxesHeight + maxChartAreaHeight
          };
          // Step 9
          helpers.each(chartAreaBoxes, function (box) {
            box.left = chartInstance.chartArea.left;
            box.top = chartInstance.chartArea.top;
            box.right = chartInstance.chartArea.right;
            box.bottom = chartInstance.chartArea.bottom;
            box.update(maxChartAreaWidth, maxChartAreaHeight)
          })
        }
      }
    }
  });
  // source: node_modules/chart.js/src/core/core.scaleService.js
  rqzt.define('chart.js/src/core/core.scaleService', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.scaleService = {
        // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
        // use the new chart options to grab the correct scale
        constructors: {},
        // Use a registration function so that we can move to an ES6 map when we no longer need to support
        // old browsers
        // Scale config defaults
        defaults: {},
        registerScaleType: function (type, scaleConstructor, defaults) {
          this.constructors[type] = scaleConstructor;
          this.defaults[type] = helpers.clone(defaults)
        },
        getScaleConstructor: function (type) {
          return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined
        },
        getScaleDefaults: function (type) {
          // Return the scale defaults merged with the global settings so that we always use the latest ones
          return this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {}
        },
        updateScaleDefaults: function (type, additions) {
          var defaults = this.defaults;
          if (defaults.hasOwnProperty(type)) {
            defaults[type] = helpers.extend(defaults[type], additions)
          }
        },
        addScalesToLayout: function (chartInstance) {
          // Adds each scale to the chart.boxes array to be sized accordingly
          helpers.each(chartInstance.scales, function (scale) {
            Chart.layoutService.addBox(chartInstance, scale)
          })
        }
      }
    }
  });
  // source: node_modules/chart.js/src/core/core.plugin.js
  rqzt.define('chart.js/src/core/core.plugin', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var noop = Chart.helpers.noop;
      /**
	 * The plugin service singleton
	 * @namespace Chart.plugins
	 * @since 2.1.0
	 */
      Chart.plugins = {
        _plugins: [],
        /**
		 * Registers the given plugin(s) if not already registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
        register: function (plugins) {
          var p = this._plugins;
          [].concat(plugins).forEach(function (plugin) {
            if (p.indexOf(plugin) === -1) {
              p.push(plugin)
            }
          })
        },
        /**
		 * Unregisters the given plugin(s) only if registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
        unregister: function (plugins) {
          var p = this._plugins;
          [].concat(plugins).forEach(function (plugin) {
            var idx = p.indexOf(plugin);
            if (idx !== -1) {
              p.splice(idx, 1)
            }
          })
        },
        /**
		 * Remove all registered plugins.
		 * @since 2.1.5
		 */
        clear: function () {
          this._plugins = []
        },
        /**
		 * Returns the number of registered plugins?
		 * @returns {Number}
		 * @since 2.1.5
		 */
        count: function () {
          return this._plugins.length
        },
        /**
		 * Returns all registered plugin instances.
		 * @returns {Array} array of plugin objects.
		 * @since 2.1.5
		 */
        getAll: function () {
          return this._plugins
        },
        /**
		 * Calls registered plugins on the specified extension, with the given args. This
		 * method immediately returns as soon as a plugin explicitly returns false. The
		 * returned value can be used, for instance, to interrupt the current action.
		 * @param {String} extension the name of the plugin method to call (e.g. 'beforeUpdate').
		 * @param {Array} [args] extra arguments to apply to the extension call.
		 * @returns {Boolean} false if any of the plugins return false, else returns true.
		 */
        notify: function (extension, args) {
          var plugins = this._plugins;
          var ilen = plugins.length;
          var i, plugin;
          for (i = 0; i < ilen; ++i) {
            plugin = plugins[i];
            if (typeof plugin[extension] === 'function') {
              if (plugin[extension].apply(plugin, args || []) === false) {
                return false
              }
            }
          }
          return true
        }
      };
      /**
	 * Plugin extension methods.
	 * @interface Chart.PluginBase
	 * @since 2.1.0
	 */
      Chart.PluginBase = Chart.Element.extend({
        // Called at start of chart init
        beforeInit: noop,
        // Called at end of chart init
        afterInit: noop,
        // Called at start of update
        beforeUpdate: noop,
        // Called at end of update
        afterUpdate: noop,
        // Called at start of draw
        beforeDraw: noop,
        // Called at end of draw
        afterDraw: noop,
        // Called during destroy
        destroy: noop
      });
      /**
	 * Provided for backward compatibility, use Chart.plugins instead
	 * @namespace Chart.pluginService
	 * @deprecated since version 2.1.5
	 * @todo remove me at version 3
	 */
      Chart.pluginService = Chart.plugins
    }
  });
  // source: node_modules/chart.js/src/core/core.ticks.js
  rqzt.define('chart.js/src/core/core.ticks', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      /**
	 * Namespace to hold static tick generation functions
	 * @namespace Chart.Ticks
	 */
      Chart.Ticks = {
        /**
		 * Namespace to hold generators for different types of ticks
		 * @namespace Chart.Ticks.generators
		 */
        generators: {
          /**
			 * Interface for the options provided to the numeric tick generator
			 * @interface INumericTickGenerationOptions
			 */
          /**
			 * The maximum number of ticks to display
			 * @name INumericTickGenerationOptions#maxTicks
			 * @type Number
			 */
          /**
			 * The distance between each tick.
			 * @name INumericTickGenerationOptions#stepSize
			 * @type Number
			 * @optional
			 */
          /**
			 * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
			 * @name INumericTickGenerationOptions#min
			 * @type Number
			 * @optional
			 */
          /**
			 * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
			 * @name INumericTickGenerationOptions#max
			 * @type Number
			 * @optional
			 */
          /**
			 * Generate a set of linear ticks
			 * @method Chart.Ticks.generators.linear
			 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
			 * @param dataRange {IRange} the range of the data
			 * @returns {Array<Number>} array of tick values
			 */
          linear: function (generationOptions, dataRange) {
            var ticks = [];
            // To get a "nice" value for the tick spacing, we will use the appropriately named
            // "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
            // for details.
            var spacing;
            if (generationOptions.stepSize && generationOptions.stepSize > 0) {
              spacing = generationOptions.stepSize
            } else {
              var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
              spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true)
            }
            var niceMin = Math.floor(dataRange.min / spacing) * spacing;
            var niceMax = Math.ceil(dataRange.max / spacing) * spacing;
            // If min, max and stepSize is set and they make an evenly spaced scale use it.
            if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
              var minMaxDeltaDivisibleByStepSize = (generationOptions.max - generationOptions.min) % generationOptions.stepSize === 0;
              if (minMaxDeltaDivisibleByStepSize) {
                niceMin = generationOptions.min;
                niceMax = generationOptions.max
              }
            }
            var numSpaces = (niceMax - niceMin) / spacing;
            // If very close to our rounded value, use it.
            if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
              numSpaces = Math.round(numSpaces)
            } else {
              numSpaces = Math.ceil(numSpaces)
            }
            // Put the values into the ticks array
            ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
            for (var j = 1; j < numSpaces; ++j) {
              ticks.push(niceMin + j * spacing)
            }
            ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);
            return ticks
          },
          /**
			 * Generate a set of logarithmic ticks
			 * @method Chart.Ticks.generators.logarithmic
			 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
			 * @param dataRange {IRange} the range of the data
			 * @returns {Array<Number>} array of tick values
			 */
          logarithmic: function (generationOptions, dataRange) {
            var ticks = [];
            var getValueOrDefault = helpers.getValueOrDefault;
            // Figure out what the max number of ticks we can support it is based on the size of
            // the axis area. For now, we say that the minimum tick spacing in pixels must be 50
            // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
            // the graph
            var tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
            while (tickVal < dataRange.max) {
              ticks.push(tickVal);
              var exp;
              var significand;
              if (tickVal === 0) {
                exp = Math.floor(helpers.log10(dataRange.minNotZero));
                significand = Math.round(dataRange.minNotZero / Math.pow(10, exp))
              } else {
                exp = Math.floor(helpers.log10(tickVal));
                significand = Math.floor(tickVal / Math.pow(10, exp)) + 1
              }
              if (significand === 10) {
                significand = 1;
                ++exp
              }
              tickVal = significand * Math.pow(10, exp)
            }
            var lastTick = getValueOrDefault(generationOptions.max, tickVal);
            ticks.push(lastTick);
            return ticks
          }
        },
        /**
		 * Namespace to hold formatters for different types of ticks
		 * @namespace Chart.Ticks.formatters
		 */
        formatters: {
          /**
			 * Formatter for value labels
			 * @method Chart.Ticks.formatters.values
			 * @param value the value to display
			 * @return {String|Array} the label to display
			 */
          values: function (value) {
            return helpers.isArray(value) ? value : '' + value
          },
          /**
			 * Formatter for linear numeric ticks
			 * @method Chart.Ticks.formatters.linear
			 * @param tickValue {Number} the value to be formatted
			 * @param index {Number} the position of the tickValue parameter in the ticks array
			 * @param ticks {Array<Number>} the list of ticks being converted
			 * @return {String} string representation of the tickValue parameter
			 */
          linear: function (tickValue, index, ticks) {
            // If we have lots of ticks, don't use the ones
            var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
            // If we have a number like 2.5 as the delta, figure out how many decimal places we need
            if (Math.abs(delta) > 1) {
              if (tickValue !== Math.floor(tickValue)) {
                // not an integer
                delta = tickValue - Math.floor(tickValue)
              }
            }
            var logDelta = helpers.log10(Math.abs(delta));
            var tickString = '';
            if (tickValue !== 0) {
              var numDecimal = -1 * Math.floor(logDelta);
              numDecimal = Math.max(Math.min(numDecimal, 20), 0);
              // toFixed has a max of 20 decimal places
              tickString = tickValue.toFixed(numDecimal)
            } else {
              tickString = '0'  // never show decimal places for 0
            }
            return tickString
          },
          logarithmic: function (tickValue, index, ticks) {
            var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));
            if (tickValue === 0) {
              return '0'
            } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
              return tickValue.toExponential()
            }
            return ''
          }
        }
      }
    }
  });
  // source: node_modules/chart.js/src/core/core.scale.js
  rqzt.define('chart.js/src/core/core.scale', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.defaults.scale = {
        display: true,
        position: 'left',
        // grid line settings
        gridLines: {
          display: true,
          color: 'rgba(0, 0, 0, 0.1)',
          lineWidth: 1,
          drawBorder: true,
          drawOnChartArea: true,
          drawTicks: true,
          tickMarkLength: 10,
          zeroLineWidth: 1,
          zeroLineColor: 'rgba(0,0,0,0.25)',
          offsetGridLines: false,
          borderDash: [],
          borderDashOffset: 0
        },
        // scale label
        scaleLabel: {
          // actual label
          labelString: '',
          // display property
          display: false
        },
        // label settings
        ticks: {
          beginAtZero: false,
          minRotation: 0,
          maxRotation: 50,
          mirror: false,
          padding: 10,
          reverse: false,
          display: true,
          autoSkip: true,
          autoSkipPadding: 0,
          labelOffset: 0,
          // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
          callback: Chart.Ticks.formatters.values
        }
      };
      Chart.Scale = Chart.Element.extend({
        // These methods are ordered by lifecycle. Utilities then follow.
        // Any function defined here is inherited by all scale types.
        // Any function can be extended by the scale type
        beforeUpdate: function () {
          helpers.callCallback(this.options.beforeUpdate, [this])
        },
        update: function (maxWidth, maxHeight, margins) {
          var me = this;
          // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
          me.beforeUpdate();
          // Absorb the master measurements
          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = helpers.extend({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, margins);
          // Dimensions
          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions();
          // Data min/max
          me.beforeDataLimits();
          me.determineDataLimits();
          me.afterDataLimits();
          // Ticks
          me.beforeBuildTicks();
          me.buildTicks();
          me.afterBuildTicks();
          me.beforeTickToLabelConversion();
          me.convertTicksToLabels();
          me.afterTickToLabelConversion();
          // Tick Rotation
          me.beforeCalculateTickRotation();
          me.calculateTickRotation();
          me.afterCalculateTickRotation();
          // Fit
          me.beforeFit();
          me.fit();
          me.afterFit();
          //
          me.afterUpdate();
          return me.minSize
        },
        afterUpdate: function () {
          helpers.callCallback(this.options.afterUpdate, [this])
        },
        //
        beforeSetDimensions: function () {
          helpers.callCallback(this.options.beforeSetDimensions, [this])
        },
        setDimensions: function () {
          var me = this;
          // Set the unconstrained dimension before label rotation
          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width
          } else {
            me.height = me.maxHeight;
            // Reset position before calculating rotation
            me.top = 0;
            me.bottom = me.height
          }
          // Reset padding
          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0
        },
        afterSetDimensions: function () {
          helpers.callCallback(this.options.afterSetDimensions, [this])
        },
        // Data limits
        beforeDataLimits: function () {
          helpers.callCallback(this.options.beforeDataLimits, [this])
        },
        determineDataLimits: helpers.noop,
        afterDataLimits: function () {
          helpers.callCallback(this.options.afterDataLimits, [this])
        },
        //
        beforeBuildTicks: function () {
          helpers.callCallback(this.options.beforeBuildTicks, [this])
        },
        buildTicks: helpers.noop,
        afterBuildTicks: function () {
          helpers.callCallback(this.options.afterBuildTicks, [this])
        },
        beforeTickToLabelConversion: function () {
          helpers.callCallback(this.options.beforeTickToLabelConversion, [this])
        },
        convertTicksToLabels: function () {
          var me = this;
          // Convert ticks to strings
          var tickOpts = me.options.ticks;
          me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback)
        },
        afterTickToLabelConversion: function () {
          helpers.callCallback(this.options.afterTickToLabelConversion, [this])
        },
        //
        beforeCalculateTickRotation: function () {
          helpers.callCallback(this.options.beforeCalculateTickRotation, [this])
        },
        calculateTickRotation: function () {
          var me = this;
          var context = me.ctx;
          var globalDefaults = Chart.defaults.global;
          var optionTicks = me.options.ticks;
          // Get the width of each grid by calculating the difference
          // between x offsets between 0 and 1.
          var tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);
          var tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);
          var tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);
          var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
          context.font = tickLabelFont;
          var firstWidth = context.measureText(me.ticks[0]).width;
          var lastWidth = context.measureText(me.ticks[me.ticks.length - 1]).width;
          var firstRotated;
          me.labelRotation = optionTicks.minRotation || 0;
          me.paddingRight = 0;
          me.paddingLeft = 0;
          if (me.options.display) {
            if (me.isHorizontal()) {
              me.paddingRight = lastWidth / 2 + 3;
              me.paddingLeft = firstWidth / 2 + 3;
              if (!me.longestTextCache) {
                me.longestTextCache = {}
              }
              var originalLabelWidth = helpers.longestText(context, tickLabelFont, me.ticks, me.longestTextCache);
              var labelWidth = originalLabelWidth;
              var cosRotation;
              var sinRotation;
              // Allow 3 pixels x2 padding either side for label readability
              // only the index matters for a dataset scale, but we want a consistent interface between scales
              var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;
              // Max label rotation can be set or default to 90 - also act as a loop counter
              while (labelWidth > tickWidth && me.labelRotation < optionTicks.maxRotation) {
                cosRotation = Math.cos(helpers.toRadians(me.labelRotation));
                sinRotation = Math.sin(helpers.toRadians(me.labelRotation));
                firstRotated = cosRotation * firstWidth;
                // We're right aligning the text now.
                if (firstRotated + tickFontSize / 2 > me.yLabelWidth) {
                  me.paddingLeft = firstRotated + tickFontSize / 2
                }
                me.paddingRight = tickFontSize / 2;
                if (sinRotation * originalLabelWidth > me.maxHeight) {
                  // go back one step
                  me.labelRotation--;
                  break
                }
                me.labelRotation++;
                labelWidth = cosRotation * originalLabelWidth
              }
            }
          }
          if (me.margins) {
            me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
            me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0)
          }
        },
        afterCalculateTickRotation: function () {
          helpers.callCallback(this.options.afterCalculateTickRotation, [this])
        },
        //
        beforeFit: function () {
          helpers.callCallback(this.options.beforeFit, [this])
        },
        fit: function () {
          var me = this;
          // Reset
          var minSize = me.minSize = {
            width: 0,
            height: 0
          };
          var opts = me.options;
          var globalDefaults = Chart.defaults.global;
          var tickOpts = opts.ticks;
          var scaleLabelOpts = opts.scaleLabel;
          var gridLineOpts = opts.gridLines;
          var display = opts.display;
          var isHorizontal = me.isHorizontal();
          var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
          var tickFontStyle = helpers.getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
          var tickFontFamily = helpers.getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
          var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
          var scaleLabelFontSize = helpers.getValueOrDefault(scaleLabelOpts.fontSize, globalDefaults.defaultFontSize);
          var tickMarkLength = opts.gridLines.tickMarkLength;
          // Width
          if (isHorizontal) {
            // subtract the margins to line up with the chartArea if we are a full width scale
            minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth
          } else {
            minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0
          }
          // height
          if (isHorizontal) {
            minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0
          } else {
            minSize.height = me.maxHeight  // fill all the height
          }
          // Are we showing a title for the scale?
          if (scaleLabelOpts.display && display) {
            if (isHorizontal) {
              minSize.height += scaleLabelFontSize * 1.5
            } else {
              minSize.width += scaleLabelFontSize * 1.5
            }
          }
          if (tickOpts.display && display) {
            // Don't bother fitting the ticks if we are not showing them
            if (!me.longestTextCache) {
              me.longestTextCache = {}
            }
            var largestTextWidth = helpers.longestText(me.ctx, tickLabelFont, me.ticks, me.longestTextCache);
            var tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);
            var lineSpace = tickFontSize * 0.5;
            if (isHorizontal) {
              // A horizontal axis is more constrained by the height.
              me.longestLabelWidth = largestTextWidth;
              // TODO - improve this calculation
              var labelHeight = Math.sin(helpers.toRadians(me.labelRotation)) * me.longestLabelWidth + tickFontSize * tallestLabelHeightInLines + lineSpace * tallestLabelHeightInLines;
              minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);
              me.ctx.font = tickLabelFont;
              var firstLabelWidth = me.ctx.measureText(me.ticks[0]).width;
              var lastLabelWidth = me.ctx.measureText(me.ticks[me.ticks.length - 1]).width;
              // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated
              // by the font height
              var cosRotation = Math.cos(helpers.toRadians(me.labelRotation));
              var sinRotation = Math.sin(helpers.toRadians(me.labelRotation));
              me.paddingLeft = me.labelRotation !== 0 ? cosRotation * firstLabelWidth + 3 : firstLabelWidth / 2 + 3;
              // add 3 px to move away from canvas edges
              me.paddingRight = me.labelRotation !== 0 ? sinRotation * (tickFontSize / 2) + 3 : lastLabelWidth / 2 + 3  // when rotated
            } else {
              // A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first
              var maxLabelWidth = me.maxWidth - minSize.width;
              // Account for padding
              var mirror = tickOpts.mirror;
              if (!mirror) {
                largestTextWidth += me.options.ticks.padding
              } else {
                // If mirrored text is on the inside so don't expand
                largestTextWidth = 0
              }
              if (largestTextWidth < maxLabelWidth) {
                // We don't need all the room
                minSize.width += largestTextWidth
              } else {
                // Expand to max size
                minSize.width = me.maxWidth
              }
              me.paddingTop = tickFontSize / 2;
              me.paddingBottom = tickFontSize / 2
            }
          }
          if (me.margins) {
            me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
            me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
            me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
            me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0)
          }
          me.width = minSize.width;
          me.height = minSize.height
        },
        afterFit: function () {
          helpers.callCallback(this.options.afterFit, [this])
        },
        // Shared Methods
        isHorizontal: function () {
          return this.options.position === 'top' || this.options.position === 'bottom'
        },
        isFullWidth: function () {
          return this.options.fullWidth
        },
        // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
        getRightValue: function (rawValue) {
          // Null and undefined values first
          if (rawValue === null || typeof rawValue === 'undefined') {
            return NaN
          }
          // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
          if (typeof rawValue === 'number' && !isFinite(rawValue)) {
            return NaN
          }
          // If it is in fact an object, dive in one more level
          if (typeof rawValue === 'object') {
            if (rawValue instanceof Date || rawValue.isValid) {
              return rawValue
            }
            return this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y)
          }
          // Value is good, return it
          return rawValue
        },
        // Used to get the value to display in the tooltip for the data at the given index
        // function getLabelForIndex(index, datasetIndex)
        getLabelForIndex: helpers.noop,
        // Used to get data value locations.  Value can either be an index or a numerical value
        getPixelForValue: helpers.noop,
        // Used to get the data value from a given pixel. This is the inverse of getPixelForValue
        getValueForPixel: helpers.noop,
        // Used for tick location, should
        getPixelForTick: function (index, includeOffset) {
          var me = this;
          if (me.isHorizontal()) {
            var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
            var tickWidth = innerWidth / Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);
            var pixel = tickWidth * index + me.paddingLeft;
            if (includeOffset) {
              pixel += tickWidth / 2
            }
            var finalVal = me.left + Math.round(pixel);
            finalVal += me.isFullWidth() ? me.margins.left : 0;
            return finalVal
          }
          var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
          return me.top + index * (innerHeight / (me.ticks.length - 1))
        },
        // Utility for getting the pixel location of a percentage of scale
        getPixelForDecimal: function (decimal) {
          var me = this;
          if (me.isHorizontal()) {
            var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
            var valueOffset = innerWidth * decimal + me.paddingLeft;
            var finalVal = me.left + Math.round(valueOffset);
            finalVal += me.isFullWidth() ? me.margins.left : 0;
            return finalVal
          }
          return me.top + decimal * me.height
        },
        getBasePixel: function () {
          var me = this;
          var min = me.min;
          var max = me.max;
          return me.getPixelForValue(me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0)
        },
        // Actually draw the scale on the canvas
        // @param {rectangle} chartArea : the area of the chart to draw full grid lines on
        draw: function (chartArea) {
          var me = this;
          var options = me.options;
          if (!options.display) {
            return
          }
          var context = me.ctx;
          var globalDefaults = Chart.defaults.global;
          var optionTicks = options.ticks;
          var gridLines = options.gridLines;
          var scaleLabel = options.scaleLabel;
          var isRotated = me.labelRotation !== 0;
          var skipRatio;
          var useAutoskipper = optionTicks.autoSkip;
          var isHorizontal = me.isHorizontal();
          // figure out the maximum number of gridlines to show
          var maxTicks;
          if (optionTicks.maxTicksLimit) {
            maxTicks = optionTicks.maxTicksLimit
          }
          var tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
          var tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);
          var tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);
          var tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);
          var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
          var tl = gridLines.tickMarkLength;
          var borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
          var borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
          var scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
          var scaleLabelFontSize = helpers.getValueOrDefault(scaleLabel.fontSize, globalDefaults.defaultFontSize);
          var scaleLabelFontStyle = helpers.getValueOrDefault(scaleLabel.fontStyle, globalDefaults.defaultFontStyle);
          var scaleLabelFontFamily = helpers.getValueOrDefault(scaleLabel.fontFamily, globalDefaults.defaultFontFamily);
          var scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);
          var labelRotationRadians = helpers.toRadians(me.labelRotation);
          var cosRotation = Math.cos(labelRotationRadians);
          var longestRotatedLabel = me.longestLabelWidth * cosRotation;
          // Make sure we draw text in the correct color and font
          context.fillStyle = tickFontColor;
          var itemsToDraw = [];
          if (isHorizontal) {
            skipRatio = false;
            // Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation
            // See #2584
            if (isRotated) {
              longestRotatedLabel /= 2
            }
            if ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > me.width - (me.paddingLeft + me.paddingRight)) {
              skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length / (me.width - (me.paddingLeft + me.paddingRight)))
            }
            // if they defined a max number of optionTicks,
            // increase skipRatio until that number is met
            if (maxTicks && me.ticks.length > maxTicks) {
              while (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {
                if (!skipRatio) {
                  skipRatio = 1
                }
                skipRatio += 1
              }
            }
            if (!useAutoskipper) {
              skipRatio = false
            }
          }
          var xTickStart = options.position === 'right' ? me.left : me.right - tl;
          var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
          var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
          var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;
          helpers.each(me.ticks, function (label, index) {
            // If the callback returned a null or undefined value, do not draw this line
            if (label === undefined || label === null) {
              return
            }
            var isLastTick = me.ticks.length === index + 1;
            // Since we always show the last tick,we need may need to hide the last shown one before
            var shouldSkip = skipRatio > 1 && index % skipRatio > 0 || index % skipRatio === 0 && index + skipRatio >= me.ticks.length;
            if (shouldSkip && !isLastTick || (label === undefined || label === null)) {
              return
            }
            var lineWidth, lineColor;
            if (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {
              // Draw the first index specially
              lineWidth = gridLines.zeroLineWidth;
              lineColor = gridLines.zeroLineColor
            } else {
              lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);
              lineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index)
            }
            // Common properties
            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
            var textAlign = 'middle';
            var textBaseline = 'middle';
            if (isHorizontal) {
              if (!isRotated) {
                textBaseline = options.position === 'top' ? 'bottom' : 'top'
              }
              textAlign = isRotated ? 'right' : 'center';
              var xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth);
              // xvalues for grid lines
              labelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset;
              // x values for optionTicks (need to consider offsetLabel option)
              labelY = isRotated ? me.top + 12 : options.position === 'top' ? me.bottom - tl : me.top + tl;
              tx1 = tx2 = x1 = x2 = xLineValue;
              ty1 = yTickStart;
              ty2 = yTickEnd;
              y1 = chartArea.top;
              y2 = chartArea.bottom
            } else {
              if (options.position === 'left') {
                if (optionTicks.mirror) {
                  labelX = me.right + optionTicks.padding;
                  textAlign = 'left'
                } else {
                  labelX = me.right - optionTicks.padding;
                  textAlign = 'right'
                }  // right side
              } else if (optionTicks.mirror) {
                labelX = me.left - optionTicks.padding;
                textAlign = 'right'
              } else {
                labelX = me.left + optionTicks.padding;
                textAlign = 'left'
              }
              var yLineValue = me.getPixelForTick(index);
              // xvalues for grid lines
              yLineValue += helpers.aliasPixel(lineWidth);
              labelY = me.getPixelForTick(index, gridLines.offsetGridLines);
              tx1 = xTickStart;
              tx2 = xTickEnd;
              x1 = chartArea.left;
              x2 = chartArea.right;
              ty1 = ty2 = y1 = y2 = yLineValue
            }
            itemsToDraw.push({
              tx1: tx1,
              ty1: ty1,
              tx2: tx2,
              ty2: ty2,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              labelX: labelX,
              labelY: labelY,
              glWidth: lineWidth,
              glColor: lineColor,
              glBorderDash: borderDash,
              glBorderDashOffset: borderDashOffset,
              rotation: -1 * labelRotationRadians,
              label: label,
              textBaseline: textBaseline,
              textAlign: textAlign
            })
          });
          // Draw all of the tick labels, tick marks, and grid lines at the correct places
          helpers.each(itemsToDraw, function (itemToDraw) {
            if (gridLines.display) {
              context.save();
              context.lineWidth = itemToDraw.glWidth;
              context.strokeStyle = itemToDraw.glColor;
              if (context.setLineDash) {
                context.setLineDash(itemToDraw.glBorderDash);
                context.lineDashOffset = itemToDraw.glBorderDashOffset
              }
              context.beginPath();
              if (gridLines.drawTicks) {
                context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
                context.lineTo(itemToDraw.tx2, itemToDraw.ty2)
              }
              if (gridLines.drawOnChartArea) {
                context.moveTo(itemToDraw.x1, itemToDraw.y1);
                context.lineTo(itemToDraw.x2, itemToDraw.y2)
              }
              context.stroke();
              context.restore()
            }
            if (optionTicks.display) {
              context.save();
              context.translate(itemToDraw.labelX, itemToDraw.labelY);
              context.rotate(itemToDraw.rotation);
              context.font = tickLabelFont;
              context.textBaseline = itemToDraw.textBaseline;
              context.textAlign = itemToDraw.textAlign;
              var label = itemToDraw.label;
              if (helpers.isArray(label)) {
                for (var i = 0, y = -(label.length - 1) * tickFontSize * 0.75; i < label.length; ++i) {
                  // We just make sure the multiline element is a string here..
                  context.fillText('' + label[i], 0, y);
                  // apply same lineSpacing as calculated @ L#320
                  y += tickFontSize * 1.5
                }
              } else {
                context.fillText(label, 0, 0)
              }
              context.restore()
            }
          });
          if (scaleLabel.display) {
            // Draw the scale label
            var scaleLabelX;
            var scaleLabelY;
            var rotation = 0;
            if (isHorizontal) {
              scaleLabelX = me.left + (me.right - me.left) / 2;
              // midpoint of the width
              scaleLabelY = options.position === 'bottom' ? me.bottom - scaleLabelFontSize / 2 : me.top + scaleLabelFontSize / 2
            } else {
              var isLeft = options.position === 'left';
              scaleLabelX = isLeft ? me.left + scaleLabelFontSize / 2 : me.right - scaleLabelFontSize / 2;
              scaleLabelY = me.top + (me.bottom - me.top) / 2;
              rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI
            }
            context.save();
            context.translate(scaleLabelX, scaleLabelY);
            context.rotate(rotation);
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = scaleLabelFontColor;
            // render in correct colour
            context.font = scaleLabelFont;
            context.fillText(scaleLabel.labelString, 0, 0);
            context.restore()
          }
          if (gridLines.drawBorder) {
            // Draw the line at the edge of the axis
            context.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);
            context.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);
            var x1 = me.left, x2 = me.right, y1 = me.top, y2 = me.bottom;
            var aliasPixel = helpers.aliasPixel(context.lineWidth);
            if (isHorizontal) {
              y1 = y2 = options.position === 'top' ? me.bottom : me.top;
              y1 += aliasPixel;
              y2 += aliasPixel
            } else {
              x1 = x2 = options.position === 'left' ? me.right : me.left;
              x1 += aliasPixel;
              x2 += aliasPixel
            }
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.stroke()
          }
        }
      })
    }
  });
  // source: node_modules/chart.js/src/core/core.title.js
  rqzt.define('chart.js/src/core/core.title', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.defaults.global.title = {
        display: false,
        position: 'top',
        fullWidth: true,
        // marks that this box should take the full width of the canvas (pushing down other boxes)
        fontStyle: 'bold',
        padding: 10,
        // actual title
        text: ''
      };
      var noop = helpers.noop;
      Chart.Title = Chart.Element.extend({
        initialize: function (config) {
          var me = this;
          helpers.extend(me, config);
          me.options = helpers.configMerge(Chart.defaults.global.title, config.options);
          // Contains hit boxes for each dataset (in dataset order)
          me.legendHitBoxes = []
        },
        // These methods are ordered by lifecycle. Utilities then follow.
        beforeUpdate: function () {
          var chartOpts = this.chart.options;
          if (chartOpts && chartOpts.title) {
            this.options = helpers.configMerge(Chart.defaults.global.title, chartOpts.title)
          }
        },
        update: function (maxWidth, maxHeight, margins) {
          var me = this;
          // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
          me.beforeUpdate();
          // Absorb the master measurements
          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = margins;
          // Dimensions
          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions();
          // Labels
          me.beforeBuildLabels();
          me.buildLabels();
          me.afterBuildLabels();
          // Fit
          me.beforeFit();
          me.fit();
          me.afterFit();
          //
          me.afterUpdate();
          return me.minSize
        },
        afterUpdate: noop,
        //
        beforeSetDimensions: noop,
        setDimensions: function () {
          var me = this;
          // Set the unconstrained dimension before label rotation
          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width
          } else {
            me.height = me.maxHeight;
            // Reset position before calculating rotation
            me.top = 0;
            me.bottom = me.height
          }
          // Reset padding
          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0;
          // Reset minSize
          me.minSize = {
            width: 0,
            height: 0
          }
        },
        afterSetDimensions: noop,
        //
        beforeBuildLabels: noop,
        buildLabels: noop,
        afterBuildLabels: noop,
        //
        beforeFit: noop,
        fit: function () {
          var me = this, valueOrDefault = helpers.getValueOrDefault, opts = me.options, globalDefaults = Chart.defaults.global, display = opts.display, fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize), minSize = me.minSize;
          if (me.isHorizontal()) {
            minSize.width = me.maxWidth;
            // fill all the width
            minSize.height = display ? fontSize + opts.padding * 2 : 0
          } else {
            minSize.width = display ? fontSize + opts.padding * 2 : 0;
            minSize.height = me.maxHeight  // fill all the height
          }
          me.width = minSize.width;
          me.height = minSize.height
        },
        afterFit: noop,
        // Shared Methods
        isHorizontal: function () {
          var pos = this.options.position;
          return pos === 'top' || pos === 'bottom'
        },
        // Actually draw the title block on the canvas
        draw: function () {
          var me = this, ctx = me.ctx, valueOrDefault = helpers.getValueOrDefault, opts = me.options, globalDefaults = Chart.defaults.global;
          if (opts.display) {
            var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize), fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle), fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily), titleFont = helpers.fontString(fontSize, fontStyle, fontFamily), rotation = 0, titleX, titleY, top = me.top, left = me.left, bottom = me.bottom, right = me.right, maxWidth;
            ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor);
            // render in correct colour
            ctx.font = titleFont;
            // Horizontal
            if (me.isHorizontal()) {
              titleX = left + (right - left) / 2;
              // midpoint of the width
              titleY = top + (bottom - top) / 2;
              // midpoint of the height
              maxWidth = right - left
            } else {
              titleX = opts.position === 'left' ? left + fontSize / 2 : right - fontSize / 2;
              titleY = top + (bottom - top) / 2;
              maxWidth = bottom - top;
              rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5)
            }
            ctx.save();
            ctx.translate(titleX, titleY);
            ctx.rotate(rotation);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(opts.text, 0, 0, maxWidth);
            ctx.restore()
          }
        }
      });
      // Register the title plugin
      Chart.plugins.register({
        beforeInit: function (chartInstance) {
          var opts = chartInstance.options;
          var titleOpts = opts.title;
          if (titleOpts) {
            chartInstance.titleBlock = new Chart.Title({
              ctx: chartInstance.chart.ctx,
              options: titleOpts,
              chart: chartInstance
            });
            Chart.layoutService.addBox(chartInstance, chartInstance.titleBlock)
          }
        }
      })
    }
  });
  // source: node_modules/chart.js/src/core/core.legend.js
  rqzt.define('chart.js/src/core/core.legend', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      var noop = helpers.noop;
      Chart.defaults.global.legend = {
        display: true,
        position: 'top',
        fullWidth: true,
        // marks that this box should take the full width of the canvas (pushing down other boxes)
        reverse: false,
        // a callback that will handle
        onClick: function (e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index);
          // See controller.isDatasetVisible comment
          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
          // We hid a dataset ... rerender the chart
          ci.update()
        },
        onHover: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          // Generates labels shown in the legend
          // Valid properties to return:
          // text : text to display
          // fillStyle : fill of coloured box
          // strokeStyle: stroke of coloured box
          // hidden : if this legend item refers to a hidden item
          // lineCap : cap style for line
          // lineDash
          // lineDashOffset :
          // lineJoin :
          // lineWidth :
          generateLabels: function (chart) {
            var data = chart.data;
            return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
              return {
                text: dataset.label,
                fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                hidden: !chart.isDatasetVisible(i),
                lineCap: dataset.borderCapStyle,
                lineDash: dataset.borderDash,
                lineDashOffset: dataset.borderDashOffset,
                lineJoin: dataset.borderJoinStyle,
                lineWidth: dataset.borderWidth,
                strokeStyle: dataset.borderColor,
                pointStyle: dataset.pointStyle,
                // Below is extra data used for toggling the datasets
                datasetIndex: i
              }
            }, this) : []
          }
        }
      };
      /**
	 * Helper function to get the box width based on the usePointStyle option
	 * @param labelopts {Object} the label options on the legend
	 * @param fontSize {Number} the label font size
	 * @return {Number} width of the color box area
	 */
      function getBoxWidth(labelOpts, fontSize) {
        return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth
      }
      Chart.Legend = Chart.Element.extend({
        initialize: function (config) {
          helpers.extend(this, config);
          // Contains hit boxes for each dataset (in dataset order)
          this.legendHitBoxes = [];
          // Are we in doughnut mode which has a different data type
          this.doughnutMode = false
        },
        // These methods are ordered by lifecycle. Utilities then follow.
        // Any function defined here is inherited by all legend types.
        // Any function can be extended by the legend type
        beforeUpdate: noop,
        update: function (maxWidth, maxHeight, margins) {
          var me = this;
          // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
          me.beforeUpdate();
          // Absorb the master measurements
          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = margins;
          // Dimensions
          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions();
          // Labels
          me.beforeBuildLabels();
          me.buildLabels();
          me.afterBuildLabels();
          // Fit
          me.beforeFit();
          me.fit();
          me.afterFit();
          //
          me.afterUpdate();
          return me.minSize
        },
        afterUpdate: noop,
        //
        beforeSetDimensions: noop,
        setDimensions: function () {
          var me = this;
          // Set the unconstrained dimension before label rotation
          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width
          } else {
            me.height = me.maxHeight;
            // Reset position before calculating rotation
            me.top = 0;
            me.bottom = me.height
          }
          // Reset padding
          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0;
          // Reset minSize
          me.minSize = {
            width: 0,
            height: 0
          }
        },
        afterSetDimensions: noop,
        //
        beforeBuildLabels: noop,
        buildLabels: function () {
          var me = this;
          me.legendItems = me.options.labels.generateLabels.call(me, me.chart);
          if (me.options.reverse) {
            me.legendItems.reverse()
          }
        },
        afterBuildLabels: noop,
        //
        beforeFit: noop,
        fit: function () {
          var me = this;
          var opts = me.options;
          var labelOpts = opts.labels;
          var display = opts.display;
          var ctx = me.ctx;
          var globalDefault = Chart.defaults.global, itemOrDefault = helpers.getValueOrDefault, fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize), fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle), fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily), labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
          // Reset hit boxes
          var hitboxes = me.legendHitBoxes = [];
          var minSize = me.minSize;
          var isHorizontal = me.isHorizontal();
          if (isHorizontal) {
            minSize.width = me.maxWidth;
            // fill all the width
            minSize.height = display ? 10 : 0
          } else {
            minSize.width = display ? 10 : 0;
            minSize.height = me.maxHeight  // fill all the height
          }
          // Increase sizes here
          if (display) {
            ctx.font = labelFont;
            if (isHorizontal) {
              // Labels
              // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
              var lineWidths = me.lineWidths = [0];
              var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;
              ctx.textAlign = 'left';
              ctx.textBaseline = 'top';
              helpers.each(me.legendItems, function (legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
                  totalHeight += fontSize + labelOpts.padding;
                  lineWidths[lineWidths.length] = me.left
                }
                // Store the hitbox width and height here. Final position will be updated in `draw`
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: width,
                  height: fontSize
                };
                lineWidths[lineWidths.length - 1] += width + labelOpts.padding
              });
              minSize.height += totalHeight
            } else {
              var vPadding = labelOpts.padding;
              var columnWidths = me.columnWidths = [];
              var totalWidth = labelOpts.padding;
              var currentColWidth = 0;
              var currentColHeight = 0;
              var itemHeight = fontSize + vPadding;
              helpers.each(me.legendItems, function (legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                // If too tall, go to new column
                if (currentColHeight + itemHeight > minSize.height) {
                  totalWidth += currentColWidth + labelOpts.padding;
                  columnWidths.push(currentColWidth);
                  // previous column width
                  currentColWidth = 0;
                  currentColHeight = 0
                }
                // Get max width
                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += itemHeight;
                // Store the hitbox width and height here. Final position will be updated in `draw`
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: itemWidth,
                  height: fontSize
                }
              });
              totalWidth += currentColWidth;
              columnWidths.push(currentColWidth);
              minSize.width += totalWidth
            }
          }
          me.width = minSize.width;
          me.height = minSize.height
        },
        afterFit: noop,
        // Shared Methods
        isHorizontal: function () {
          return this.options.position === 'top' || this.options.position === 'bottom'
        },
        // Actually draw the legend on the canvas
        draw: function () {
          var me = this;
          var opts = me.options;
          var labelOpts = opts.labels;
          var globalDefault = Chart.defaults.global, lineDefault = globalDefault.elements.line, legendWidth = me.width, lineWidths = me.lineWidths;
          if (opts.display) {
            var ctx = me.ctx, cursor, itemOrDefault = helpers.getValueOrDefault, fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor), fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize), fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle), fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily), labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
            // Canvas setup
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor;
            // for strikethrough effect
            ctx.fillStyle = fontColor;
            // render in correct colour
            ctx.font = labelFont;
            var boxWidth = getBoxWidth(labelOpts, fontSize), hitboxes = me.legendHitBoxes;
            // current position
            var drawLegendBox = function (x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0) {
                return
              }
              // Set the ctx for the box
              ctx.save();
              ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
              ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
              ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
              ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
              ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
              ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
              var isLineWidthZero = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;
              if (ctx.setLineDash) {
                // IE 9 and 10 do not support line dash
                ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash))
              }
              if (opts.labels && opts.labels.usePointStyle) {
                // Recalculate x and y for drawPoint() because its expecting
                // x and y to be center of figure (instead of top left)
                var radius = fontSize * Math.SQRT2 / 2;
                var offSet = radius / Math.SQRT2;
                var centerX = x + offSet;
                var centerY = y + offSet;
                // Draw pointStyle as legend symbol
                Chart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY)
              } else {
                // Draw box as legend symbol
                if (!isLineWidthZero) {
                  ctx.strokeRect(x, y, boxWidth, fontSize)
                }
                ctx.fillRect(x, y, boxWidth, fontSize)
              }
              ctx.restore()
            };
            var fillText = function (x, y, legendItem, textWidth) {
              ctx.fillText(legendItem.text, boxWidth + fontSize / 2 + x, y);
              if (legendItem.hidden) {
                // Strikethrough the text if hidden
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(boxWidth + fontSize / 2 + x, y + fontSize / 2);
                ctx.lineTo(boxWidth + fontSize / 2 + x + textWidth, y + fontSize / 2);
                ctx.stroke()
              }
            };
            // Horizontal
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              cursor = {
                x: me.left + (legendWidth - lineWidths[0]) / 2,
                y: me.top + labelOpts.padding,
                line: 0
              }
            } else {
              cursor = {
                x: me.left + labelOpts.padding,
                y: me.top + labelOpts.padding,
                line: 0
              }
            }
            var itemHeight = fontSize + labelOpts.padding;
            helpers.each(me.legendItems, function (legendItem, i) {
              var textWidth = ctx.measureText(legendItem.text).width, width = boxWidth + fontSize / 2 + textWidth, x = cursor.x, y = cursor.y;
              if (isHorizontal) {
                if (x + width >= legendWidth) {
                  y = cursor.y += itemHeight;
                  cursor.line++;
                  x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2
                }
              } else if (y + itemHeight > me.bottom) {
                x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                y = cursor.y = me.top;
                cursor.line++
              }
              drawLegendBox(x, y, legendItem);
              hitboxes[i].left = x;
              hitboxes[i].top = y;
              // Fill the actual label
              fillText(x, y, legendItem, textWidth);
              if (isHorizontal) {
                cursor.x += width + labelOpts.padding
              } else {
                cursor.y += itemHeight
              }
            })
          }
        },
        /**
		 * Handle an event
		 * @private
		 * @param e {Event} the event to handle
		 * @return {Boolean} true if a change occured
		 */
        handleEvent: function (e) {
          var me = this;
          var opts = me.options;
          var type = e.type === 'mouseup' ? 'click' : e.type;
          var changed = false;
          if (type === 'mousemove') {
            if (!opts.onHover) {
              return
            }
          } else if (type === 'click') {
            if (!opts.onClick) {
              return
            }
          } else {
            return
          }
          var position = helpers.getRelativePosition(e, me.chart.chart), x = position.x, y = position.y;
          if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
            // See if we are touching one of the dataset boxes
            var lh = me.legendHitBoxes;
            for (var i = 0; i < lh.length; ++i) {
              var hitBox = lh[i];
              if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                // Touching an element
                if (type === 'click') {
                  opts.onClick.call(me, e, me.legendItems[i]);
                  changed = true;
                  break
                } else if (type === 'mousemove') {
                  opts.onHover.call(me, e, me.legendItems[i]);
                  changed = true;
                  break
                }
              }
            }
          }
          return changed
        }
      });
      // Register the legend plugin
      Chart.plugins.register({
        beforeInit: function (chartInstance) {
          var opts = chartInstance.options;
          var legendOpts = opts.legend;
          if (legendOpts) {
            chartInstance.legend = new Chart.Legend({
              ctx: chartInstance.chart.ctx,
              options: legendOpts,
              chart: chartInstance
            });
            Chart.layoutService.addBox(chartInstance, chartInstance.legend)
          }
        }
      })
    }
  });
  // source: node_modules/chart.js/src/core/core.interaction.js
  rqzt.define('chart.js/src/core/core.interaction', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      /**
	 * Helper function to traverse all of the visible elements in the chart
	 * @param chart {chart} the chart
	 * @param handler {Function} the callback to execute for each visible item
	 */
      function parseVisibleItems(chart, handler) {
        var datasets = chart.data.datasets;
        var meta, i, j, ilen, jlen;
        for (i = 0, ilen = datasets.length; i < ilen; ++i) {
          if (!chart.isDatasetVisible(i)) {
            continue
          }
          meta = chart.getDatasetMeta(i);
          for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
            var element = meta.data[j];
            if (!element._view.skip) {
              handler(element)
            }
          }
        }
      }
      /**
	 * Helper function to get the items that intersect the event position
	 * @param items {ChartElement[]} elements to filter
	 * @param position {Point} the point to be nearest to
	 * @return {ChartElement[]} the nearest items
	 */
      function getIntersectItems(chart, position) {
        var elements = [];
        parseVisibleItems(chart, function (element) {
          if (element.inRange(position.x, position.y)) {
            elements.push(element)
          }
        });
        return elements
      }
      /**
	 * Helper function to get the items nearest to the event position considering all visible items in teh chart
	 * @param chart {Chart} the chart to look at elements from
	 * @param position {Point} the point to be nearest to
	 * @param intersect {Boolean} if true, only consider items that intersect the position
	 * @param distanceMetric {Function} Optional function to provide the distance between
	 * @return {ChartElement[]} the nearest items
	 */
      function getNearestItems(chart, position, intersect, distanceMetric) {
        var minDistance = Number.POSITIVE_INFINITY;
        var nearestItems = [];
        if (!distanceMetric) {
          distanceMetric = helpers.distanceBetweenPoints
        }
        parseVisibleItems(chart, function (element) {
          if (intersect && !element.inRange(position.x, position.y)) {
            return
          }
          var center = element.getCenterPoint();
          var distance = distanceMetric(position, center);
          if (distance < minDistance) {
            nearestItems = [element];
            minDistance = distance
          } else if (distance === minDistance) {
            // Can have multiple items at the same distance in which case we sort by size
            nearestItems.push(element)
          }
        });
        return nearestItems
      }
      function indexMode(chart, e, options) {
        var position = helpers.getRelativePosition(e, chart.chart);
        var distanceMetric = function (pt1, pt2) {
          return Math.abs(pt1.x - pt2.x)
        };
        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
        var elements = [];
        if (!items.length) {
          return []
        }
        chart.data.datasets.forEach(function (dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex), element = meta.data[items[0]._index];
            // don't count items that are skipped (null data)
            if (element && !element._view.skip) {
              elements.push(element)
            }
          }
        });
        return elements
      }
      /**
	 * @interface IInteractionOptions
	 */
      /**
	 * If true, only consider items that intersect the point
	 * @name IInterfaceOptions#boolean
	 * @type Boolean
	 */
      /**
	 * @namespace Chart.Interaction
	 * Contains interaction related functions
	 */
      Chart.Interaction = {
        // Helper function for different modes
        modes: {
          single: function (chart, e) {
            var position = helpers.getRelativePosition(e, chart.chart);
            var elements = [];
            parseVisibleItems(chart, function (element) {
              if (element.inRange(position.x, position.y)) {
                elements.push(element);
                return elements
              }
            });
            return elements.slice(0, 1)
          },
          /**
			 * @function Chart.Interaction.modes.label
			 * @deprecated since version 2.4.0
			 */
          label: indexMode,
          /**
			 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
			 * @function Chart.Interaction.modes.index
			 * @since v2.4.0
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
          index: indexMode,
          /**
			 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect is false, we find the nearest item and return the items in that dataset
			 * @function Chart.Interaction.modes.dataset
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
          dataset: function (chart, e, options) {
            var position = helpers.getRelativePosition(e, chart.chart);
            var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);
            if (items.length > 0) {
              items = chart.getDatasetMeta(items[0]._datasetIndex).data
            }
            return items
          },
          /**
			 * @function Chart.Interaction.modes.x-axis
			 * @deprecated since version 2.4.0. Use index mode and intersect == true
			 */
          'x-axis': function (chart, e) {
            return indexMode(chart, e, true)
          },
          /**
			 * Point mode returns all elements that hit test based on the event position
			 * of the event
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
          point: function (chart, e) {
            var position = helpers.getRelativePosition(e, chart.chart);
            return getIntersectItems(chart, position)
          },
          /**
			 * nearest mode returns the element closest to the point
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
          nearest: function (chart, e, options) {
            var position = helpers.getRelativePosition(e, chart.chart);
            var nearestItems = getNearestItems(chart, position, options.intersect);
            // We have multiple items at the same distance from the event. Now sort by smallest
            if (nearestItems.length > 1) {
              nearestItems.sort(function (a, b) {
                var sizeA = a.getArea();
                var sizeB = b.getArea();
                var ret = sizeA - sizeB;
                if (ret === 0) {
                  // if equal sort by dataset index
                  ret = a._datasetIndex - b._datasetIndex
                }
                return ret
              })
            }
            // Return only 1 item
            return nearestItems.slice(0, 1)
          },
          /**
			 * x mode returns the elements that hit-test at the current x coordinate
			 * @function Chart.Interaction.modes.x
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
          x: function (chart, e, options) {
            var position = helpers.getRelativePosition(e, chart.chart);
            var items = [];
            var intersectsItem = false;
            parseVisibleItems(chart, function (element) {
              if (element.inXRange(position.x)) {
                items.push(element)
              }
              if (element.inRange(position.x, position.y)) {
                intersectsItem = true
              }
            });
            // If we want to trigger on an intersect and we don't have any items
            // that intersect the position, return nothing
            if (options.intersect && !intersectsItem) {
              items = []
            }
            return items
          },
          /**
			 * y mode returns the elements that hit-test at the current y coordinate
			 * @function Chart.Interaction.modes.y
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
          y: function (chart, e, options) {
            var position = helpers.getRelativePosition(e, chart.chart);
            var items = [];
            var intersectsItem = false;
            parseVisibleItems(chart, function (element) {
              if (element.inYRange(position.y)) {
                items.push(element)
              }
              if (element.inRange(position.x, position.y)) {
                intersectsItem = true
              }
            });
            // If we want to trigger on an intersect and we don't have any items
            // that intersect the position, return nothing
            if (options.intersect && !intersectsItem) {
              items = []
            }
            return items
          }
        }
      }
    }
  });
  // source: node_modules/chart.js/src/core/core.tooltip.js
  rqzt.define('chart.js/src/core/core.tooltip', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      /**
 	 * Helper method to merge the opacity into a color
 	 */
      function mergeOpacity(colorString, opacity) {
        var color = helpers.color(colorString);
        return color.alpha(opacity * color.alpha()).rgbaString()
      }
      Chart.defaults.global.tooltips = {
        enabled: true,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: true,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: true,
        callbacks: {
          // Args are: (tooltipItems, data)
          beforeTitle: helpers.noop,
          title: function (tooltipItems, data) {
            // Pick first xLabel for now
            var title = '';
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;
            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];
              if (item.xLabel) {
                title = item.xLabel
              } else if (labelCount > 0 && item.index < labelCount) {
                title = labels[item.index]
              }
            }
            return title
          },
          afterTitle: helpers.noop,
          // Args are: (tooltipItems, data)
          beforeBody: helpers.noop,
          // Args are: (tooltipItem, data)
          beforeLabel: helpers.noop,
          label: function (tooltipItem, data) {
            var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
            return datasetLabel + ': ' + tooltipItem.yLabel
          },
          labelColor: function (tooltipItem, chartInstance) {
            var meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            }
          },
          afterLabel: helpers.noop,
          // Args are: (tooltipItems, data)
          afterBody: helpers.noop,
          // Args are: (tooltipItems, data)
          beforeFooter: helpers.noop,
          footer: helpers.noop,
          afterFooter: helpers.noop
        }
      };
      // Helper to push or concat based on if the 2nd parameter is an array or not
      function pushOrConcat(base, toPush) {
        if (toPush) {
          if (helpers.isArray(toPush)) {
            // base = base.concat(toPush);
            Array.prototype.push.apply(base, toPush)
          } else {
            base.push(toPush)
          }
        }
        return base
      }
      // Private helper to create a tooltip item model
      // @param element : the chart element (point, arc, bar) to create the tooltip item for
      // @return : new tooltip item
      function createTooltipItem(element) {
        var xScale = element._xScale;
        var yScale = element._yScale || element._scale;
        // handle radar || polarArea charts
        var index = element._index, datasetIndex = element._datasetIndex;
        return {
          xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
          yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
          index: index,
          datasetIndex: datasetIndex,
          x: element._model.x,
          y: element._model.y
        }
      }
      /**
	 * Helper to get the reset model for the tooltip
	 * @param tooltipOpts {Object} the tooltip options
	 */
      function getBaseModel(tooltipOpts) {
        var globalDefaults = Chart.defaults.global;
        var getValueOrDefault = helpers.getValueOrDefault;
        return {
          // Positioning
          xPadding: tooltipOpts.xPadding,
          yPadding: tooltipOpts.yPadding,
          xAlign: tooltipOpts.xAlign,
          yAlign: tooltipOpts.yAlign,
          // Body
          bodyFontColor: tooltipOpts.bodyFontColor,
          _bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
          _bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
          _bodyAlign: tooltipOpts.bodyAlign,
          bodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
          bodySpacing: tooltipOpts.bodySpacing,
          // Title
          titleFontColor: tooltipOpts.titleFontColor,
          _titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
          _titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
          titleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
          _titleAlign: tooltipOpts.titleAlign,
          titleSpacing: tooltipOpts.titleSpacing,
          titleMarginBottom: tooltipOpts.titleMarginBottom,
          // Footer
          footerFontColor: tooltipOpts.footerFontColor,
          _footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
          _footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
          footerFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
          _footerAlign: tooltipOpts.footerAlign,
          footerSpacing: tooltipOpts.footerSpacing,
          footerMarginTop: tooltipOpts.footerMarginTop,
          // Appearance
          caretSize: tooltipOpts.caretSize,
          cornerRadius: tooltipOpts.cornerRadius,
          backgroundColor: tooltipOpts.backgroundColor,
          opacity: 0,
          legendColorBackground: tooltipOpts.multiKeyBackground,
          displayColors: tooltipOpts.displayColors
        }
      }
      /**
	 * Get the size of the tooltip
	 */
      function getTooltipSize(tooltip, model) {
        var ctx = tooltip._chart.ctx;
        var height = model.yPadding * 2;
        // Tooltip Padding
        var width = 0;
        // Count of all lines in the body
        var body = model.body;
        var combinedBodyLength = body.reduce(function (count, bodyItem) {
          return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length
        }, 0);
        combinedBodyLength += model.beforeBody.length + model.afterBody.length;
        var titleLineCount = model.title.length;
        var footerLineCount = model.footer.length;
        var titleFontSize = model.titleFontSize, bodyFontSize = model.bodyFontSize, footerFontSize = model.footerFontSize;
        height += titleLineCount * titleFontSize;
        // Title Lines
        height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
        // Title Line Spacing
        height += titleLineCount ? model.titleMarginBottom : 0;
        // Title's bottom Margin
        height += combinedBodyLength * bodyFontSize;
        // Body Lines
        height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
        // Body Line Spacing
        height += footerLineCount ? model.footerMarginTop : 0;
        // Footer Margin
        height += footerLineCount * footerFontSize;
        // Footer Lines
        height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
        // Footer Line Spacing
        // Title width
        var widthPadding = 0;
        var maxLineWidth = function (line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding)
        };
        ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
        helpers.each(model.title, maxLineWidth);
        // Body width
        ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
        helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
        // Body lines may include some extra width due to the color box
        widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
        helpers.each(body, function (bodyItem) {
          helpers.each(bodyItem.before, maxLineWidth);
          helpers.each(bodyItem.lines, maxLineWidth);
          helpers.each(bodyItem.after, maxLineWidth)
        });
        // Reset back to 0
        widthPadding = 0;
        // Footer width
        ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
        helpers.each(model.footer, maxLineWidth);
        // Add padding
        width += 2 * model.xPadding;
        return {
          width: width,
          height: height
        }
      }
      /**
	 * Helper to get the alignment of a tooltip given the size
	 */
      function determineAlignment(tooltip, size) {
        var model = tooltip._model;
        var chart = tooltip._chart;
        var chartArea = tooltip._chartInstance.chartArea;
        var xAlign = 'center';
        var yAlign = 'center';
        if (model.y < size.height) {
          yAlign = 'top'
        } else if (model.y > chart.height - size.height) {
          yAlign = 'bottom'
        }
        var lf, rf;
        // functions to determine left, right alignment
        var olf, orf;
        // functions to determine if left/right alignment causes tooltip to go outside chart
        var yf;
        // function to get the y alignment if the tooltip goes outside of the left or right edges
        var midX = (chartArea.left + chartArea.right) / 2;
        var midY = (chartArea.top + chartArea.bottom) / 2;
        if (yAlign === 'center') {
          lf = function (x) {
            return x <= midX
          };
          rf = function (x) {
            return x > midX
          }
        } else {
          lf = function (x) {
            return x <= size.width / 2
          };
          rf = function (x) {
            return x >= chart.width - size.width / 2
          }
        }
        olf = function (x) {
          return x + size.width > chart.width
        };
        orf = function (x) {
          return x - size.width < 0
        };
        yf = function (y) {
          return y <= midY ? 'top' : 'bottom'
        };
        if (lf(model.x)) {
          xAlign = 'left';
          // Is tooltip too wide and goes over the right side of the chart.?
          if (olf(model.x)) {
            xAlign = 'center';
            yAlign = yf(model.y)
          }
        } else if (rf(model.x)) {
          xAlign = 'right';
          // Is tooltip too wide and goes outside left edge of canvas?
          if (orf(model.x)) {
            xAlign = 'center';
            yAlign = yf(model.y)
          }
        }
        var opts = tooltip._options;
        return {
          xAlign: opts.xAlign ? opts.xAlign : xAlign,
          yAlign: opts.yAlign ? opts.yAlign : yAlign
        }
      }
      /**
	 * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
	 */
      function getBackgroundPoint(vm, size, alignment) {
        // Background Position
        var x = vm.x;
        var y = vm.y;
        var caretSize = vm.caretSize, caretPadding = vm.caretPadding, cornerRadius = vm.cornerRadius, xAlign = alignment.xAlign, yAlign = alignment.yAlign, paddingAndSize = caretSize + caretPadding, radiusAndPadding = cornerRadius + caretPadding;
        if (xAlign === 'right') {
          x -= size.width
        } else if (xAlign === 'center') {
          x -= size.width / 2
        }
        if (yAlign === 'top') {
          y += paddingAndSize
        } else if (yAlign === 'bottom') {
          y -= size.height + paddingAndSize
        } else {
          y -= size.height / 2
        }
        if (yAlign === 'center') {
          if (xAlign === 'left') {
            x += paddingAndSize
          } else if (xAlign === 'right') {
            x -= paddingAndSize
          }
        } else if (xAlign === 'left') {
          x -= radiusAndPadding
        } else if (xAlign === 'right') {
          x += radiusAndPadding
        }
        return {
          x: x,
          y: y
        }
      }
      Chart.Tooltip = Chart.Element.extend({
        initialize: function () {
          this._model = getBaseModel(this._options)
        },
        // Get the title
        // Args are: (tooltipItem, data)
        getTitle: function () {
          var me = this;
          var opts = me._options;
          var callbacks = opts.callbacks;
          var beforeTitle = callbacks.beforeTitle.apply(me, arguments), title = callbacks.title.apply(me, arguments), afterTitle = callbacks.afterTitle.apply(me, arguments);
          var lines = [];
          lines = pushOrConcat(lines, beforeTitle);
          lines = pushOrConcat(lines, title);
          lines = pushOrConcat(lines, afterTitle);
          return lines
        },
        // Args are: (tooltipItem, data)
        getBeforeBody: function () {
          var lines = this._options.callbacks.beforeBody.apply(this, arguments);
          return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : []
        },
        // Args are: (tooltipItem, data)
        getBody: function (tooltipItems, data) {
          var me = this;
          var callbacks = me._options.callbacks;
          var bodyItems = [];
          helpers.each(tooltipItems, function (tooltipItem) {
            var bodyItem = {
              before: [],
              lines: [],
              after: []
            };
            pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
            pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
            pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));
            bodyItems.push(bodyItem)
          });
          return bodyItems
        },
        // Args are: (tooltipItem, data)
        getAfterBody: function () {
          var lines = this._options.callbacks.afterBody.apply(this, arguments);
          return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : []
        },
        // Get the footer and beforeFooter and afterFooter lines
        // Args are: (tooltipItem, data)
        getFooter: function () {
          var me = this;
          var callbacks = me._options.callbacks;
          var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
          var footer = callbacks.footer.apply(me, arguments);
          var afterFooter = callbacks.afterFooter.apply(me, arguments);
          var lines = [];
          lines = pushOrConcat(lines, beforeFooter);
          lines = pushOrConcat(lines, footer);
          lines = pushOrConcat(lines, afterFooter);
          return lines
        },
        update: function (changed) {
          var me = this;
          var opts = me._options;
          // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
          // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
          // which breaks any animations.
          var existingModel = me._model;
          var model = me._model = getBaseModel(opts);
          var active = me._active;
          var data = me._data;
          var chartInstance = me._chartInstance;
          // In the case where active.length === 0 we need to keep these at existing values for good animations
          var alignment = {
            xAlign: existingModel.xAlign,
            yAlign: existingModel.yAlign
          };
          var backgroundPoint = {
            x: existingModel.x,
            y: existingModel.y
          };
          var tooltipSize = {
            width: existingModel.width,
            height: existingModel.height
          };
          var tooltipPosition = {
            x: existingModel.caretX,
            y: existingModel.caretY
          };
          var i, len;
          if (active.length) {
            model.opacity = 1;
            var labelColors = [];
            tooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);
            var tooltipItems = [];
            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(active[i]))
            }
            // If the user provided a filter function, use it to modify the tooltip items
            if (opts.filter) {
              tooltipItems = tooltipItems.filter(function (a) {
                return opts.filter(a, data)
              })
            }
            // If the user provided a sorting function, use it to modify the tooltip items
            if (opts.itemSort) {
              tooltipItems = tooltipItems.sort(function (a, b) {
                return opts.itemSort(a, b, data)
              })
            }
            // Determine colors for boxes
            helpers.each(tooltipItems, function (tooltipItem) {
              labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance))
            });
            // Build the Text Lines
            model.title = me.getTitle(tooltipItems, data);
            model.beforeBody = me.getBeforeBody(tooltipItems, data);
            model.body = me.getBody(tooltipItems, data);
            model.afterBody = me.getAfterBody(tooltipItems, data);
            model.footer = me.getFooter(tooltipItems, data);
            // Initial positioning and colors
            model.x = Math.round(tooltipPosition.x);
            model.y = Math.round(tooltipPosition.y);
            model.caretPadding = helpers.getValueOrDefault(tooltipPosition.padding, 2);
            model.labelColors = labelColors;
            // data points
            model.dataPoints = tooltipItems;
            // We need to determine alignment of the tooltip
            tooltipSize = getTooltipSize(this, model);
            alignment = determineAlignment(this, tooltipSize);
            // Final Size and Position
            backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment)
          } else {
            model.opacity = 0
          }
          model.xAlign = alignment.xAlign;
          model.yAlign = alignment.yAlign;
          model.x = backgroundPoint.x;
          model.y = backgroundPoint.y;
          model.width = tooltipSize.width;
          model.height = tooltipSize.height;
          // Point where the caret on the tooltip points to
          model.caretX = tooltipPosition.x;
          model.caretY = tooltipPosition.y;
          me._model = model;
          if (changed && opts.custom) {
            opts.custom.call(me, model)
          }
          return me
        },
        drawCaret: function (tooltipPoint, size, opacity) {
          var vm = this._view;
          var ctx = this._chart.ctx;
          var x1, x2, x3;
          var y1, y2, y3;
          var caretSize = vm.caretSize;
          var cornerRadius = vm.cornerRadius;
          var xAlign = vm.xAlign, yAlign = vm.yAlign;
          var ptX = tooltipPoint.x, ptY = tooltipPoint.y;
          var width = size.width, height = size.height;
          if (yAlign === 'center') {
            // Left or right side
            if (xAlign === 'left') {
              x1 = ptX;
              x2 = x1 - caretSize;
              x3 = x1
            } else {
              x1 = ptX + width;
              x2 = x1 + caretSize;
              x3 = x1
            }
            y2 = ptY + height / 2;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize
          } else {
            if (xAlign === 'left') {
              x1 = ptX + cornerRadius;
              x2 = x1 + caretSize;
              x3 = x2 + caretSize
            } else if (xAlign === 'right') {
              x1 = ptX + width - cornerRadius;
              x2 = x1 - caretSize;
              x3 = x2 - caretSize
            } else {
              x2 = ptX + width / 2;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize
            }
            if (yAlign === 'top') {
              y1 = ptY;
              y2 = y1 - caretSize;
              y3 = y1
            } else {
              y1 = ptY + height;
              y2 = y1 + caretSize;
              y3 = y1
            }
          }
          ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.lineTo(x3, y3);
          ctx.closePath();
          ctx.fill()
        },
        drawTitle: function (pt, vm, ctx, opacity) {
          var title = vm.title;
          if (title.length) {
            ctx.textAlign = vm._titleAlign;
            ctx.textBaseline = 'top';
            var titleFontSize = vm.titleFontSize, titleSpacing = vm.titleSpacing;
            ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
            ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
            var i, len;
            for (i = 0, len = title.length; i < len; ++i) {
              ctx.fillText(title[i], pt.x, pt.y);
              pt.y += titleFontSize + titleSpacing;
              // Line Height and spacing
              if (i + 1 === title.length) {
                pt.y += vm.titleMarginBottom - titleSpacing  // If Last, add margin, remove spacing
              }
            }
          }
        },
        drawBody: function (pt, vm, ctx, opacity) {
          var bodyFontSize = vm.bodyFontSize;
          var bodySpacing = vm.bodySpacing;
          var body = vm.body;
          ctx.textAlign = vm._bodyAlign;
          ctx.textBaseline = 'top';
          var textColor = mergeOpacity(vm.bodyFontColor, opacity);
          ctx.fillStyle = textColor;
          ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
          // Before Body
          var xLinePadding = 0;
          var fillLineOfText = function (line) {
            ctx.fillText(line, pt.x + xLinePadding, pt.y);
            pt.y += bodyFontSize + bodySpacing
          };
          // Before body lines
          helpers.each(vm.beforeBody, fillLineOfText);
          var drawColorBoxes = vm.displayColors;
          xLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0;
          // Draw body lines now
          helpers.each(body, function (bodyItem, i) {
            helpers.each(bodyItem.before, fillLineOfText);
            helpers.each(bodyItem.lines, function (line) {
              // Draw Legend-like boxes if needed
              if (drawColorBoxes) {
                // Fill a white rect so that colours merge nicely if the opacity is < 1
                ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
                ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
                // Border
                ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
                ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
                // Inner square
                ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
                ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                ctx.fillStyle = textColor
              }
              fillLineOfText(line)
            });
            helpers.each(bodyItem.after, fillLineOfText)
          });
          // Reset back to 0 for after body
          xLinePadding = 0;
          // After body lines
          helpers.each(vm.afterBody, fillLineOfText);
          pt.y -= bodySpacing  // Remove last body spacing
        },
        drawFooter: function (pt, vm, ctx, opacity) {
          var footer = vm.footer;
          if (footer.length) {
            pt.y += vm.footerMarginTop;
            ctx.textAlign = vm._footerAlign;
            ctx.textBaseline = 'top';
            ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
            ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
            helpers.each(footer, function (line) {
              ctx.fillText(line, pt.x, pt.y);
              pt.y += vm.footerFontSize + vm.footerSpacing
            })
          }
        },
        drawBackground: function (pt, vm, ctx, tooltipSize, opacity) {
          ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
          helpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);
          ctx.fill()
        },
        draw: function () {
          var ctx = this._chart.ctx;
          var vm = this._view;
          if (vm.opacity === 0) {
            return
          }
          var tooltipSize = {
            width: vm.width,
            height: vm.height
          };
          var pt = {
            x: vm.x,
            y: vm.y
          };
          // IE11/Edge does not like very small opacities, so snap to 0
          var opacity = Math.abs(vm.opacity < 0.001) ? 0 : vm.opacity;
          if (this._options.enabled) {
            // Draw Background
            this.drawBackground(pt, vm, ctx, tooltipSize, opacity);
            // Draw Caret
            this.drawCaret(pt, tooltipSize, opacity);
            // Draw Title, Body, and Footer
            pt.x += vm.xPadding;
            pt.y += vm.yPadding;
            // Titles
            this.drawTitle(pt, vm, ctx, opacity);
            // Body
            this.drawBody(pt, vm, ctx, opacity);
            // Footer
            this.drawFooter(pt, vm, ctx, opacity)
          }
        },
        /**
		 * Handle an event
		 * @private
		 * @param e {Event} the event to handle
		 * @returns {Boolean} true if the tooltip changed
		 */
        handleEvent: function (e) {
          var me = this;
          var options = me._options;
          var changed = false;
          me._lastActive = me._lastActive || [];
          // Find Active Elements for tooltips
          if (e.type === 'mouseout') {
            me._active = []
          } else {
            me._active = me._chartInstance.getElementsAtEventForMode(e, options.mode, options)
          }
          // Remember Last Actives
          changed = !helpers.arrayEquals(me._active, me._lastActive);
          me._lastActive = me._active;
          if (options.enabled || options.custom) {
            me._eventPosition = helpers.getRelativePosition(e, me._chart);
            var model = me._model;
            me.update(true);
            me.pivot();
            // See if our tooltip position changed
            changed |= model.x !== me._model.x || model.y !== me._model.y
          }
          return changed
        }
      });
      /**
	 * @namespace Chart.Tooltip.positioners
	 */
      Chart.Tooltip.positioners = {
        /**
		 * Average mode places the tooltip at the average position of the elements shown
		 * @function Chart.Tooltip.positioners.average
		 * @param elements {ChartElement[]} the elements being displayed in the tooltip
		 * @returns {Point} tooltip position
		 */
        average: function (elements) {
          if (!elements.length) {
            return false
          }
          var i, len;
          var x = 0;
          var y = 0;
          var count = 0;
          for (i = 0, len = elements.length; i < len; ++i) {
            var el = elements[i];
            if (el && el.hasValue()) {
              var pos = el.tooltipPosition();
              x += pos.x;
              y += pos.y;
              ++count
            }
          }
          return {
            x: Math.round(x / count),
            y: Math.round(y / count)
          }
        },
        /**
		 * Gets the tooltip position nearest of the item nearest to the event position
		 * @function Chart.Tooltip.positioners.nearest
		 * @param elements {Chart.Element[]} the tooltip elements
		 * @param eventPosition {Point} the position of the event in canvas coordinates
		 * @returns {Point} the tooltip position
		 */
        nearest: function (elements, eventPosition) {
          var x = eventPosition.x;
          var y = eventPosition.y;
          var nearestElement;
          var minDistance = Number.POSITIVE_INFINITY;
          var i, len;
          for (i = 0, len = elements.length; i < len; ++i) {
            var el = elements[i];
            if (el && el.hasValue()) {
              var center = el.getCenterPoint();
              var d = helpers.distanceBetweenPoints(eventPosition, center);
              if (d < minDistance) {
                minDistance = d;
                nearestElement = el
              }
            }
          }
          if (nearestElement) {
            var tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y
          }
          return {
            x: x,
            y: y
          }
        }
      }
    }
  });
  // source: node_modules/chart.js/src/elements/element.arc.js
  rqzt.define('chart.js/src/elements/element.arc', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers, globalOpts = Chart.defaults.global;
      globalOpts.elements.arc = {
        backgroundColor: globalOpts.defaultColor,
        borderColor: '#fff',
        borderWidth: 2
      };
      Chart.elements.Arc = Chart.Element.extend({
        inLabelRange: function (mouseX) {
          var vm = this._view;
          if (vm) {
            return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2)
          }
          return false
        },
        inRange: function (chartX, chartY) {
          var vm = this._view;
          if (vm) {
            var pointRelativePosition = helpers.getAngleFromPoint(vm, {
                x: chartX,
                y: chartY
              }), angle = pointRelativePosition.angle, distance = pointRelativePosition.distance;
            // Sanitise angle range
            var startAngle = vm.startAngle;
            var endAngle = vm.endAngle;
            while (endAngle < startAngle) {
              endAngle += 2 * Math.PI
            }
            while (angle > endAngle) {
              angle -= 2 * Math.PI
            }
            while (angle < startAngle) {
              angle += 2 * Math.PI
            }
            // Check if within the range of the open/close angle
            var betweenAngles = angle >= startAngle && angle <= endAngle, withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
            return betweenAngles && withinRadius
          }
          return false
        },
        getCenterPoint: function () {
          var vm = this._view;
          var halfAngle = (vm.startAngle + vm.endAngle) / 2;
          var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
          return {
            x: vm.x + Math.cos(halfAngle) * halfRadius,
            y: vm.y + Math.sin(halfAngle) * halfRadius
          }
        },
        getArea: function () {
          var vm = this._view;
          return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2))
        },
        tooltipPosition: function () {
          var vm = this._view;
          var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2, rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
          return {
            x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
            y: vm.y + Math.sin(centreAngle) * rangeFromCentre
          }
        },
        draw: function () {
          var ctx = this._chart.ctx, vm = this._view, sA = vm.startAngle, eA = vm.endAngle;
          ctx.beginPath();
          ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
          ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
          ctx.closePath();
          ctx.strokeStyle = vm.borderColor;
          ctx.lineWidth = vm.borderWidth;
          ctx.fillStyle = vm.backgroundColor;
          ctx.fill();
          ctx.lineJoin = 'bevel';
          if (vm.borderWidth) {
            ctx.stroke()
          }
        }
      })
    }
  });
  // source: node_modules/chart.js/src/elements/element.line.js
  rqzt.define('chart.js/src/elements/element.line', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      var globalDefaults = Chart.defaults.global;
      Chart.defaults.global.elements.line = {
        tension: 0.4,
        backgroundColor: globalDefaults.defaultColor,
        borderWidth: 3,
        borderColor: globalDefaults.defaultColor,
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        capBezierPoints: true,
        fill: true
      };
      Chart.elements.Line = Chart.Element.extend({
        draw: function () {
          var me = this;
          var vm = me._view;
          var spanGaps = vm.spanGaps;
          var fillPoint = vm.scaleZero;
          var loop = me._loop;
          // Handle different fill modes for cartesian lines
          if (!loop) {
            if (vm.fill === 'top') {
              fillPoint = vm.scaleTop
            } else if (vm.fill === 'bottom') {
              fillPoint = vm.scaleBottom
            }
          }
          var ctx = me._chart.ctx;
          ctx.save();
          // Helper function to draw a line to a point
          function lineToPoint(previousPoint, point) {
            var pointVM = point._view;
            if (point._view.steppedLine === true) {
              ctx.lineTo(pointVM.x, previousPoint._view.y);
              ctx.lineTo(pointVM.x, pointVM.y)
            } else if (point._view.tension === 0) {
              ctx.lineTo(pointVM.x, pointVM.y)
            } else {
              ctx.bezierCurveTo(previousPoint._view.controlPointNextX, previousPoint._view.controlPointNextY, pointVM.controlPointPreviousX, pointVM.controlPointPreviousY, pointVM.x, pointVM.y)
            }
          }
          var points = me._children.slice();
          // clone array
          var lastDrawnIndex = -1;
          // If we are looping, adding the first point again
          if (loop && points.length) {
            points.push(points[0])
          }
          var index, current, previous, currentVM;
          // Fill Line
          if (points.length && vm.fill) {
            ctx.beginPath();
            for (index = 0; index < points.length; ++index) {
              current = points[index];
              previous = helpers.previousItem(points, index);
              currentVM = current._view;
              // First point moves to it's starting position no matter what
              if (index === 0) {
                if (loop) {
                  ctx.moveTo(fillPoint.x, fillPoint.y)
                } else {
                  ctx.moveTo(currentVM.x, fillPoint)
                }
                if (!currentVM.skip) {
                  lastDrawnIndex = index;
                  ctx.lineTo(currentVM.x, currentVM.y)
                }
              } else {
                previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
                if (currentVM.skip) {
                  // Only do this if this is the first point that is skipped
                  if (!spanGaps && lastDrawnIndex === index - 1) {
                    if (loop) {
                      ctx.lineTo(fillPoint.x, fillPoint.y)
                    } else {
                      ctx.lineTo(previous._view.x, fillPoint)
                    }
                  }
                } else {
                  if (lastDrawnIndex !== index - 1) {
                    // There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.
                    // If the first data point is NaN, then there is no real gap to skip
                    if (spanGaps && lastDrawnIndex !== -1) {
                      // We are spanning the gap, so simple draw a line to this point
                      lineToPoint(previous, current)
                    } else if (loop) {
                      ctx.lineTo(currentVM.x, currentVM.y)
                    } else {
                      ctx.lineTo(currentVM.x, fillPoint);
                      ctx.lineTo(currentVM.x, currentVM.y)
                    }
                  } else {
                    // Line to next point
                    lineToPoint(previous, current)
                  }
                  lastDrawnIndex = index
                }
              }
            }
            if (!loop && lastDrawnIndex !== -1) {
              ctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint)
            }
            ctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;
            ctx.closePath();
            ctx.fill()
          }
          // Stroke Line Options
          var globalOptionLineElements = globalDefaults.elements.line;
          ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
          // IE 9 and 10 do not support line dash
          if (ctx.setLineDash) {
            ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash)
          }
          ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
          ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
          ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
          ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
          // Stroke Line
          ctx.beginPath();
          lastDrawnIndex = -1;
          for (index = 0; index < points.length; ++index) {
            current = points[index];
            previous = helpers.previousItem(points, index);
            currentVM = current._view;
            // First point moves to it's starting position no matter what
            if (index === 0) {
              if (!currentVM.skip) {
                ctx.moveTo(currentVM.x, currentVM.y);
                lastDrawnIndex = index
              }
            } else {
              previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
              if (!currentVM.skip) {
                if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                  // There was a gap and this is the first point after the gap
                  ctx.moveTo(currentVM.x, currentVM.y)
                } else {
                  // Line to next point
                  lineToPoint(previous, current)
                }
                lastDrawnIndex = index
              }
            }
          }
          ctx.stroke();
          ctx.restore()
        }
      })
    }
  });
  // source: node_modules/chart.js/src/elements/element.point.js
  rqzt.define('chart.js/src/elements/element.point', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers, globalOpts = Chart.defaults.global, defaultColor = globalOpts.defaultColor;
      globalOpts.elements.point = {
        radius: 3,
        pointStyle: 'circle',
        backgroundColor: defaultColor,
        borderWidth: 1,
        borderColor: defaultColor,
        // Hover
        hitRadius: 1,
        hoverRadius: 4,
        hoverBorderWidth: 1
      };
      function xRange(mouseX) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false
      }
      function yRange(mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false
      }
      Chart.elements.Point = Chart.Element.extend({
        inRange: function (mouseX, mouseY) {
          var vm = this._view;
          return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false
        },
        inLabelRange: xRange,
        inXRange: xRange,
        inYRange: yRange,
        getCenterPoint: function () {
          var vm = this._view;
          return {
            x: vm.x,
            y: vm.y
          }
        },
        getArea: function () {
          return Math.PI * Math.pow(this._view.radius, 2)
        },
        tooltipPosition: function () {
          var vm = this._view;
          return {
            x: vm.x,
            y: vm.y,
            padding: vm.radius + vm.borderWidth
          }
        },
        draw: function () {
          var vm = this._view;
          var ctx = this._chart.ctx;
          var pointStyle = vm.pointStyle;
          var radius = vm.radius;
          var x = vm.x;
          var y = vm.y;
          if (vm.skip) {
            return
          }
          ctx.strokeStyle = vm.borderColor || defaultColor;
          ctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);
          ctx.fillStyle = vm.backgroundColor || defaultColor;
          Chart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y)
        }
      })
    }
  });
  // source: node_modules/chart.js/src/elements/element.rectangle.js
  rqzt.define('chart.js/src/elements/element.rectangle', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var globalOpts = Chart.defaults.global;
      globalOpts.elements.rectangle = {
        backgroundColor: globalOpts.defaultColor,
        borderWidth: 0,
        borderColor: globalOpts.defaultColor,
        borderSkipped: 'bottom'
      };
      function isVertical(bar) {
        return bar._view.width !== undefined
      }
      /**
	 * Helper function to get the bounds of the bar regardless of the orientation
	 * @private
	 * @param bar {Chart.Element.Rectangle} the bar
	 * @return {Bounds} bounds of the bar
	 */
      function getBarBounds(bar) {
        var vm = bar._view;
        var x1, x2, y1, y2;
        if (isVertical(bar)) {
          // vertical
          var halfWidth = vm.width / 2;
          x1 = vm.x - halfWidth;
          x2 = vm.x + halfWidth;
          y1 = Math.min(vm.y, vm.base);
          y2 = Math.max(vm.y, vm.base)
        } else {
          // horizontal bar
          var halfHeight = vm.height / 2;
          x1 = Math.min(vm.x, vm.base);
          x2 = Math.max(vm.x, vm.base);
          y1 = vm.y - halfHeight;
          y2 = vm.y + halfHeight
        }
        return {
          left: x1,
          top: y1,
          right: x2,
          bottom: y2
        }
      }
      Chart.elements.Rectangle = Chart.Element.extend({
        draw: function () {
          var ctx = this._chart.ctx;
          var vm = this._view;
          var halfWidth = vm.width / 2, leftX = vm.x - halfWidth, rightX = vm.x + halfWidth, top = vm.base - (vm.base - vm.y), halfStroke = vm.borderWidth / 2;
          // Canvas doesn't allow us to stroke inside the width so we can
          // adjust the sizes to fit if we're setting a stroke on the line
          if (vm.borderWidth) {
            leftX += halfStroke;
            rightX -= halfStroke;
            top += halfStroke
          }
          ctx.beginPath();
          ctx.fillStyle = vm.backgroundColor;
          ctx.strokeStyle = vm.borderColor;
          ctx.lineWidth = vm.borderWidth;
          // Corner points, from bottom-left to bottom-right clockwise
          // | 1 2 |
          // | 0 3 |
          var corners = [
            [
              leftX,
              vm.base
            ],
            [
              leftX,
              top
            ],
            [
              rightX,
              top
            ],
            [
              rightX,
              vm.base
            ]
          ];
          // Find first (starting) corner with fallback to 'bottom'
          var borders = [
            'bottom',
            'left',
            'top',
            'right'
          ];
          var startCorner = borders.indexOf(vm.borderSkipped, 0);
          if (startCorner === -1) {
            startCorner = 0
          }
          function cornerAt(index) {
            return corners[(startCorner + index) % 4]
          }
          // Draw rectangle from 'startCorner'
          var corner = cornerAt(0);
          ctx.moveTo(corner[0], corner[1]);
          for (var i = 1; i < 4; i++) {
            corner = cornerAt(i);
            ctx.lineTo(corner[0], corner[1])
          }
          ctx.fill();
          if (vm.borderWidth) {
            ctx.stroke()
          }
        },
        height: function () {
          var vm = this._view;
          return vm.base - vm.y
        },
        inRange: function (mouseX, mouseY) {
          var inRange = false;
          if (this._view) {
            var bounds = getBarBounds(this);
            inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom
          }
          return inRange
        },
        inLabelRange: function (mouseX, mouseY) {
          var me = this;
          if (!me._view) {
            return false
          }
          var inRange = false;
          var bounds = getBarBounds(me);
          if (isVertical(me)) {
            inRange = mouseX >= bounds.left && mouseX <= bounds.right
          } else {
            inRange = mouseY >= bounds.top && mouseY <= bounds.bottom
          }
          return inRange
        },
        inXRange: function (mouseX) {
          var bounds = getBarBounds(this);
          return mouseX >= bounds.left && mouseX <= bounds.right
        },
        inYRange: function (mouseY) {
          var bounds = getBarBounds(this);
          return mouseY >= bounds.top && mouseY <= bounds.bottom
        },
        getCenterPoint: function () {
          var vm = this._view;
          var x, y;
          if (isVertical(this)) {
            x = vm.x;
            y = (vm.y + vm.base) / 2
          } else {
            x = (vm.x + vm.base) / 2;
            y = vm.y
          }
          return {
            x: x,
            y: y
          }
        },
        getArea: function () {
          var vm = this._view;
          return vm.width * Math.abs(vm.y - vm.base)
        },
        tooltipPosition: function () {
          var vm = this._view;
          return {
            x: vm.x,
            y: vm.y
          }
        }
      })
    }
  });
  // source: node_modules/chart.js/src/scales/scale.linearbase.js
  rqzt.define('chart.js/src/scales/scale.linearbase', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers, noop = helpers.noop;
      Chart.LinearScaleBase = Chart.Scale.extend({
        handleTickRangeOptions: function () {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks;
          // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
          // do nothing since that would make the chart weird. If the user really wants a weird chart
          // axis, they can manually override it
          if (tickOpts.beginAtZero) {
            var minSign = helpers.sign(me.min);
            var maxSign = helpers.sign(me.max);
            if (minSign < 0 && maxSign < 0) {
              // move the top up to 0
              me.max = 0
            } else if (minSign > 0 && maxSign > 0) {
              // move the bottom down to 0
              me.min = 0
            }
          }
          if (tickOpts.min !== undefined) {
            me.min = tickOpts.min
          } else if (tickOpts.suggestedMin !== undefined) {
            me.min = Math.min(me.min, tickOpts.suggestedMin)
          }
          if (tickOpts.max !== undefined) {
            me.max = tickOpts.max
          } else if (tickOpts.suggestedMax !== undefined) {
            me.max = Math.max(me.max, tickOpts.suggestedMax)
          }
          if (me.min === me.max) {
            me.max++;
            if (!tickOpts.beginAtZero) {
              me.min--
            }
          }
        },
        getTickLimit: noop,
        handleDirectionalChanges: noop,
        buildTicks: function () {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks;
          // Figure out what the max number of ticks we can support it is based on the size of
          // the axis area. For now, we say that the minimum tick spacing in pixels must be 50
          // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
          // the graph. Make sure we always have at least 2 ticks
          var maxTicks = me.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          var numericGeneratorOptions = {
            maxTicks: maxTicks,
            min: tickOpts.min,
            max: tickOpts.max,
            stepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
          };
          var ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);
          me.handleDirectionalChanges();
          // At this point, we need to update our max and min given the tick values since we have expanded the
          // range of the scale
          me.max = helpers.max(ticks);
          me.min = helpers.min(ticks);
          if (tickOpts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min
          } else {
            me.start = me.min;
            me.end = me.max
          }
        },
        convertTicksToLabels: function () {
          var me = this;
          me.ticksAsNumbers = me.ticks.slice();
          me.zeroLineIndex = me.ticks.indexOf(0);
          Chart.Scale.prototype.convertTicksToLabels.call(me)
        }
      })
    }
  });
  // source: node_modules/chart.js/src/scales/scale.category.js
  rqzt.define('chart.js/src/scales/scale.category', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      // Default config for a category scale
      var defaultConfig = { position: 'bottom' };
      var DatasetScale = Chart.Scale.extend({
        /**
		* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
		* else fall back to data.labels
		* @private
		*/
        getLabels: function () {
          var data = this.chart.data;
          return (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels
        },
        // Implement this so that
        determineDataLimits: function () {
          var me = this;
          var labels = me.getLabels();
          me.minIndex = 0;
          me.maxIndex = labels.length - 1;
          var findIndex;
          if (me.options.ticks.min !== undefined) {
            // user specified min value
            findIndex = helpers.indexOf(labels, me.options.ticks.min);
            me.minIndex = findIndex !== -1 ? findIndex : me.minIndex
          }
          if (me.options.ticks.max !== undefined) {
            // user specified max value
            findIndex = helpers.indexOf(labels, me.options.ticks.max);
            me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex
          }
          me.min = labels[me.minIndex];
          me.max = labels[me.maxIndex]
        },
        buildTicks: function () {
          var me = this;
          var labels = me.getLabels();
          // If we are viewing some subset of labels, slice the original array
          me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1)
        },
        getLabelForIndex: function (index, datasetIndex) {
          var me = this;
          var data = me.chart.data;
          var isHorizontal = me.isHorizontal();
          if (data.xLabels && isHorizontal || data.yLabels && !isHorizontal) {
            return me.getRightValue(data.datasets[datasetIndex].data[index])
          }
          return me.ticks[index]
        },
        // Used to get data value locations.  Value can either be an index or a numerical value
        getPixelForValue: function (value, index, datasetIndex, includeOffset) {
          var me = this;
          // 1 is added because we need the length but we have the indexes
          var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);
          if (value !== undefined && isNaN(index)) {
            var labels = me.getLabels();
            var idx = labels.indexOf(value);
            index = idx !== -1 ? idx : index
          }
          if (me.isHorizontal()) {
            var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
            var valueWidth = innerWidth / offsetAmt;
            var widthOffset = valueWidth * (index - me.minIndex) + me.paddingLeft;
            if (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {
              widthOffset += valueWidth / 2
            }
            return me.left + Math.round(widthOffset)
          }
          var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
          var valueHeight = innerHeight / offsetAmt;
          var heightOffset = valueHeight * (index - me.minIndex) + me.paddingTop;
          if (me.options.gridLines.offsetGridLines && includeOffset) {
            heightOffset += valueHeight / 2
          }
          return me.top + Math.round(heightOffset)
        },
        getPixelForTick: function (index, includeOffset) {
          return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset)
        },
        getValueForPixel: function (pixel) {
          var me = this;
          var value;
          var offsetAmt = Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);
          var horz = me.isHorizontal();
          var innerDimension = horz ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);
          var valueDimension = innerDimension / offsetAmt;
          pixel -= horz ? me.left : me.top;
          if (me.options.gridLines.offsetGridLines) {
            pixel -= valueDimension / 2
          }
          pixel -= horz ? me.paddingLeft : me.paddingTop;
          if (pixel <= 0) {
            value = 0
          } else {
            value = Math.round(pixel / valueDimension)
          }
          return value
        },
        getBasePixel: function () {
          return this.bottom
        }
      });
      Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig)
    }
  });
  // source: node_modules/chart.js/src/scales/scale.linear.js
  rqzt.define('chart.js/src/scales/scale.linear', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      var defaultConfig = {
        position: 'left',
        ticks: { callback: Chart.Ticks.formatters.linear }
      };
      var LinearScale = Chart.LinearScaleBase.extend({
        determineDataLimits: function () {
          var me = this;
          var opts = me.options;
          var chart = me.chart;
          var data = chart.data;
          var datasets = data.datasets;
          var isHorizontal = me.isHorizontal();
          function IDMatches(meta) {
            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id
          }
          // First Calculate the range
          me.min = null;
          me.max = null;
          if (opts.stacked) {
            var valuesPerType = {};
            helpers.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);
              if (valuesPerType[meta.type] === undefined) {
                valuesPerType[meta.type] = {
                  positiveValues: [],
                  negativeValues: []
                }
              }
              // Store these per type
              var positiveValues = valuesPerType[meta.type].positiveValues;
              var negativeValues = valuesPerType[meta.type].negativeValues;
              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue);
                  if (isNaN(value) || meta.data[index].hidden) {
                    return
                  }
                  positiveValues[index] = positiveValues[index] || 0;
                  negativeValues[index] = negativeValues[index] || 0;
                  if (opts.relativePoints) {
                    positiveValues[index] = 100
                  } else if (value < 0) {
                    negativeValues[index] += value
                  } else {
                    positiveValues[index] += value
                  }
                })
              }
            });
            helpers.each(valuesPerType, function (valuesForType) {
              var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
              var minVal = helpers.min(values);
              var maxVal = helpers.max(values);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal)
            })
          } else {
            helpers.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);
              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue);
                  if (isNaN(value) || meta.data[index].hidden) {
                    return
                  }
                  if (me.min === null) {
                    me.min = value
                  } else if (value < me.min) {
                    me.min = value
                  }
                  if (me.max === null) {
                    me.max = value
                  } else if (value > me.max) {
                    me.max = value
                  }
                })
              }
            })
          }
          // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
          this.handleTickRangeOptions()
        },
        getTickLimit: function () {
          var maxTicks;
          var me = this;
          var tickOpts = me.options.ticks;
          if (me.isHorizontal()) {
            maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50))
          } else {
            // The factor of 2 used to scale the font size has been experimentally determined.
            var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);
            maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)))
          }
          return maxTicks
        },
        // Called after the ticks are built. We need
        handleDirectionalChanges: function () {
          if (!this.isHorizontal()) {
            // We are in a vertical orientation. The top value is the highest. So reverse the array
            this.ticks.reverse()
          }
        },
        getLabelForIndex: function (index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index])
        },
        // Utils
        getPixelForValue: function (value) {
          // This must be called after fit has been run so that
          // this.left, this.top, this.right, and this.bottom have been defined
          var me = this;
          var paddingLeft = me.paddingLeft;
          var paddingBottom = me.paddingBottom;
          var start = me.start;
          var rightValue = +me.getRightValue(value);
          var pixel;
          var innerDimension;
          var range = me.end - start;
          if (me.isHorizontal()) {
            innerDimension = me.width - (paddingLeft + me.paddingRight);
            pixel = me.left + innerDimension / range * (rightValue - start);
            return Math.round(pixel + paddingLeft)
          }
          innerDimension = me.height - (me.paddingTop + paddingBottom);
          pixel = me.bottom - paddingBottom - innerDimension / range * (rightValue - start);
          return Math.round(pixel)
        },
        getValueForPixel: function (pixel) {
          var me = this;
          var isHorizontal = me.isHorizontal();
          var paddingLeft = me.paddingLeft;
          var paddingBottom = me.paddingBottom;
          var innerDimension = isHorizontal ? me.width - (paddingLeft + me.paddingRight) : me.height - (me.paddingTop + paddingBottom);
          var offset = (isHorizontal ? pixel - me.left - paddingLeft : me.bottom - paddingBottom - pixel) / innerDimension;
          return me.start + (me.end - me.start) * offset
        },
        getPixelForTick: function (index) {
          return this.getPixelForValue(this.ticksAsNumbers[index])
        }
      });
      Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig)
    }
  });
  // source: node_modules/chart.js/src/scales/scale.logarithmic.js
  rqzt.define('chart.js/src/scales/scale.logarithmic', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      var defaultConfig = {
        position: 'left',
        // label settings
        ticks: { callback: Chart.Ticks.formatters.logarithmic }
      };
      var LogarithmicScale = Chart.Scale.extend({
        determineDataLimits: function () {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks;
          var chart = me.chart;
          var data = chart.data;
          var datasets = data.datasets;
          var getValueOrDefault = helpers.getValueOrDefault;
          var isHorizontal = me.isHorizontal();
          function IDMatches(meta) {
            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id
          }
          // Calculate Range
          me.min = null;
          me.max = null;
          me.minNotZero = null;
          if (opts.stacked) {
            var valuesPerType = {};
            helpers.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);
              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                if (valuesPerType[meta.type] === undefined) {
                  valuesPerType[meta.type] = []
                }
                helpers.each(dataset.data, function (rawValue, index) {
                  var values = valuesPerType[meta.type];
                  var value = +me.getRightValue(rawValue);
                  if (isNaN(value) || meta.data[index].hidden) {
                    return
                  }
                  values[index] = values[index] || 0;
                  if (opts.relativePoints) {
                    values[index] = 100
                  } else {
                    // Don't need to split positive and negative since the log scale can't handle a 0 crossing
                    values[index] += value
                  }
                })
              }
            });
            helpers.each(valuesPerType, function (valuesForType) {
              var minVal = helpers.min(valuesForType);
              var maxVal = helpers.max(valuesForType);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal)
            })
          } else {
            helpers.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);
              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue);
                  if (isNaN(value) || meta.data[index].hidden) {
                    return
                  }
                  if (me.min === null) {
                    me.min = value
                  } else if (value < me.min) {
                    me.min = value
                  }
                  if (me.max === null) {
                    me.max = value
                  } else if (value > me.max) {
                    me.max = value
                  }
                  if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                    me.minNotZero = value
                  }
                })
              }
            })
          }
          me.min = getValueOrDefault(tickOpts.min, me.min);
          me.max = getValueOrDefault(tickOpts.max, me.max);
          if (me.min === me.max) {
            if (me.min !== 0 && me.min !== null) {
              me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
              me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1)
            } else {
              me.min = 1;
              me.max = 10
            }
          }
        },
        buildTicks: function () {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks;
          var generationOptions = {
            min: tickOpts.min,
            max: tickOpts.max
          };
          var ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);
          if (!me.isHorizontal()) {
            // We are in a vertical orientation. The top value is the highest. So reverse the array
            ticks.reverse()
          }
          // At this point, we need to update our max and min given the tick values since we have expanded the
          // range of the scale
          me.max = helpers.max(ticks);
          me.min = helpers.min(ticks);
          if (tickOpts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min
          } else {
            me.start = me.min;
            me.end = me.max
          }
        },
        convertTicksToLabels: function () {
          this.tickValues = this.ticks.slice();
          Chart.Scale.prototype.convertTicksToLabels.call(this)
        },
        // Get the correct tooltip label
        getLabelForIndex: function (index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index])
        },
        getPixelForTick: function (index) {
          return this.getPixelForValue(this.tickValues[index])
        },
        getPixelForValue: function (value) {
          var me = this;
          var innerDimension;
          var pixel;
          var start = me.start;
          var newVal = +me.getRightValue(value);
          var range;
          var paddingTop = me.paddingTop;
          var paddingBottom = me.paddingBottom;
          var paddingLeft = me.paddingLeft;
          var opts = me.options;
          var tickOpts = opts.ticks;
          if (me.isHorizontal()) {
            range = helpers.log10(me.end) - helpers.log10(start);
            // todo: if start === 0
            if (newVal === 0) {
              pixel = me.left + paddingLeft
            } else {
              innerDimension = me.width - (paddingLeft + me.paddingRight);
              pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
              pixel += paddingLeft
            }
          } else {
            // Bottom - top since pixels increase downward on a screen
            innerDimension = me.height - (paddingTop + paddingBottom);
            if (start === 0 && !tickOpts.reverse) {
              range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
              if (newVal === start) {
                pixel = me.bottom - paddingBottom
              } else if (newVal === me.minNotZero) {
                pixel = me.bottom - paddingBottom - innerDimension * 0.02
              } else {
                pixel = me.bottom - paddingBottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero))
              }
            } else if (me.end === 0 && tickOpts.reverse) {
              range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
              if (newVal === me.end) {
                pixel = me.top + paddingTop
              } else if (newVal === me.minNotZero) {
                pixel = me.top + paddingTop + innerDimension * 0.02
              } else {
                pixel = me.top + paddingTop + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero))
              }
            } else {
              range = helpers.log10(me.end) - helpers.log10(start);
              innerDimension = me.height - (paddingTop + paddingBottom);
              pixel = me.bottom - paddingBottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start))
            }
          }
          return pixel
        },
        getValueForPixel: function (pixel) {
          var me = this;
          var range = helpers.log10(me.end) - helpers.log10(me.start);
          var value, innerDimension;
          if (me.isHorizontal()) {
            innerDimension = me.width - (me.paddingLeft + me.paddingRight);
            value = me.start * Math.pow(10, (pixel - me.left - me.paddingLeft) * range / innerDimension)
          } else {
            // todo: if start === 0
            innerDimension = me.height - (me.paddingTop + me.paddingBottom);
            value = Math.pow(10, (me.bottom - me.paddingBottom - pixel) * range / innerDimension) / me.start
          }
          return value
        }
      });
      Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig)
    }
  });
  // source: node_modules/chart.js/src/scales/scale.radialLinear.js
  rqzt.define('chart.js/src/scales/scale.radialLinear', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      var globalDefaults = Chart.defaults.global;
      var defaultConfig = {
        display: true,
        // Boolean - Whether to animate scaling the chart from the centre
        animate: true,
        lineArc: false,
        position: 'chartArea',
        angleLines: {
          display: true,
          color: 'rgba(0, 0, 0, 0.1)',
          lineWidth: 1
        },
        // label settings
        ticks: {
          // Boolean - Show a backdrop to the scale label
          showLabelBackdrop: true,
          // String - The colour of the label backdrop
          backdropColor: 'rgba(255,255,255,0.75)',
          // Number - The backdrop padding above & below the label in pixels
          backdropPaddingY: 2,
          // Number - The backdrop padding to the side of the label in pixels
          backdropPaddingX: 2,
          callback: Chart.Ticks.formatters.linear
        },
        pointLabels: {
          // Number - Point label font size in pixels
          fontSize: 10,
          // Function - Used to convert point labels
          callback: function (label) {
            return label
          }
        }
      };
      var LinearRadialScale = Chart.LinearScaleBase.extend({
        getValueCount: function () {
          return this.chart.data.labels.length
        },
        setDimensions: function () {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks;
          // Set the unconstrained dimension before label rotation
          me.width = me.maxWidth;
          me.height = me.maxHeight;
          me.xCenter = Math.round(me.width / 2);
          me.yCenter = Math.round(me.height / 2);
          var minSize = helpers.min([
            me.height,
            me.width
          ]);
          var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
          me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2
        },
        determineDataLimits: function () {
          var me = this;
          var chart = me.chart;
          me.min = null;
          me.max = null;
          helpers.each(chart.data.datasets, function (dataset, datasetIndex) {
            if (chart.isDatasetVisible(datasetIndex)) {
              var meta = chart.getDatasetMeta(datasetIndex);
              helpers.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);
                if (isNaN(value) || meta.data[index].hidden) {
                  return
                }
                if (me.min === null) {
                  me.min = value
                } else if (value < me.min) {
                  me.min = value
                }
                if (me.max === null) {
                  me.max = value
                } else if (value > me.max) {
                  me.max = value
                }
              })
            }
          });
          // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
          me.handleTickRangeOptions()
        },
        getTickLimit: function () {
          var tickOpts = this.options.ticks;
          var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
          return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)))
        },
        convertTicksToLabels: function () {
          var me = this;
          Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);
          // Point labels
          me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me)
        },
        getLabelForIndex: function (index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index])
        },
        fit: function () {
          /*
			 * Right, this is really confusing and there is a lot of maths going on here
			 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
			 *
			 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
			 *
			 * Solution:
			 *
			 * We assume the radius of the polygon is half the size of the canvas at first
			 * at each index we check if the text overlaps.
			 *
			 * Where it does, we store that angle and that index.
			 *
			 * After finding the largest index and angle we calculate how much we need to remove
			 * from the shape radius to move the point inwards by that x.
			 *
			 * We average the left and right distances to get the maximum shape radius that can fit in the box
			 * along with labels.
			 *
			 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
			 * on each side, removing that from the size, halving it and adding the left x protrusion width.
			 *
			 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
			 * and position it in the most space efficient manner
			 *
			 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
			 */
          var pointLabels = this.options.pointLabels;
          var pointLabelFontSize = helpers.getValueOrDefault(pointLabels.fontSize, globalDefaults.defaultFontSize);
          var pointLabeFontStyle = helpers.getValueOrDefault(pointLabels.fontStyle, globalDefaults.defaultFontStyle);
          var pointLabeFontFamily = helpers.getValueOrDefault(pointLabels.fontFamily, globalDefaults.defaultFontFamily);
          var pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);
          // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
          // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
          var largestPossibleRadius = helpers.min([
              this.height / 2 - pointLabelFontSize - 5,
              this.width / 2
            ]), pointPosition, i, textWidth, halfTextWidth, furthestRight = this.width, furthestRightIndex, furthestRightAngle, furthestLeft = 0, furthestLeftIndex, furthestLeftAngle, xProtrusionLeft, xProtrusionRight, radiusReductionRight, radiusReductionLeft;
          this.ctx.font = pointLabeFont;
          for (i = 0; i < this.getValueCount(); i++) {
            // 5px to space the text slightly out - similar to what we do in the draw function.
            pointPosition = this.getPointPosition(i, largestPossibleRadius);
            textWidth = this.ctx.measureText(this.pointLabels[i] ? this.pointLabels[i] : '').width + 5;
            // Add quarter circle to make degree 0 mean top of circle
            var angleRadians = this.getIndexAngle(i) + Math.PI / 2;
            var angle = angleRadians * 360 / (2 * Math.PI) % 360;
            if (angle === 0 || angle === 180) {
              // At angle 0 and 180, we're at exactly the top/bottom
              // of the radar chart, so text will be aligned centrally, so we'll half it and compare
              // w/left and right text sizes
              halfTextWidth = textWidth / 2;
              if (pointPosition.x + halfTextWidth > furthestRight) {
                furthestRight = pointPosition.x + halfTextWidth;
                furthestRightIndex = i
              }
              if (pointPosition.x - halfTextWidth < furthestLeft) {
                furthestLeft = pointPosition.x - halfTextWidth;
                furthestLeftIndex = i
              }
            } else if (angle < 180) {
              // Less than half the values means we'll left align the text
              if (pointPosition.x + textWidth > furthestRight) {
                furthestRight = pointPosition.x + textWidth;
                furthestRightIndex = i
              }  // More than half the values means we'll right align the text
            } else if (pointPosition.x - textWidth < furthestLeft) {
              furthestLeft = pointPosition.x - textWidth;
              furthestLeftIndex = i
            }
          }
          xProtrusionLeft = furthestLeft;
          xProtrusionRight = Math.ceil(furthestRight - this.width);
          furthestRightAngle = this.getIndexAngle(furthestRightIndex);
          furthestLeftAngle = this.getIndexAngle(furthestLeftIndex);
          radiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI / 2);
          radiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI / 2);
          // Ensure we actually need to reduce the size of the chart
          radiusReductionRight = helpers.isNumber(radiusReductionRight) ? radiusReductionRight : 0;
          radiusReductionLeft = helpers.isNumber(radiusReductionLeft) ? radiusReductionLeft : 0;
          this.drawingArea = Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2);
          this.setCenterPoint(radiusReductionLeft, radiusReductionRight)
        },
        setCenterPoint: function (leftMovement, rightMovement) {
          var me = this;
          var maxRight = me.width - rightMovement - me.drawingArea, maxLeft = leftMovement + me.drawingArea;
          me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);
          // Always vertically in the centre as the text height doesn't change
          me.yCenter = Math.round(me.height / 2 + me.top)
        },
        getIndexAngle: function (index) {
          var angleMultiplier = Math.PI * 2 / this.getValueCount();
          var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
          var startAngleRadians = startAngle * Math.PI * 2 / 360;
          // Start from the top instead of right, so remove a quarter of the circle
          return index * angleMultiplier - Math.PI / 2 + startAngleRadians
        },
        getDistanceFromCenterForValue: function (value) {
          var me = this;
          if (value === null) {
            return 0  // null always in center
          }
          // Take into account half font size + the yPadding of the top value
          var scalingFactor = me.drawingArea / (me.max - me.min);
          if (me.options.reverse) {
            return (me.max - value) * scalingFactor
          }
          return (value - me.min) * scalingFactor
        },
        getPointPosition: function (index, distanceFromCenter) {
          var me = this;
          var thisAngle = me.getIndexAngle(index);
          return {
            x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
            y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
          }
        },
        getPointPositionForValue: function (index, value) {
          return this.getPointPosition(index, this.getDistanceFromCenterForValue(value))
        },
        getBasePosition: function () {
          var me = this;
          var min = me.min;
          var max = me.max;
          return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0)
        },
        draw: function () {
          var me = this;
          var opts = me.options;
          var gridLineOpts = opts.gridLines;
          var tickOpts = opts.ticks;
          var angleLineOpts = opts.angleLines;
          var pointLabelOpts = opts.pointLabels;
          var getValueOrDefault = helpers.getValueOrDefault;
          if (opts.display) {
            var ctx = me.ctx;
            // Tick Font
            var tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
            var tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
            var tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
            var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
            helpers.each(me.ticks, function (label, index) {
              // Don't draw a centre value (if it is minimum)
              if (index > 0 || opts.reverse) {
                var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                var yHeight = me.yCenter - yCenterOffset;
                // Draw circular lines around the scale
                if (gridLineOpts.display && index !== 0) {
                  ctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);
                  ctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);
                  if (opts.lineArc) {
                    // Draw circular arcs between the points
                    ctx.beginPath();
                    ctx.arc(me.xCenter, me.yCenter, yCenterOffset, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.stroke()
                  } else {
                    // Draw straight lines connecting each index
                    ctx.beginPath();
                    for (var i = 0; i < me.getValueCount(); i++) {
                      var pointPosition = me.getPointPosition(i, yCenterOffset);
                      if (i === 0) {
                        ctx.moveTo(pointPosition.x, pointPosition.y)
                      } else {
                        ctx.lineTo(pointPosition.x, pointPosition.y)
                      }
                    }
                    ctx.closePath();
                    ctx.stroke()
                  }
                }
                if (tickOpts.display) {
                  var tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
                  ctx.font = tickLabelFont;
                  if (tickOpts.showLabelBackdrop) {
                    var labelWidth = ctx.measureText(label).width;
                    ctx.fillStyle = tickOpts.backdropColor;
                    ctx.fillRect(me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX, yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2)
                  }
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillStyle = tickFontColor;
                  ctx.fillText(label, me.xCenter, yHeight)
                }
              }
            });
            if (!opts.lineArc) {
              ctx.lineWidth = angleLineOpts.lineWidth;
              ctx.strokeStyle = angleLineOpts.color;
              var outerDistance = me.getDistanceFromCenterForValue(opts.reverse ? me.min : me.max);
              // Point Label Font
              var pointLabelFontSize = getValueOrDefault(pointLabelOpts.fontSize, globalDefaults.defaultFontSize);
              var pointLabeFontStyle = getValueOrDefault(pointLabelOpts.fontStyle, globalDefaults.defaultFontStyle);
              var pointLabeFontFamily = getValueOrDefault(pointLabelOpts.fontFamily, globalDefaults.defaultFontFamily);
              var pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);
              for (var i = me.getValueCount() - 1; i >= 0; i--) {
                if (angleLineOpts.display) {
                  var outerPosition = me.getPointPosition(i, outerDistance);
                  ctx.beginPath();
                  ctx.moveTo(me.xCenter, me.yCenter);
                  ctx.lineTo(outerPosition.x, outerPosition.y);
                  ctx.stroke();
                  ctx.closePath()
                }
                // Extra 3px out for some label spacing
                var pointLabelPosition = me.getPointPosition(i, outerDistance + 5);
                // Keep this in loop since we may support array properties here
                var pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
                ctx.font = pointLabeFont;
                ctx.fillStyle = pointLabelFontColor;
                var pointLabels = me.pointLabels;
                // Add quarter circle to make degree 0 mean top of circle
                var angleRadians = this.getIndexAngle(i) + Math.PI / 2;
                var angle = angleRadians * 360 / (2 * Math.PI) % 360;
                if (angle === 0 || angle === 180) {
                  ctx.textAlign = 'center'
                } else if (angle < 180) {
                  ctx.textAlign = 'left'
                } else {
                  ctx.textAlign = 'right'
                }
                // Set the correct text baseline based on outer positioning
                if (angle === 90 || angle === 270) {
                  ctx.textBaseline = 'middle'
                } else if (angle > 270 || angle < 90) {
                  ctx.textBaseline = 'bottom'
                } else {
                  ctx.textBaseline = 'top'
                }
                ctx.fillText(pointLabels[i] ? pointLabels[i] : '', pointLabelPosition.x, pointLabelPosition.y)
              }
            }
          }
        }
      });
      Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig)
    }
  });
  // source: node_modules/chart.js/src/scales/scale.time.js
  rqzt.define('chart.js/src/scales/scale.time', function (module, exports, __dirname, __filename, process) {
    /* global window: false */
    'use strict';
    var moment = rqzt('moment/moment');
    moment = typeof moment === 'function' ? moment : window.moment;
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      var time = {
        units: [
          {
            name: 'millisecond',
            steps: [
              1,
              2,
              5,
              10,
              20,
              50,
              100,
              250,
              500
            ]
          },
          {
            name: 'second',
            steps: [
              1,
              2,
              5,
              10,
              30
            ]
          },
          {
            name: 'minute',
            steps: [
              1,
              2,
              5,
              10,
              30
            ]
          },
          {
            name: 'hour',
            steps: [
              1,
              2,
              3,
              6,
              12
            ]
          },
          {
            name: 'day',
            steps: [
              1,
              2,
              5
            ]
          },
          {
            name: 'week',
            maxStep: 4
          },
          {
            name: 'month',
            maxStep: 3
          },
          {
            name: 'quarter',
            maxStep: 4
          },
          {
            name: 'year',
            maxStep: false
          }
        ]
      };
      var defaultConfig = {
        position: 'bottom',
        time: {
          parser: false,
          // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
          format: false,
          // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
          unit: false,
          // false == automatic or override with week, month, year, etc.
          round: false,
          // none, or override with week, month, year, etc.
          displayFormat: false,
          // DEPRECATED
          isoWeekday: false,
          // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
          minUnit: 'millisecond',
          // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
          displayFormats: {
            millisecond: 'h:mm:ss.SSS a',
            // 11:20:01.123 AM,
            second: 'h:mm:ss a',
            // 11:20:01 AM
            minute: 'h:mm:ss a',
            // 11:20:01 AM
            hour: 'MMM D, hA',
            // Sept 4, 5PM
            day: 'll',
            // Sep 4 2015
            week: 'll',
            // Week 46, or maybe "[W]WW - YYYY" ?
            month: 'MMM YYYY',
            // Sept 2015
            quarter: '[Q]Q - YYYY',
            // Q3
            year: 'YYYY'  // 2015
          }
        },
        ticks: { autoSkip: false }
      };
      var TimeScale = Chart.Scale.extend({
        initialize: function () {
          if (!moment) {
            throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com')
          }
          Chart.Scale.prototype.initialize.call(this)
        },
        getLabelMoment: function (datasetIndex, index) {
          if (datasetIndex === null || index === null) {
            return null
          }
          if (typeof this.labelMoments[datasetIndex] !== 'undefined') {
            return this.labelMoments[datasetIndex][index]
          }
          return null
        },
        getLabelDiff: function (datasetIndex, index) {
          var me = this;
          if (datasetIndex === null || index === null) {
            return null
          }
          if (me.labelDiffs === undefined) {
            me.buildLabelDiffs()
          }
          if (typeof me.labelDiffs[datasetIndex] !== 'undefined') {
            return me.labelDiffs[datasetIndex][index]
          }
          return null
        },
        getMomentStartOf: function (tick) {
          var me = this;
          if (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {
            return tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday)
          }
          return tick.clone().startOf(me.tickUnit)
        },
        determineDataLimits: function () {
          var me = this;
          me.labelMoments = [];
          // Only parse these once. If the dataset does not have data as x,y pairs, we will use
          // these
          var scaleLabelMoments = [];
          if (me.chart.data.labels && me.chart.data.labels.length > 0) {
            helpers.each(me.chart.data.labels, function (label) {
              var labelMoment = me.parseTime(label);
              if (labelMoment.isValid()) {
                if (me.options.time.round) {
                  labelMoment.startOf(me.options.time.round)
                }
                scaleLabelMoments.push(labelMoment)
              }
            }, me);
            me.firstTick = moment.min.call(me, scaleLabelMoments);
            me.lastTick = moment.max.call(me, scaleLabelMoments)
          } else {
            me.firstTick = null;
            me.lastTick = null
          }
          helpers.each(me.chart.data.datasets, function (dataset, datasetIndex) {
            var momentsForDataset = [];
            var datasetVisible = me.chart.isDatasetVisible(datasetIndex);
            if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {
              helpers.each(dataset.data, function (value) {
                var labelMoment = me.parseTime(me.getRightValue(value));
                if (labelMoment.isValid()) {
                  if (me.options.time.round) {
                    labelMoment.startOf(me.options.time.round)
                  }
                  momentsForDataset.push(labelMoment);
                  if (datasetVisible) {
                    // May have gone outside the scale ranges, make sure we keep the first and last ticks updated
                    me.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;
                    me.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment
                  }
                }
              }, me)
            } else {
              // We have no labels. Use the ones from the scale
              momentsForDataset = scaleLabelMoments
            }
            me.labelMoments.push(momentsForDataset)
          }, me);
          // Set these after we've done all the data
          if (me.options.time.min) {
            me.firstTick = me.parseTime(me.options.time.min)
          }
          if (me.options.time.max) {
            me.lastTick = me.parseTime(me.options.time.max)
          }
          // We will modify these, so clone for later
          me.firstTick = (me.firstTick || moment()).clone();
          me.lastTick = (me.lastTick || moment()).clone()
        },
        buildLabelDiffs: function () {
          var me = this;
          me.labelDiffs = [];
          var scaleLabelDiffs = [];
          // Parse common labels once
          if (me.chart.data.labels && me.chart.data.labels.length > 0) {
            helpers.each(me.chart.data.labels, function (label) {
              var labelMoment = me.parseTime(label);
              if (labelMoment.isValid()) {
                if (me.options.time.round) {
                  labelMoment.startOf(me.options.time.round)
                }
                scaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true))
              }
            }, me)
          }
          helpers.each(me.chart.data.datasets, function (dataset) {
            var diffsForDataset = [];
            if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {
              helpers.each(dataset.data, function (value) {
                var labelMoment = me.parseTime(me.getRightValue(value));
                if (labelMoment.isValid()) {
                  if (me.options.time.round) {
                    labelMoment.startOf(me.options.time.round)
                  }
                  diffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true))
                }
              }, me)
            } else {
              // We have no labels. Use common ones
              diffsForDataset = scaleLabelDiffs
            }
            me.labelDiffs.push(diffsForDataset)
          }, me)
        },
        buildTicks: function () {
          var me = this;
          me.ctx.save();
          var tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
          var tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);
          var tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);
          var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
          me.ctx.font = tickLabelFont;
          me.ticks = [];
          me.unitScale = 1;
          // How much we scale the unit by, ie 2 means 2x unit per step
          me.scaleSizeInUnits = 0;
          // How large the scale is in the base unit (seconds, minutes, etc)
          // Set unit override if applicable
          if (me.options.time.unit) {
            me.tickUnit = me.options.time.unit || 'day';
            me.displayFormat = me.options.time.displayFormats[me.tickUnit];
            me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
            me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1)
          } else {
            // Determine the smallest needed unit of the time
            var innerWidth = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);
            // Crude approximation of what the label length might be
            var tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);
            var tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;
            var cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));
            var sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));
            tickLabelWidth = tickLabelWidth * cosRotation + tickFontSize * sinRotation;
            var labelCapacity = innerWidth / tickLabelWidth;
            // Start as small as possible
            me.tickUnit = me.options.time.minUnit;
            me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
            me.displayFormat = me.options.time.displayFormats[me.tickUnit];
            var unitDefinitionIndex = 0;
            var unitDefinition = time.units[unitDefinitionIndex];
            // While we aren't ideal and we don't have units left
            while (unitDefinitionIndex < time.units.length) {
              // Can we scale this unit. If `false` we can scale infinitely
              me.unitScale = 1;
              if (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {
                // Use one of the predefined steps
                for (var idx = 0; idx < unitDefinition.steps.length; ++idx) {
                  if (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {
                    me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);
                    break
                  }
                }
                break
              } else if (unitDefinition.maxStep === false || Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep) {
                // We have a max step. Scale this unit
                me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));
                break
              } else {
                // Move to the next unit up
                ++unitDefinitionIndex;
                unitDefinition = time.units[unitDefinitionIndex];
                me.tickUnit = unitDefinition.name;
                var leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);
                var trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);
                me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;
                me.displayFormat = me.options.time.displayFormats[unitDefinition.name]
              }
            }
          }
          var roundedStart;
          // Only round the first tick if we have no hard minimum
          if (!me.options.time.min) {
            me.firstTick = me.getMomentStartOf(me.firstTick);
            roundedStart = me.firstTick
          } else {
            roundedStart = me.getMomentStartOf(me.firstTick)
          }
          // Only round the last tick if we have no hard maximum
          if (!me.options.time.max) {
            var roundedEnd = me.getMomentStartOf(me.lastTick);
            var delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);
            if (delta < 0) {
              // Do not use end of because we need me to be in the next time unit
              me.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit))
            } else if (delta >= 0) {
              me.lastTick = roundedEnd
            }
            me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true)
          }
          // Tick displayFormat override
          if (me.options.time.displayFormat) {
            me.displayFormat = me.options.time.displayFormat
          }
          // first tick. will have been rounded correctly if options.time.min is not specified
          me.ticks.push(me.firstTick.clone());
          // For every unit in between the first and last moment, create a moment and add it to the ticks tick
          for (var i = 1; i <= me.scaleSizeInUnits; ++i) {
            var newTick = roundedStart.clone().add(i, me.tickUnit);
            // Are we greater than the max time
            if (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {
              break
            }
            if (i % me.unitScale === 0) {
              me.ticks.push(newTick)
            }
          }
          // Always show the right tick
          var diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);
          if (diff !== 0 || me.scaleSizeInUnits === 0) {
            // this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart
            // but the last tick was not rounded.
            if (me.options.time.max) {
              me.ticks.push(me.lastTick.clone());
              me.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true)
            } else {
              me.ticks.push(me.lastTick.clone());
              me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true)
            }
          }
          me.ctx.restore();
          // Invalidate label diffs cache
          me.labelDiffs = undefined
        },
        // Get tooltip label
        getLabelForIndex: function (index, datasetIndex) {
          var me = this;
          var label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';
          if (typeof me.chart.data.datasets[datasetIndex].data[0] === 'object') {
            label = me.getRightValue(me.chart.data.datasets[datasetIndex].data[index])
          }
          // Format nicely
          if (me.options.time.tooltipFormat) {
            label = me.parseTime(label).format(me.options.time.tooltipFormat)
          }
          return label
        },
        // Function to format an individual tick mark
        tickFormatFunction: function (tick, index, ticks) {
          var formattedTick = tick.format(this.displayFormat);
          var tickOpts = this.options.ticks;
          var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);
          if (callback) {
            return callback(formattedTick, index, ticks)
          }
          return formattedTick
        },
        convertTicksToLabels: function () {
          var me = this;
          me.tickMoments = me.ticks;
          me.ticks = me.ticks.map(me.tickFormatFunction, me)
        },
        getPixelForValue: function (value, index, datasetIndex) {
          var me = this;
          var offset = null;
          if (index !== undefined && datasetIndex !== undefined) {
            offset = me.getLabelDiff(datasetIndex, index)
          }
          if (offset === null) {
            if (!value || !value.isValid) {
              // not already a moment object
              value = me.parseTime(me.getRightValue(value))
            }
            if (value && value.isValid && value.isValid()) {
              offset = value.diff(me.firstTick, me.tickUnit, true)
            }
          }
          if (offset !== null) {
            var decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;
            if (me.isHorizontal()) {
              var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
              var valueOffset = innerWidth * decimal + me.paddingLeft;
              return me.left + Math.round(valueOffset)
            }
            var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
            var heightOffset = innerHeight * decimal + me.paddingTop;
            return me.top + Math.round(heightOffset)
          }
        },
        getPixelForTick: function (index) {
          return this.getPixelForValue(this.tickMoments[index], null, null)
        },
        getValueForPixel: function (pixel) {
          var me = this;
          var innerDimension = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);
          var offset = (pixel - (me.isHorizontal() ? me.left + me.paddingLeft : me.top + me.paddingTop)) / innerDimension;
          offset *= me.scaleSizeInUnits;
          return me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds')
        },
        parseTime: function (label) {
          var me = this;
          if (typeof me.options.time.parser === 'string') {
            return moment(label, me.options.time.parser)
          }
          if (typeof me.options.time.parser === 'function') {
            return me.options.time.parser(label)
          }
          // Date objects
          if (typeof label.getMonth === 'function' || typeof label === 'number') {
            return moment(label)
          }
          // Moment support
          if (label.isValid && label.isValid()) {
            return label
          }
          // Custom parsing (return an instance of moment)
          if (typeof me.options.time.format !== 'string' && me.options.time.format.call) {
            console.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');
            return me.options.time.format(label)
          }
          // Moment format parsing
          return moment(label, me.options.time.format)
        }
      });
      Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig)
    }
  });
  // source: node_modules/chart.js/src/controllers/controller.bar.js
  rqzt.define('chart.js/src/controllers/controller.bar', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.defaults.bar = {
        hover: { mode: 'label' },
        scales: {
          xAxes: [{
              type: 'category',
              // Specific to Bar Controller
              categoryPercentage: 0.8,
              barPercentage: 0.9,
              // grid line settings
              gridLines: { offsetGridLines: true }
            }],
          yAxes: [{ type: 'linear' }]
        }
      };
      Chart.controllers.bar = Chart.DatasetController.extend({
        dataElementType: Chart.elements.Rectangle,
        initialize: function (chart, datasetIndex) {
          Chart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);
          // Use this to indicate that this is a bar dataset.
          this.getMeta().bar = true
        },
        // Get the number of datasets that display bars. We use this to correctly calculate the bar width
        getBarCount: function () {
          var me = this;
          var barCount = 0;
          helpers.each(me.chart.data.datasets, function (dataset, datasetIndex) {
            var meta = me.chart.getDatasetMeta(datasetIndex);
            if (meta.bar && me.chart.isDatasetVisible(datasetIndex)) {
              ++barCount
            }
          }, me);
          return barCount
        },
        update: function (reset) {
          var me = this;
          helpers.each(me.getMeta().data, function (rectangle, index) {
            me.updateElement(rectangle, index, reset)
          }, me)
        },
        updateElement: function (rectangle, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var xScale = me.getScaleForId(meta.xAxisID);
          var yScale = me.getScaleForId(meta.yAxisID);
          var scaleBase = yScale.getBasePixel();
          var rectangleElementOptions = me.chart.options.elements.rectangle;
          var custom = rectangle.custom || {};
          var dataset = me.getDataset();
          rectangle._xScale = xScale;
          rectangle._yScale = yScale;
          rectangle._datasetIndex = me.index;
          rectangle._index = index;
          var ruler = me.getRuler(index);
          rectangle._model = {
            x: me.calculateBarX(index, me.index, ruler),
            y: reset ? scaleBase : me.calculateBarY(index, me.index),
            // Tooltip
            label: me.chart.data.labels[index],
            datasetLabel: dataset.label,
            // Appearance
            base: reset ? scaleBase : me.calculateBarBase(me.index, index),
            width: me.calculateBarWidth(ruler),
            backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),
            borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,
            borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),
            borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
          };
          rectangle.pivot()
        },
        calculateBarBase: function (datasetIndex, index) {
          var me = this;
          var meta = me.getMeta();
          var yScale = me.getScaleForId(meta.yAxisID);
          var base = 0;
          if (yScale.options.stacked) {
            var chart = me.chart;
            var datasets = chart.data.datasets;
            var value = Number(datasets[datasetIndex].data[index]);
            for (var i = 0; i < datasetIndex; i++) {
              var currentDs = datasets[i];
              var currentDsMeta = chart.getDatasetMeta(i);
              if (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
                var currentVal = Number(currentDs.data[index]);
                base += value < 0 ? Math.min(currentVal, 0) : Math.max(currentVal, 0)
              }
            }
            return yScale.getPixelForValue(base)
          }
          return yScale.getBasePixel()
        },
        getRuler: function (index) {
          var me = this;
          var meta = me.getMeta();
          var xScale = me.getScaleForId(meta.xAxisID);
          var datasetCount = me.getBarCount();
          var tickWidth;
          if (xScale.options.type === 'category') {
            tickWidth = xScale.getPixelForTick(index + 1) - xScale.getPixelForTick(index)
          } else {
            // Average width
            tickWidth = xScale.width / xScale.ticks.length
          }
          var categoryWidth = tickWidth * xScale.options.categoryPercentage;
          var categorySpacing = (tickWidth - tickWidth * xScale.options.categoryPercentage) / 2;
          var fullBarWidth = categoryWidth / datasetCount;
          if (xScale.ticks.length !== me.chart.data.labels.length) {
            var perc = xScale.ticks.length / me.chart.data.labels.length;
            fullBarWidth = fullBarWidth * perc
          }
          var barWidth = fullBarWidth * xScale.options.barPercentage;
          var barSpacing = fullBarWidth - fullBarWidth * xScale.options.barPercentage;
          return {
            datasetCount: datasetCount,
            tickWidth: tickWidth,
            categoryWidth: categoryWidth,
            categorySpacing: categorySpacing,
            fullBarWidth: fullBarWidth,
            barWidth: barWidth,
            barSpacing: barSpacing
          }
        },
        calculateBarWidth: function (ruler) {
          var xScale = this.getScaleForId(this.getMeta().xAxisID);
          if (xScale.options.barThickness) {
            return xScale.options.barThickness
          }
          return xScale.options.stacked ? ruler.categoryWidth : ruler.barWidth
        },
        // Get bar index from the given dataset index accounting for the fact that not all bars are visible
        getBarIndex: function (datasetIndex) {
          var barIndex = 0;
          var meta, j;
          for (j = 0; j < datasetIndex; ++j) {
            meta = this.chart.getDatasetMeta(j);
            if (meta.bar && this.chart.isDatasetVisible(j)) {
              ++barIndex
            }
          }
          return barIndex
        },
        calculateBarX: function (index, datasetIndex, ruler) {
          var me = this;
          var meta = me.getMeta();
          var xScale = me.getScaleForId(meta.xAxisID);
          var barIndex = me.getBarIndex(datasetIndex);
          var leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);
          leftTick -= me.chart.isCombo ? ruler.tickWidth / 2 : 0;
          if (xScale.options.stacked) {
            return leftTick + ruler.categoryWidth / 2 + ruler.categorySpacing
          }
          return leftTick + ruler.barWidth / 2 + ruler.categorySpacing + ruler.barWidth * barIndex + ruler.barSpacing / 2 + ruler.barSpacing * barIndex
        },
        calculateBarY: function (index, datasetIndex) {
          var me = this;
          var meta = me.getMeta();
          var yScale = me.getScaleForId(meta.yAxisID);
          var value = Number(me.getDataset().data[index]);
          if (yScale.options.stacked) {
            var sumPos = 0, sumNeg = 0;
            for (var i = 0; i < datasetIndex; i++) {
              var ds = me.chart.data.datasets[i];
              var dsMeta = me.chart.getDatasetMeta(i);
              if (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i)) {
                var stackedVal = Number(ds.data[index]);
                if (stackedVal < 0) {
                  sumNeg += stackedVal || 0
                } else {
                  sumPos += stackedVal || 0
                }
              }
            }
            if (value < 0) {
              return yScale.getPixelForValue(sumNeg + value)
            }
            return yScale.getPixelForValue(sumPos + value)
          }
          return yScale.getPixelForValue(value)
        },
        draw: function (ease) {
          var me = this;
          var easingDecimal = ease || 1;
          var metaData = me.getMeta().data;
          var dataset = me.getDataset();
          var i, len;
          for (i = 0, len = metaData.length; i < len; ++i) {
            var d = dataset.data[i];
            if (d !== null && d !== undefined && !isNaN(d)) {
              metaData[i].transition(easingDecimal).draw()
            }
          }
        },
        setHoverStyle: function (rectangle) {
          var dataset = this.chart.data.datasets[rectangle._datasetIndex];
          var index = rectangle._index;
          var custom = rectangle.custom || {};
          var model = rectangle._model;
          model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
          model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
          model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth)
        },
        removeHoverStyle: function (rectangle) {
          var dataset = this.chart.data.datasets[rectangle._datasetIndex];
          var index = rectangle._index;
          var custom = rectangle.custom || {};
          var model = rectangle._model;
          var rectangleElementOptions = this.chart.options.elements.rectangle;
          model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
          model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
          model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
        }
      });
      // including horizontalBar in the bar file, instead of a file of its own
      // it extends bar (like pie extends doughnut)
      Chart.defaults.horizontalBar = {
        hover: { mode: 'label' },
        scales: {
          xAxes: [{
              type: 'linear',
              position: 'bottom'
            }],
          yAxes: [{
              position: 'left',
              type: 'category',
              // Specific to Horizontal Bar Controller
              categoryPercentage: 0.8,
              barPercentage: 0.9,
              // grid line settings
              gridLines: { offsetGridLines: true }
            }]
        },
        elements: { rectangle: { borderSkipped: 'left' } },
        tooltips: {
          callbacks: {
            title: function (tooltipItems, data) {
              // Pick first xLabel for now
              var title = '';
              if (tooltipItems.length > 0) {
                if (tooltipItems[0].yLabel) {
                  title = tooltipItems[0].yLabel
                } else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {
                  title = data.labels[tooltipItems[0].index]
                }
              }
              return title
            },
            label: function (tooltipItem, data) {
              var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
              return datasetLabel + ': ' + tooltipItem.xLabel
            }
          }
        }
      };
      Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
        updateElement: function (rectangle, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var xScale = me.getScaleForId(meta.xAxisID);
          var yScale = me.getScaleForId(meta.yAxisID);
          var scaleBase = xScale.getBasePixel();
          var custom = rectangle.custom || {};
          var dataset = me.getDataset();
          var rectangleElementOptions = me.chart.options.elements.rectangle;
          rectangle._xScale = xScale;
          rectangle._yScale = yScale;
          rectangle._datasetIndex = me.index;
          rectangle._index = index;
          var ruler = me.getRuler(index);
          rectangle._model = {
            x: reset ? scaleBase : me.calculateBarX(index, me.index),
            y: me.calculateBarY(index, me.index, ruler),
            // Tooltip
            label: me.chart.data.labels[index],
            datasetLabel: dataset.label,
            // Appearance
            base: reset ? scaleBase : me.calculateBarBase(me.index, index),
            height: me.calculateBarHeight(ruler),
            backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),
            borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,
            borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),
            borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
          };
          rectangle.draw = function () {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var halfHeight = vm.height / 2, topY = vm.y - halfHeight, bottomY = vm.y + halfHeight, right = vm.base - (vm.base - vm.x), halfStroke = vm.borderWidth / 2;
            // Canvas doesn't allow us to stroke inside the width so we can
            // adjust the sizes to fit if we're setting a stroke on the line
            if (vm.borderWidth) {
              topY += halfStroke;
              bottomY -= halfStroke;
              right += halfStroke
            }
            ctx.beginPath();
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            ctx.lineWidth = vm.borderWidth;
            // Corner points, from bottom-left to bottom-right clockwise
            // | 1 2 |
            // | 0 3 |
            var corners = [
              [
                vm.base,
                bottomY
              ],
              [
                vm.base,
                topY
              ],
              [
                right,
                topY
              ],
              [
                right,
                bottomY
              ]
            ];
            // Find first (starting) corner with fallback to 'bottom'
            var borders = [
              'bottom',
              'left',
              'top',
              'right'
            ];
            var startCorner = borders.indexOf(vm.borderSkipped, 0);
            if (startCorner === -1) {
              startCorner = 0
            }
            function cornerAt(cornerIndex) {
              return corners[(startCorner + cornerIndex) % 4]
            }
            // Draw rectangle from 'startCorner'
            ctx.moveTo.apply(ctx, cornerAt(0));
            for (var i = 1; i < 4; i++) {
              ctx.lineTo.apply(ctx, cornerAt(i))
            }
            ctx.fill();
            if (vm.borderWidth) {
              ctx.stroke()
            }
          };
          rectangle.pivot()
        },
        calculateBarBase: function (datasetIndex, index) {
          var me = this;
          var meta = me.getMeta();
          var xScale = me.getScaleForId(meta.xAxisID);
          var base = 0;
          if (xScale.options.stacked) {
            var chart = me.chart;
            var datasets = chart.data.datasets;
            var value = Number(datasets[datasetIndex].data[index]);
            for (var i = 0; i < datasetIndex; i++) {
              var currentDs = datasets[i];
              var currentDsMeta = chart.getDatasetMeta(i);
              if (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i)) {
                var currentVal = Number(currentDs.data[index]);
                base += value < 0 ? Math.min(currentVal, 0) : Math.max(currentVal, 0)
              }
            }
            return xScale.getPixelForValue(base)
          }
          return xScale.getBasePixel()
        },
        getRuler: function (index) {
          var me = this;
          var meta = me.getMeta();
          var yScale = me.getScaleForId(meta.yAxisID);
          var datasetCount = me.getBarCount();
          var tickHeight;
          if (yScale.options.type === 'category') {
            tickHeight = yScale.getPixelForTick(index + 1) - yScale.getPixelForTick(index)
          } else {
            // Average width
            tickHeight = yScale.width / yScale.ticks.length
          }
          var categoryHeight = tickHeight * yScale.options.categoryPercentage;
          var categorySpacing = (tickHeight - tickHeight * yScale.options.categoryPercentage) / 2;
          var fullBarHeight = categoryHeight / datasetCount;
          if (yScale.ticks.length !== me.chart.data.labels.length) {
            var perc = yScale.ticks.length / me.chart.data.labels.length;
            fullBarHeight = fullBarHeight * perc
          }
          var barHeight = fullBarHeight * yScale.options.barPercentage;
          var barSpacing = fullBarHeight - fullBarHeight * yScale.options.barPercentage;
          return {
            datasetCount: datasetCount,
            tickHeight: tickHeight,
            categoryHeight: categoryHeight,
            categorySpacing: categorySpacing,
            fullBarHeight: fullBarHeight,
            barHeight: barHeight,
            barSpacing: barSpacing
          }
        },
        calculateBarHeight: function (ruler) {
          var me = this;
          var yScale = me.getScaleForId(me.getMeta().yAxisID);
          if (yScale.options.barThickness) {
            return yScale.options.barThickness
          }
          return yScale.options.stacked ? ruler.categoryHeight : ruler.barHeight
        },
        calculateBarX: function (index, datasetIndex) {
          var me = this;
          var meta = me.getMeta();
          var xScale = me.getScaleForId(meta.xAxisID);
          var value = Number(me.getDataset().data[index]);
          if (xScale.options.stacked) {
            var sumPos = 0, sumNeg = 0;
            for (var i = 0; i < datasetIndex; i++) {
              var ds = me.chart.data.datasets[i];
              var dsMeta = me.chart.getDatasetMeta(i);
              if (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i)) {
                var stackedVal = Number(ds.data[index]);
                if (stackedVal < 0) {
                  sumNeg += stackedVal || 0
                } else {
                  sumPos += stackedVal || 0
                }
              }
            }
            if (value < 0) {
              return xScale.getPixelForValue(sumNeg + value)
            }
            return xScale.getPixelForValue(sumPos + value)
          }
          return xScale.getPixelForValue(value)
        },
        calculateBarY: function (index, datasetIndex, ruler) {
          var me = this;
          var meta = me.getMeta();
          var yScale = me.getScaleForId(meta.yAxisID);
          var barIndex = me.getBarIndex(datasetIndex);
          var topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);
          topTick -= me.chart.isCombo ? ruler.tickHeight / 2 : 0;
          if (yScale.options.stacked) {
            return topTick + ruler.categoryHeight / 2 + ruler.categorySpacing
          }
          return topTick + ruler.barHeight / 2 + ruler.categorySpacing + ruler.barHeight * barIndex + ruler.barSpacing / 2 + ruler.barSpacing * barIndex
        }
      })
    }
  });
  // source: node_modules/chart.js/src/controllers/controller.bubble.js
  rqzt.define('chart.js/src/controllers/controller.bubble', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.defaults.bubble = {
        hover: { mode: 'single' },
        scales: {
          xAxes: [{
              type: 'linear',
              // bubble should probably use a linear scale by default
              position: 'bottom',
              id: 'x-axis-0'  // need an ID so datasets can reference the scale
            }],
          yAxes: [{
              type: 'linear',
              position: 'left',
              id: 'y-axis-0'
            }]
        },
        tooltips: {
          callbacks: {
            title: function () {
              // Title doesn't make sense for scatter since we format the data as a point
              return ''
            },
            label: function (tooltipItem, data) {
              var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
              var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
              return datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')'
            }
          }
        }
      };
      Chart.controllers.bubble = Chart.DatasetController.extend({
        dataElementType: Chart.elements.Point,
        update: function (reset) {
          var me = this;
          var meta = me.getMeta();
          var points = meta.data;
          // Update Points
          helpers.each(points, function (point, index) {
            me.updateElement(point, index, reset)
          })
        },
        updateElement: function (point, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var xScale = me.getScaleForId(meta.xAxisID);
          var yScale = me.getScaleForId(meta.yAxisID);
          var custom = point.custom || {};
          var dataset = me.getDataset();
          var data = dataset.data[index];
          var pointElementOptions = me.chart.options.elements.point;
          var dsIndex = me.index;
          helpers.extend(point, {
            // Utility
            _xScale: xScale,
            _yScale: yScale,
            _datasetIndex: dsIndex,
            _index: index,
            // Desired view properties
            _model: {
              x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),
              y: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),
              // Appearance
              radius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),
              // Tooltip
              hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
            }
          });
          // Trick to reset the styles of the point
          Chart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);
          var model = point._model;
          model.skip = custom.skip ? custom.skip : isNaN(model.x) || isNaN(model.y);
          point.pivot()
        },
        getRadius: function (value) {
          return value.r || this.chart.options.elements.point.radius
        },
        setHoverStyle: function (point) {
          var me = this;
          Chart.DatasetController.prototype.setHoverStyle.call(me, point);
          // Radius
          var dataset = me.chart.data.datasets[point._datasetIndex];
          var index = point._index;
          var custom = point.custom || {};
          var model = point._model;
          model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius) + me.getRadius(dataset.data[index])
        },
        removeHoverStyle: function (point) {
          var me = this;
          Chart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);
          var dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];
          var custom = point.custom || {};
          var model = point._model;
          model.radius = custom.radius ? custom.radius : me.getRadius(dataVal)
        }
      })
    }
  });
  // source: node_modules/chart.js/src/controllers/controller.doughnut.js
  rqzt.define('chart.js/src/controllers/controller.doughnut', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers, defaults = Chart.defaults;
      defaults.doughnut = {
        animation: {
          // Boolean - Whether we animate the rotation of the Doughnut
          animateRotate: true,
          // Boolean - Whether we animate scaling the Doughnut from the centre
          animateScale: false
        },
        aspectRatio: 1,
        hover: { mode: 'single' },
        legendCallback: function (chart) {
          var text = [];
          text.push('<ul class="' + chart.id + '-legend">');
          var data = chart.data;
          var datasets = data.datasets;
          var labels = data.labels;
          if (datasets.length) {
            for (var i = 0; i < datasets[0].data.length; ++i) {
              text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
              if (labels[i]) {
                text.push(labels[i])
              }
              text.push('</li>')
            }
          }
          text.push('</ul>');
          return text.join('')
        },
        legend: {
          labels: {
            generateLabels: function (chart) {
              var data = chart.data;
              if (data.labels.length && data.datasets.length) {
                return data.labels.map(function (label, i) {
                  var meta = chart.getDatasetMeta(0);
                  var ds = data.datasets[0];
                  var arc = meta.data[i];
                  var custom = arc && arc.custom || {};
                  var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
                  var arcOpts = chart.options.elements.arc;
                  var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
                  var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
                  var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
                  return {
                    text: label,
                    fillStyle: fill,
                    strokeStyle: stroke,
                    lineWidth: bw,
                    hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                    // Extra data used for toggling the correct item
                    index: i
                  }
                })
              }
              return []
            }
          },
          onClick: function (e, legendItem) {
            var index = legendItem.index;
            var chart = this.chart;
            var i, ilen, meta;
            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
              meta = chart.getDatasetMeta(i);
              // toggle visibility of index if exists
              if (meta.data[index]) {
                meta.data[index].hidden = !meta.data[index].hidden
              }
            }
            chart.update()
          }
        },
        // The percentage of the chart that we cut out of the middle.
        cutoutPercentage: 50,
        // The rotation of the chart, where the first data arc begins.
        rotation: Math.PI * -0.5,
        // The total circumference of the chart.
        circumference: Math.PI * 2,
        // Need to override these to give a nice default
        tooltips: {
          callbacks: {
            title: function () {
              return ''
            },
            label: function (tooltipItem, data) {
              var dataLabel = data.labels[tooltipItem.index];
              var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
              if (helpers.isArray(dataLabel)) {
                // show value on first line of multiline label
                // need to clone because we are changing the value
                dataLabel = dataLabel.slice();
                dataLabel[0] += value
              } else {
                dataLabel += value
              }
              return dataLabel
            }
          }
        }
      };
      defaults.pie = helpers.clone(defaults.doughnut);
      helpers.extend(defaults.pie, { cutoutPercentage: 0 });
      Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
        dataElementType: Chart.elements.Arc,
        linkScales: helpers.noop,
        // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
        getRingIndex: function (datasetIndex) {
          var ringIndex = 0;
          for (var j = 0; j < datasetIndex; ++j) {
            if (this.chart.isDatasetVisible(j)) {
              ++ringIndex
            }
          }
          return ringIndex
        },
        update: function (reset) {
          var me = this;
          var chart = me.chart, chartArea = chart.chartArea, opts = chart.options, arcOpts = opts.elements.arc, availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth, availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth, minSize = Math.min(availableWidth, availableHeight), offset = {
              x: 0,
              y: 0
            }, meta = me.getMeta(), cutoutPercentage = opts.cutoutPercentage, circumference = opts.circumference;
          // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
          if (circumference < Math.PI * 2) {
            var startAngle = opts.rotation % (Math.PI * 2);
            startAngle += Math.PI * 2 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
            var endAngle = startAngle + circumference;
            var start = {
              x: Math.cos(startAngle),
              y: Math.sin(startAngle)
            };
            var end = {
              x: Math.cos(endAngle),
              y: Math.sin(endAngle)
            };
            var contains0 = startAngle <= 0 && 0 <= endAngle || startAngle <= Math.PI * 2 && Math.PI * 2 <= endAngle;
            var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
            var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
            var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
            var cutout = cutoutPercentage / 100;
            var min = {
              x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
              y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
            };
            var max = {
              x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
              y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
            };
            var size = {
              width: (max.x - min.x) * 0.5,
              height: (max.y - min.y) * 0.5
            };
            minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
            offset = {
              x: (max.x + min.x) * -0.5,
              y: (max.y + min.y) * -0.5
            }
          }
          chart.borderWidth = me.getMaxBorderWidth(meta.data);
          chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
          chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 1, 0);
          chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
          chart.offsetX = offset.x * chart.outerRadius;
          chart.offsetY = offset.y * chart.outerRadius;
          meta.total = me.calculateTotal();
          me.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);
          me.innerRadius = me.outerRadius - chart.radiusLength;
          helpers.each(meta.data, function (arc, index) {
            me.updateElement(arc, index, reset)
          })
        },
        updateElement: function (arc, index, reset) {
          var me = this;
          var chart = me.chart, chartArea = chart.chartArea, opts = chart.options, animationOpts = opts.animation, centerX = (chartArea.left + chartArea.right) / 2, centerY = (chartArea.top + chartArea.bottom) / 2, startAngle = opts.rotation,
            // non reset case handled later
            endAngle = opts.rotation,
            // non reset case handled later
            dataset = me.getDataset(), circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2 * Math.PI)), innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius, outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius, valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
          helpers.extend(arc, {
            // Utility
            _datasetIndex: me.index,
            _index: index,
            // Desired view properties
            _model: {
              x: centerX + chart.offsetX,
              y: centerY + chart.offsetY,
              startAngle: startAngle,
              endAngle: endAngle,
              circumference: circumference,
              outerRadius: outerRadius,
              innerRadius: innerRadius,
              label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
            }
          });
          var model = arc._model;
          // Resets the visual styles
          this.removeHoverStyle(arc);
          // Set correct angles if not resetting
          if (!reset || !animationOpts.animateRotate) {
            if (index === 0) {
              model.startAngle = opts.rotation
            } else {
              model.startAngle = me.getMeta().data[index - 1]._model.endAngle
            }
            model.endAngle = model.startAngle + model.circumference
          }
          arc.pivot()
        },
        removeHoverStyle: function (arc) {
          Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc)
        },
        calculateTotal: function () {
          var dataset = this.getDataset();
          var meta = this.getMeta();
          var total = 0;
          var value;
          helpers.each(meta.data, function (element, index) {
            value = dataset.data[index];
            if (!isNaN(value) && !element.hidden) {
              total += Math.abs(value)
            }
          });
          /* if (total === 0) {
				total = NaN;
			}*/
          return total
        },
        calculateCircumference: function (value) {
          var total = this.getMeta().total;
          if (total > 0 && !isNaN(value)) {
            return Math.PI * 2 * (value / total)
          }
          return 0
        },
        // gets the max border or hover width to properly scale pie charts
        getMaxBorderWidth: function (elements) {
          var max = 0, index = this.index, length = elements.length, borderWidth, hoverWidth;
          for (var i = 0; i < length; i++) {
            borderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;
            hoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max
          }
          return max
        }
      })
    }
  });
  // source: node_modules/chart.js/src/controllers/controller.line.js
  rqzt.define('chart.js/src/controllers/controller.line', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.defaults.line = {
        showLines: true,
        spanGaps: false,
        hover: { mode: 'label' },
        scales: {
          xAxes: [{
              type: 'category',
              id: 'x-axis-0'
            }],
          yAxes: [{
              type: 'linear',
              id: 'y-axis-0'
            }]
        }
      };
      function lineEnabled(dataset, options) {
        return helpers.getValueOrDefault(dataset.showLine, options.showLines)
      }
      Chart.controllers.line = Chart.DatasetController.extend({
        datasetElementType: Chart.elements.Line,
        dataElementType: Chart.elements.Point,
        update: function (reset) {
          var me = this;
          var meta = me.getMeta();
          var line = meta.dataset;
          var points = meta.data || [];
          var options = me.chart.options;
          var lineElementOptions = options.elements.line;
          var scale = me.getScaleForId(meta.yAxisID);
          var i, ilen, custom;
          var dataset = me.getDataset();
          var showLine = lineEnabled(dataset, options);
          // Update Line
          if (showLine) {
            custom = line.custom || {};
            // Compatibility: If the properties are defined with only the old name, use those values
            if (dataset.tension !== undefined && dataset.lineTension === undefined) {
              dataset.lineTension = dataset.tension
            }
            // Utility
            line._scale = scale;
            line._datasetIndex = me.index;
            // Data
            line._children = points;
            // Model
            line._model = {
              // Appearance
              // The default behavior of lines is to break at null values, according
              // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
              // This option gives lines the ability to span gaps
              spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
              tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
              backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
              borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
              borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
              borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
              borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
              borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
              borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
              fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
              steppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
              cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
              // Scale
              scaleTop: scale.top,
              scaleBottom: scale.bottom,
              scaleZero: scale.getBasePixel()
            };
            line.pivot()
          }
          // Update Points
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            me.updateElement(points[i], i, reset)
          }
          if (showLine && line._model.tension !== 0) {
            me.updateBezierControlPoints()
          }
          // Now pivot the point for animation
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            points[i].pivot()
          }
        },
        getPointBackgroundColor: function (point, index) {
          var backgroundColor = this.chart.options.elements.point.backgroundColor;
          var dataset = this.getDataset();
          var custom = point.custom || {};
          if (custom.backgroundColor) {
            backgroundColor = custom.backgroundColor
          } else if (dataset.pointBackgroundColor) {
            backgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor)
          } else if (dataset.backgroundColor) {
            backgroundColor = dataset.backgroundColor
          }
          return backgroundColor
        },
        getPointBorderColor: function (point, index) {
          var borderColor = this.chart.options.elements.point.borderColor;
          var dataset = this.getDataset();
          var custom = point.custom || {};
          if (custom.borderColor) {
            borderColor = custom.borderColor
          } else if (dataset.pointBorderColor) {
            borderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor)
          } else if (dataset.borderColor) {
            borderColor = dataset.borderColor
          }
          return borderColor
        },
        getPointBorderWidth: function (point, index) {
          var borderWidth = this.chart.options.elements.point.borderWidth;
          var dataset = this.getDataset();
          var custom = point.custom || {};
          if (custom.borderWidth) {
            borderWidth = custom.borderWidth
          } else if (dataset.pointBorderWidth) {
            borderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth)
          } else if (dataset.borderWidth) {
            borderWidth = dataset.borderWidth
          }
          return borderWidth
        },
        updateElement: function (point, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var custom = point.custom || {};
          var dataset = me.getDataset();
          var datasetIndex = me.index;
          var value = dataset.data[index];
          var yScale = me.getScaleForId(meta.yAxisID);
          var xScale = me.getScaleForId(meta.xAxisID);
          var pointOptions = me.chart.options.elements.point;
          var x, y;
          var labels = me.chart.data.labels || [];
          var includeOffset = labels.length === 1 || dataset.data.length === 1 || me.chart.isCombo;
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
            dataset.pointRadius = dataset.radius
          }
          if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
            dataset.pointHitRadius = dataset.hitRadius
          }
          x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);
          y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
          // Utility
          point._xScale = xScale;
          point._yScale = yScale;
          point._datasetIndex = datasetIndex;
          point._index = index;
          // Desired view properties
          point._model = {
            x: x,
            y: y,
            skip: custom.skip || isNaN(x) || isNaN(y),
            // Appearance
            radius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
            pointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
            backgroundColor: me.getPointBackgroundColor(point, index),
            borderColor: me.getPointBorderColor(point, index),
            borderWidth: me.getPointBorderWidth(point, index),
            tension: meta.dataset._model ? meta.dataset._model.tension : 0,
            steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
            // Tooltip
            hitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
          }
        },
        calculatePointY: function (value, index, datasetIndex) {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();
          var yScale = me.getScaleForId(meta.yAxisID);
          var sumPos = 0;
          var sumNeg = 0;
          var i, ds, dsMeta;
          if (yScale.options.stacked) {
            for (i = 0; i < datasetIndex; i++) {
              ds = chart.data.datasets[i];
              dsMeta = chart.getDatasetMeta(i);
              if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
                var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
                if (stackedRightValue < 0) {
                  sumNeg += stackedRightValue || 0
                } else {
                  sumPos += stackedRightValue || 0
                }
              }
            }
            var rightValue = Number(yScale.getRightValue(value));
            if (rightValue < 0) {
              return yScale.getPixelForValue(sumNeg + rightValue)
            }
            return yScale.getPixelForValue(sumPos + rightValue)
          }
          return yScale.getPixelForValue(value)
        },
        updateBezierControlPoints: function () {
          var me = this;
          var meta = me.getMeta();
          var area = me.chart.chartArea;
          var points = meta.data || [];
          var i, ilen, point, model, controlPoints;
          // Only consider points that are drawn in case the spanGaps option is used
          if (meta.dataset._model.spanGaps) {
            points = points.filter(function (pt) {
              return !pt._model.skip
            })
          }
          function capControlPoint(pt, min, max) {
            return Math.max(Math.min(pt, max), min)
          }
          if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
            helpers.splineCurveMonotone(points)
          } else {
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              point = points[i];
              model = point._model;
              controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);
              model.controlPointPreviousX = controlPoints.previous.x;
              model.controlPointPreviousY = controlPoints.previous.y;
              model.controlPointNextX = controlPoints.next.x;
              model.controlPointNextY = controlPoints.next.y
            }
          }
          if (me.chart.options.elements.line.capBezierPoints) {
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              model = points[i]._model;
              model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
              model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
              model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom)
            }
          }
        },
        draw: function (ease) {
          var me = this;
          var meta = me.getMeta();
          var points = meta.data || [];
          var easingDecimal = ease || 1;
          var i, ilen;
          // Transition Point Locations
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            points[i].transition(easingDecimal)
          }
          // Transition and Draw the line
          if (lineEnabled(me.getDataset(), me.chart.options)) {
            meta.dataset.transition(easingDecimal).draw()
          }
          // Draw the points
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            points[i].draw()
          }
        },
        setHoverStyle: function (point) {
          // Point
          var dataset = this.chart.data.datasets[point._datasetIndex];
          var index = point._index;
          var custom = point.custom || {};
          var model = point._model;
          model.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
          model.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
          model.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
          model.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth)
        },
        removeHoverStyle: function (point) {
          var me = this;
          var dataset = me.chart.data.datasets[point._datasetIndex];
          var index = point._index;
          var custom = point.custom || {};
          var model = point._model;
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
            dataset.pointRadius = dataset.radius
          }
          model.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
          model.backgroundColor = me.getPointBackgroundColor(point, index);
          model.borderColor = me.getPointBorderColor(point, index);
          model.borderWidth = me.getPointBorderWidth(point, index)
        }
      })
    }
  });
  // source: node_modules/chart.js/src/controllers/controller.polarArea.js
  rqzt.define('chart.js/src/controllers/controller.polarArea', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.defaults.polarArea = {
        scale: {
          type: 'radialLinear',
          lineArc: true,
          // so that lines are circular
          ticks: { beginAtZero: true }
        },
        // Boolean - Whether to animate the rotation of the chart
        animation: {
          animateRotate: true,
          animateScale: true
        },
        startAngle: -0.5 * Math.PI,
        aspectRatio: 1,
        legendCallback: function (chart) {
          var text = [];
          text.push('<ul class="' + chart.id + '-legend">');
          var data = chart.data;
          var datasets = data.datasets;
          var labels = data.labels;
          if (datasets.length) {
            for (var i = 0; i < datasets[0].data.length; ++i) {
              text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
              if (labels[i]) {
                text.push(labels[i])
              }
              text.push('</li>')
            }
          }
          text.push('</ul>');
          return text.join('')
        },
        legend: {
          labels: {
            generateLabels: function (chart) {
              var data = chart.data;
              if (data.labels.length && data.datasets.length) {
                return data.labels.map(function (label, i) {
                  var meta = chart.getDatasetMeta(0);
                  var ds = data.datasets[0];
                  var arc = meta.data[i];
                  var custom = arc.custom || {};
                  var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
                  var arcOpts = chart.options.elements.arc;
                  var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
                  var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
                  var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
                  return {
                    text: label,
                    fillStyle: fill,
                    strokeStyle: stroke,
                    lineWidth: bw,
                    hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                    // Extra data used for toggling the correct item
                    index: i
                  }
                })
              }
              return []
            }
          },
          onClick: function (e, legendItem) {
            var index = legendItem.index;
            var chart = this.chart;
            var i, ilen, meta;
            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
              meta = chart.getDatasetMeta(i);
              meta.data[index].hidden = !meta.data[index].hidden
            }
            chart.update()
          }
        },
        // Need to override these to give a nice default
        tooltips: {
          callbacks: {
            title: function () {
              return ''
            },
            label: function (tooltipItem, data) {
              return data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel
            }
          }
        }
      };
      Chart.controllers.polarArea = Chart.DatasetController.extend({
        dataElementType: Chart.elements.Arc,
        linkScales: helpers.noop,
        update: function (reset) {
          var me = this;
          var chart = me.chart;
          var chartArea = chart.chartArea;
          var meta = me.getMeta();
          var opts = chart.options;
          var arcOpts = opts.elements.arc;
          var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
          chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
          me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
          me.innerRadius = me.outerRadius - chart.radiusLength;
          meta.count = me.countVisibleElements();
          helpers.each(meta.data, function (arc, index) {
            me.updateElement(arc, index, reset)
          })
        },
        updateElement: function (arc, index, reset) {
          var me = this;
          var chart = me.chart;
          var dataset = me.getDataset();
          var opts = chart.options;
          var animationOpts = opts.animation;
          var scale = chart.scale;
          var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
          var labels = chart.data.labels;
          var circumference = me.calculateCircumference(dataset.data[index]);
          var centerX = scale.xCenter;
          var centerY = scale.yCenter;
          // If there is NaN data before us, we need to calculate the starting angle correctly.
          // We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
          var visibleCount = 0;
          var meta = me.getMeta();
          for (var i = 0; i < index; ++i) {
            if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
              ++visibleCount
            }
          }
          // var negHalfPI = -0.5 * Math.PI;
          var datasetStartAngle = opts.startAngle;
          var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
          var startAngle = datasetStartAngle + circumference * visibleCount;
          var endAngle = startAngle + (arc.hidden ? 0 : circumference);
          var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
          helpers.extend(arc, {
            // Utility
            _datasetIndex: me.index,
            _index: index,
            _scale: scale,
            // Desired view properties
            _model: {
              x: centerX,
              y: centerY,
              innerRadius: 0,
              outerRadius: reset ? resetRadius : distance,
              startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
              endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
              label: getValueAtIndexOrDefault(labels, index, labels[index])
            }
          });
          // Apply border and fill style
          me.removeHoverStyle(arc);
          arc.pivot()
        },
        removeHoverStyle: function (arc) {
          Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc)
        },
        countVisibleElements: function () {
          var dataset = this.getDataset();
          var meta = this.getMeta();
          var count = 0;
          helpers.each(meta.data, function (element, index) {
            if (!isNaN(dataset.data[index]) && !element.hidden) {
              count++
            }
          });
          return count
        },
        calculateCircumference: function (value) {
          var count = this.getMeta().count;
          if (count > 0 && !isNaN(value)) {
            return 2 * Math.PI / count
          }
          return 0
        }
      })
    }
  });
  // source: node_modules/chart.js/src/controllers/controller.radar.js
  rqzt.define('chart.js/src/controllers/controller.radar', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var helpers = Chart.helpers;
      Chart.defaults.radar = {
        aspectRatio: 1,
        scale: { type: 'radialLinear' },
        elements: {
          line: {
            tension: 0  // no bezier in radar
          }
        }
      };
      Chart.controllers.radar = Chart.DatasetController.extend({
        datasetElementType: Chart.elements.Line,
        dataElementType: Chart.elements.Point,
        linkScales: helpers.noop,
        update: function (reset) {
          var me = this;
          var meta = me.getMeta();
          var line = meta.dataset;
          var points = meta.data;
          var custom = line.custom || {};
          var dataset = me.getDataset();
          var lineElementOptions = me.chart.options.elements.line;
          var scale = me.chart.scale;
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension
          }
          helpers.extend(meta.dataset, {
            // Utility
            _datasetIndex: me.index,
            // Data
            _children: points,
            _loop: true,
            // Model
            _model: {
              // Appearance
              tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
              backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
              borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
              borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
              fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
              borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
              borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
              borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
              borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
              // Scale
              scaleTop: scale.top,
              scaleBottom: scale.bottom,
              scaleZero: scale.getBasePosition()
            }
          });
          meta.dataset.pivot();
          // Update Points
          helpers.each(points, function (point, index) {
            me.updateElement(point, index, reset)
          }, me);
          // Update bezier control points
          me.updateBezierControlPoints()
        },
        updateElement: function (point, index, reset) {
          var me = this;
          var custom = point.custom || {};
          var dataset = me.getDataset();
          var scale = me.chart.scale;
          var pointElementOptions = me.chart.options.elements.point;
          var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
          helpers.extend(point, {
            // Utility
            _datasetIndex: me.index,
            _index: index,
            _scale: scale,
            // Desired view properties
            _model: {
              x: reset ? scale.xCenter : pointPosition.x,
              // value not used in dataset scale, but we want a consistent API between scales
              y: reset ? scale.yCenter : pointPosition.y,
              // Appearance
              tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.tension, me.chart.options.elements.line.tension),
              radius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
              backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
              borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
              borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
              pointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
              // Tooltip
              hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
            }
          });
          point._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y)
        },
        updateBezierControlPoints: function () {
          var chartArea = this.chart.chartArea;
          var meta = this.getMeta();
          helpers.each(meta.data, function (point, index) {
            var model = point._model;
            var controlPoints = helpers.splineCurve(helpers.previousItem(meta.data, index, true)._model, model, helpers.nextItem(meta.data, index, true)._model, model.tension);
            // Prevent the bezier going outside of the bounds of the graph
            model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
            model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
            model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
            model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);
            // Now pivot the point for animation
            point.pivot()
          })
        },
        draw: function (ease) {
          var meta = this.getMeta();
          var easingDecimal = ease || 1;
          // Transition Point Locations
          helpers.each(meta.data, function (point) {
            point.transition(easingDecimal)
          });
          // Transition and Draw the line
          meta.dataset.transition(easingDecimal).draw();
          // Draw the points
          helpers.each(meta.data, function (point) {
            point.draw()
          })
        },
        setHoverStyle: function (point) {
          // Point
          var dataset = this.chart.data.datasets[point._datasetIndex];
          var custom = point.custom || {};
          var index = point._index;
          var model = point._model;
          model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
          model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
          model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
          model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth)
        },
        removeHoverStyle: function (point) {
          var dataset = this.chart.data.datasets[point._datasetIndex];
          var custom = point.custom || {};
          var index = point._index;
          var model = point._model;
          var pointElementOptions = this.chart.options.elements.point;
          model.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);
          model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
          model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
          model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth)
        }
      })
    }
  });
  // source: node_modules/chart.js/src/charts/Chart.Bar.js
  rqzt.define('chart.js/src/charts/Chart.Bar', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      Chart.Bar = function (context, config) {
        config.type = 'bar';
        return new Chart(context, config)
      }
    }
  });
  // source: node_modules/chart.js/src/charts/Chart.Bubble.js
  rqzt.define('chart.js/src/charts/Chart.Bubble', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      Chart.Bubble = function (context, config) {
        config.type = 'bubble';
        return new Chart(context, config)
      }
    }
  });
  // source: node_modules/chart.js/src/charts/Chart.Doughnut.js
  rqzt.define('chart.js/src/charts/Chart.Doughnut', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      Chart.Doughnut = function (context, config) {
        config.type = 'doughnut';
        return new Chart(context, config)
      }
    }
  });
  // source: node_modules/chart.js/src/charts/Chart.Line.js
  rqzt.define('chart.js/src/charts/Chart.Line', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      Chart.Line = function (context, config) {
        config.type = 'line';
        return new Chart(context, config)
      }
    }
  });
  // source: node_modules/chart.js/src/charts/Chart.PolarArea.js
  rqzt.define('chart.js/src/charts/Chart.PolarArea', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      Chart.PolarArea = function (context, config) {
        config.type = 'polarArea';
        return new Chart(context, config)
      }
    }
  });
  // source: node_modules/chart.js/src/charts/Chart.Radar.js
  rqzt.define('chart.js/src/charts/Chart.Radar', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      Chart.Radar = function (context, config) {
        config.type = 'radar';
        return new Chart(context, config)
      }
    }
  });
  // source: node_modules/chart.js/src/charts/Chart.Scatter.js
  rqzt.define('chart.js/src/charts/Chart.Scatter', function (module, exports, __dirname, __filename, process) {
    'use strict';
    module.exports = function (Chart) {
      var defaultConfig = {
        hover: { mode: 'single' },
        scales: {
          xAxes: [{
              type: 'linear',
              // scatter should not use a category axis
              position: 'bottom',
              id: 'x-axis-1'  // need an ID so datasets can reference the scale
            }],
          yAxes: [{
              type: 'linear',
              position: 'left',
              id: 'y-axis-1'
            }]
        },
        tooltips: {
          callbacks: {
            title: function () {
              // Title doesn't make sense for scatter since we format the data as a point
              return ''
            },
            label: function (tooltipItem) {
              return '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')'
            }
          }
        }
      };
      // Register the default config for this type
      Chart.defaults.scatter = defaultConfig;
      // Scatter charts use line controllers
      Chart.controllers.scatter = Chart.controllers.line;
      Chart.Scatter = function (context, config) {
        config.type = 'scatter';
        return new Chart(context, config)
      }
    }
  });
  // source: assets/js/dash/dash.coffee
  rqzt.define('./dash', function (module, exports, __dirname, __filename, process) {
    var _, crowdcontrol, riot;
    riot = rqzt('riot/riot');
    _ = rqzt('underscore/underscore');
    window.riot = riot;
    crowdcontrol = rqzt('crowdcontrol/lib');
    window.moment = rqzt('moment/moment');
    window.crowdstart = {
      site: rqzt('./site'),
      table: rqzt('./table'),
      form: rqzt('./form'),
      widget: rqzt('./widget'),
      util: rqzt('./util'),
      visual: rqzt('./visual')
    }
  });
  rqzt('./dash')
}.call(this, this))