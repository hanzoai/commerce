package cryptopaymentintent

import (
	"fmt"
	"time"

	"github.com/hanzoai/commerce/models/mixin"
)

// Status represents the lifecycle state of a crypto payment.
type Status string

const (
	Pending    Status = "pending"     // Awaiting deposit
	Confirming Status = "confirming"  // Deposit detected, awaiting confirmations
	Succeeded  Status = "succeeded"   // Fully confirmed + settled
	Expired    Status = "expired"     // No deposit received before timeout
	Failed     Status = "failed"      // Deposit failed (reorg, etc.)
	Refunded   Status = "refunded"    // Refund issued on-chain
)

// Chain represents a supported blockchain.
type Chain string

const (
	Ethereum Chain = "ethereum"
	Solana   Chain = "solana"
	Base     Chain = "base"
	Polygon  Chain = "polygon"
	Arbitrum Chain = "arbitrum"
)

// CryptoPaymentIntent represents a custodial crypto/stablecoin payment flow.
type CryptoPaymentIntent struct {
	mixin.Model

	// Amount in smallest unit of settlement currency (cents for USD)
	Amount int64 `json:"amount"`

	// Settlement currency (fiat, e.g., "usd")
	Currency string `json:"currency"`

	// Blockchain where deposit is expected
	Chain Chain `json:"chain"`

	// Token on the chain (e.g., "usdc", "usdt", "eth")
	Token string `json:"token"`

	// Per-payment deposit address (generated by custody service)
	DepositAddress string `json:"depositAddress"`

	// Customer reference
	CustomerRef string `json:"customerRef,omitempty"`

	// Current status
	Status Status `json:"status"`

	// Number of confirmations received
	Confirmations int `json:"confirmations"`

	// Number of confirmations required
	RequiredConfirmations int `json:"requiredConfirmations"`

	// On-chain transaction hash (once detected)
	TxHash string `json:"txHash,omitempty"`

	// Block number where deposit was included
	BlockNumber int64 `json:"blockNumber,omitempty"`

	// Payment expiry (typically 30-60 minutes)
	ExpiresAt time.Time `json:"expiresAt"`

	// Fiat-equivalent amount after conversion
	SettlementAmount int64 `json:"settlementAmount"`

	// Settlement currency
	SettlementCurrency string `json:"settlementCurrency"`

	// Exchange rate at time of settlement
	ExchangeRate string `json:"exchangeRate,omitempty"`

	// Crypto amount in token's smallest unit (wei, lamports, etc.)
	CryptoAmount string `json:"cryptoAmount,omitempty"`

	// Refund transaction hash (if refunded)
	RefundTxHash string `json:"refundTxHash,omitempty"`

	// OFAC screening result
	ScreeningStatus string `json:"screeningStatus,omitempty"` // clear, flagged, blocked

	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// MarkConfirming transitions to confirming state when deposit is detected.
func (cpi *CryptoPaymentIntent) MarkConfirming(txHash string, blockNumber int64) error {
	if cpi.Status != Pending {
		return fmt.Errorf("cannot mark confirming: current status %s", cpi.Status)
	}
	cpi.Status = Confirming
	cpi.TxHash = txHash
	cpi.BlockNumber = blockNumber
	return nil
}

// AddConfirmation records a new block confirmation.
func (cpi *CryptoPaymentIntent) AddConfirmation() {
	cpi.Confirmations++
}

// IsFullyConfirmed returns true if required confirmations are met.
func (cpi *CryptoPaymentIntent) IsFullyConfirmed() bool {
	return cpi.Confirmations >= cpi.RequiredConfirmations
}

// MarkSucceeded transitions to succeeded after full confirmation.
func (cpi *CryptoPaymentIntent) MarkSucceeded(settlementAmount int64, exchangeRate string) error {
	if cpi.Status != Confirming {
		return fmt.Errorf("cannot mark succeeded: current status %s", cpi.Status)
	}
	if !cpi.IsFullyConfirmed() {
		return fmt.Errorf("insufficient confirmations: %d/%d", cpi.Confirmations, cpi.RequiredConfirmations)
	}
	cpi.Status = Succeeded
	cpi.SettlementAmount = settlementAmount
	cpi.ExchangeRate = exchangeRate
	return nil
}

// MarkExpired transitions to expired if no deposit received.
func (cpi *CryptoPaymentIntent) MarkExpired() error {
	if cpi.Status != Pending {
		return fmt.Errorf("cannot expire: current status %s", cpi.Status)
	}
	cpi.Status = Expired
	return nil
}

// MarkFailed transitions to failed (e.g., reorg caused loss).
func (cpi *CryptoPaymentIntent) MarkFailed(reason string) error {
	if cpi.Status == Succeeded || cpi.Status == Refunded {
		return fmt.Errorf("cannot fail: current status %s", cpi.Status)
	}
	cpi.Status = Failed
	return nil
}

// IsExpired returns true if the payment window has closed.
func (cpi *CryptoPaymentIntent) IsExpired() bool {
	return !cpi.ExpiresAt.IsZero() && time.Now().After(cpi.ExpiresAt)
}

// RequiredConfirmationsForChain returns the default confirmation count.
func RequiredConfirmationsForChain(chain Chain) int {
	switch chain {
	case Ethereum:
		return 12
	case Base, Polygon, Arbitrum:
		return 20
	case Solana:
		return 32
	default:
		return 12
	}
}
